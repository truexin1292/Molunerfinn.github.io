<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARKSZのBlog</title>
  
  <subtitle>Do what you love,Love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://molunerfinn.com/"/>
  <updated>2018-11-19T15:29:00.610Z</updated>
  <id>https://molunerfinn.com/</id>
  
  <author>
    <name>Molunerfinn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一周一部好电影V【WEEK210 网络迷踪】</title>
    <link href="https://molunerfinn.com/PerfectMoviePerWeek5/"/>
    <id>https://molunerfinn.com/PerfectMoviePerWeek5/</id>
    <published>2018-11-19T22:29:00.000Z</published>
    <updated>2018-11-19T15:29:00.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018-11-11-WEEK210-网络迷踪"><a href="#2018-11-11-WEEK210-网络迷踪" class="headerlink" title="2018-11-11 WEEK210 网络迷踪"></a>2018-11-11 WEEK210 网络迷踪</h3><p>网络迷踪——————————————Searching<br><img src="https://img.piegg.cn/week210.jpg?imgslim" alt="网络迷踪"></p><ul><li>导演：阿尼什·查甘蒂</li><li>主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯尼/康纳·麦克雷斯/科林·伍德尔/约瑟夫·约翰·谢尔勒/阿什丽·艾德纳/托马斯·巴布萨卡/朱莉·内桑森/罗伊·阿布拉姆森/盖奇·<br>比尔托福/肖恩·奥布赖恩/瑞克·萨拉比亚/布拉德·阿布瑞尔/加布里埃尔D·安吉尔</li><li>片长：102分钟</li><li>影 片类型：剧情/悬疑/惊悚</li><li>豆 瓣评分：8.7/10(from85,981users)</li><li>IMDB评分：7.8/10(from38,178users)</li></ul><a id="more"></a><p>Hi，各位好久不见！（最近在忙毕设开题的事，所以一直没办法按期完成推送。等忙过这一段就能大致恢复正常。）这部电影可以说是小成本制作的典范之作了。全片很有意思，大部分用的镜头来自手机、电脑的前置摄像头，然后配合电脑、手机屏幕的聊天记录、网页记录等来描述故事、展现角色心理状态。很多时候刚敲完的文字，然后想了想又删掉的光标；在屏幕前停留的视线等等都会让你身临其境——因为这些场景在我们当今的生活中，真的司空见惯。</p><p>可以说手机和电脑加上互联网已经占据了很多人一天的大部分。本片也聚焦在当前的网络环境下的人与人之间，父母和孩子之间的关系。我们经常会对父母隐藏自己的某一面，而在互联网上却又是另一副的面孔。所以很多时候本该最了解我们的人，却成了最熟悉的陌生人。当然，意外的惊喜是本片还加入了很不错的悬疑元素，真相大白的那刻，总算把你觉得不对劲的地方说了出来，但是却让你依然感觉很过瘾。好电影，值得一看！</p><hr><h3 id="2018-10-07-WEEK209-奇迹男孩"><a href="#2018-10-07-WEEK209-奇迹男孩" class="headerlink" title="2018-10-07 WEEK209 奇迹男孩"></a>2018-10-07 WEEK209 奇迹男孩</h3><p>奇迹男孩——————————————Wonder<br><img src="https://img.piegg.cn/week209.jpg?imgslim" alt="奇迹男孩"></p><ul><li>导演：斯蒂芬·卓博斯基</li><li>主演：雅各布·特伦布莱/朱莉娅·罗伯茨/伊扎贝拉·维多维奇/欧文·威尔逊/诺亚·尤佩/丹妮尔·罗丝·拉塞尔/纳吉·杰特/戴维<br>德·迪格斯/曼迪·帕廷金/布莱斯·吉扎尔/艾尔·麦金农/泰·孔西利奥/詹姆斯·休斯/凯尔·布瑞特科夫/米莉·戴维斯/莉娅·朱厄<br>特/凯琳·布瑞特科夫/利亚姆·迪金森/艾玛·特伦布莱/马克·多兹劳/鲁奇娅·伯纳德/J·道格拉斯·斯图瓦特/阿里·利伯特/埃丽卡<br>·麦基特里克/本杰明·拉特纳/杰森·麦金农/索尼娅·布拉加/吉洁特</li><li>片长：113分钟</li><li>影 片类型：剧情/家庭/儿童</li><li>豆 瓣评分：8.6/10(from211,803users)</li><li>IMDB评分：8.0/10(from89,828users)</li></ul><!--more--><p>Hi，各位好久不见！本周给大家推荐的是一部来自美国的《奇迹男孩》。从片名就可以看出是讲述一个小男孩的故事。温馨的故事很多，不过各有各打动人的地方。本片讲述的故事可能并没有什么出奇的地方，甚至你也有可能遇到类似的例子。影片中的的主要角色都有自己的一段独白戏。而从独白戏中，你才可以看到那些角色真实的自己。</p><p>就像行星绕着恒星转一样，我们的生活中也或多或少会围着某个人转。在关心他人的同时不得不遮盖自己的伤疤。但其实很多时候跟对方坦诚相待能获得更好的效果。要成为一个善良的人，要做善良的事。温馨的电影，值得一看~</p><hr><h3 id="2018-09-23-WEEK208-谍影重重"><a href="#2018-09-23-WEEK208-谍影重重" class="headerlink" title="2018-09-23 WEEK208 谍影重重"></a>2018-09-23 WEEK208 谍影重重</h3><p>谍影重重——————————————The Bourne Identity<br><img src="https://img.piegg.cn/week208.jpg?imgslim" alt="谍影重重"></p><ul><li>导演：道格·里曼</li><li>主演：马特·达蒙/弗朗卡·波滕特/克里斯·库珀/克里夫·欧文/朱丽娅·斯蒂尔斯/布莱恩·考克斯/阿德沃尔·阿吉纽依-艾格拜吉/加布里埃尔·曼/沃尔顿·戈金斯/约什·汉密尔顿/Orso Maria Guerrini</li><li>片长：119分钟</li><li>影 片类型：动作/悬疑/惊悚</li><li>豆 瓣评分：8.5/10(from215,888users)</li><li>IMDB评分：7.9/10(from461,682users)</li></ul><!--more--><p>Hi，各位好久不见！继上次看完《碟中谍6》之后，在经过舍友的推荐后我找来了另外一部讲述特工的电影《谍影重重》。跟《碟中谍》系列不同的是，《谍影重重》系列的男主角马特达蒙并没有阿汤哥那样帅到让你印象深刻。相反他一开始并不吸引人。</p><p>如果说《007》的看点是特工+美女，《碟中谍》的看点是阿汤哥的颜和拼命，那么《谍影重重》的看点就真的是一个特工的自我救赎了。我想推荐的并不是这一部电影，而是这整个系列（1、2、3、5部）。并且这里面每一部的水平、评分都很高。可以说是荧幕上「最为真实」的讲述间谍、特工的电影了。在这里面你是能真的学习到一些常人并不会特意关注到的细节。伯恩的招式可能没有那么华丽，但是是招招制敌，干净利落不拖泥带水，剧情的发展也是一波三折，紧凑而牵动人心。作为一部动作、悬疑电影我觉得虽然动作戏不如《碟中谍》那么华丽但是也已经足够帮。</p><p>其实第一部已经做得很出色，没想到第二部、第三部也同样出彩。好电影，值得一看。</p><hr><h3 id="2018-09-16-WEEK207-走到尽头"><a href="#2018-09-16-WEEK207-走到尽头" class="headerlink" title="2018-09-16 WEEK207 走到尽头"></a>2018-09-16 WEEK207 走到尽头</h3><p>走到尽头——————————————끝까지 간다<br><img src="https://img.piegg.cn/week207.jpg?imgslim" alt="走到尽头"></p><ul><li>导演：金成勋</li><li>主演：李善均/赵震雄/郑满植/申东美/申正根/朴宝剑</li><li>片长：111分钟</li><li>影 片类型：动作/惊悚/犯罪</li><li>豆 瓣评分：7.8/10(from41,868users)</li><li>IMDB评分：7.2/10(from7,509users)</li></ul><!--more--><p>Hi，各位好久不见！本周给大家推荐的是一部来自韩国的《走到尽头》。这部电影我在3年前曾看过一次，不过最近重新又看了一遍依然感觉十分不错。</p><p>从影片一开始就开始就把观众带入非常紧张、刺激的情节，让人不由自主地为主角捏一把汗。而后的矛盾冲突又依然保持着高度的紧张和不突兀的幽默镜头。而随着剧情的推进，不断地反转也是让人看得很是过瘾。可以说是不停地用新的错误掩盖旧的错误。我想虽然电影有所夸张，但是现实中的我们却总会有类似的时刻。环环相扣的剧情在影片的最后达到高潮。开放式的结局也能让你思考良多。而比起我们的电影结局大多是阳光美好而言，这部电影的结局可以说带着一些黑色气息了。好电影，值得一看！</p><hr><h3 id="2018-09-09-WEEK206-碟中谍6：全面瓦解"><a href="#2018-09-09-WEEK206-碟中谍6：全面瓦解" class="headerlink" title="2018-09-09 WEEK206 碟中谍6：全面瓦解"></a>2018-09-09 WEEK206 碟中谍6：全面瓦解</h3><p>碟中谍6：全面瓦解——————————————Mission: Impossible - Fallout<br><img src="https://img.piegg.cn/week206.jpg?imgslim" alt="碟中谍6：全面瓦解"></p><ul><li>导演：克里斯托弗·麦奎里</li><li>主演：汤姆·克鲁斯/亨利·卡维尔/文·瑞姆斯/西蒙·佩吉/丽贝卡·弗格森/西恩·哈里斯/安吉拉·贝塞特/凡妮莎·柯比/米歇尔·莫纳汉/韦斯·本特利/费雷德里克·施密特/亚历克·鲍德温/杨亮/克里斯托弗·琼勒/沃尔夫·布利策/拉斐尔·琼勒/安德鲁·卡扎纳夫·平/克里斯多夫·德·舒瓦西/拉裴尔·德普雷/让·巴普蒂斯特·菲永/马克斯·盖勒/奥利维尔·体班德/亚历山大·普尔/阿利克斯·贝纳泽什/乔伊·安沙/维利贝·托皮奇/格雷厄姆·福克斯/卡斯珀·菲利普森/菲恩·乔利/鲁斯·贝恩/奈杰尔·艾伦</li><li>片长：147分钟</li><li>影 片类型：动作/惊悚/冒险</li><li>豆 瓣评分：8.3/10(from164,538users)</li><li>IMDB评分：8.1/10(from118,713users)</li></ul><!--more--><p>Hi，各位好久不见！本周给大家推荐的是一部最近正在热映的电影《碟中谍6：全面瓦解》。动作片系列，我觉得如今只有《速度与激情》系列能与《碟中谍》系列比拼了。</p><p>阿汤哥依然是拼命三郎。本片全程无尿点。虽然剧情依然是跟核弹有关（哈哈）。不过不管是跳伞、飙车、开飞机甚至是「屋顶跑酷」都让人看得热血沸腾。22年了，阿汤哥依然是那个阿汤哥，不过当年看他电影的人已经长大了。熟悉的片头曲，琳琅满目的「黑科技」，剧情也是不停地反转反转。整部电影几乎一直处于神经紧绷的状态，让人看了大呼过瘾！</p><p>不知道还能再看到阿汤哥的碟中谍多少次，这部好电影，我想你一定要去看看。</p><hr><h3 id="2018-08-26-WEEK205-游戏之夜"><a href="#2018-08-26-WEEK205-游戏之夜" class="headerlink" title="2018-08-26 WEEK205 游戏之夜"></a>2018-08-26 WEEK205 游戏之夜</h3><p>游戏之夜——————————————Game Night<br><img src="https://img.piegg.cn/week205.jpg?imgslim" alt="游戏之夜"></p><!--more--><ul><li>导演：约翰·弗朗西斯·戴利/乔纳森·M·戈尔茨坦</li><li>主演：杰森·贝特曼/瑞秋·麦克亚当斯/凯尔·钱德勒/ 莎朗·豪根/比利·马格努森/拉蒙尼·莫里斯/凯莉·班伯里/杰西·普莱蒙/ 迈克尔·C·豪尔/丹尼·赫斯顿/切尔西·帕瑞蒂/卡米利·陈/泽瑞克·威廉姆斯/约书亚·米克尔/R·F·戴利</li><li>片长：100分钟</li><li>影 片类型：喜剧/悬疑/犯罪</li><li>豆 瓣评分：7.1/10(from22,632users)</li><li>IMDB评分：7.0/10(from109,979users)</li></ul><p>Hi，各位好久不见~本周给大家推荐的是来自英国的喜剧电影《游戏之夜》。听名字可能并不知道是什么意思，甚至有点「游戏人生」的感觉。但是看完之后却能把你笑得人仰马翻。这部结合了悬疑、犯罪的喜剧电影从分类上来说就让人忍俊不禁。其实同样类型的国内电影还有比如《唐人街探案》系列。不过我更加推荐这一部电影。</p><p>原因？原因在于这部电影的笑点和反转总是让你措手不及，反转会给你会心一击，笑点会让你笑掉下巴。我觉得一部喜剧电影的成功在于它能不用老梗把观众欢笑地送出电影院。而每部喜剧电影或多或少都会有些荤段子。有些电影处理地不好反而让人反感。而这部电影处理起来就让人看完很舒服。它不是什么很高内涵的电影，但是确是一部老少咸宜，适合一群人一起观看一起欢笑的好电影。值得一看~</p><hr><h3 id="2018-08-05-WEEK204-华盛顿邮报"><a href="#2018-08-05-WEEK204-华盛顿邮报" class="headerlink" title="2018-08-05 WEEK204 华盛顿邮报"></a>2018-08-05 WEEK204 华盛顿邮报</h3><p>华盛顿邮报——————————————The Post<br><img src="https://img.piegg.cn/week204.jpg?imgslim" alt="华盛顿邮报"></p><!--more--><ul><li>导演：史蒂文·斯皮尔伯格</li><li>主演：梅丽尔·斯特里普/汤姆·汉克斯/莎拉·保罗森/鲍勃·奥登科克/崔西·莱茨/布莱德利·惠特福德/布鲁斯·格林伍德/马修·瑞斯/爱丽森·布里/凯莉·库恩/杰西·普莱蒙/大卫·克罗斯/扎克·伍兹/帕特·希利/约翰·鲁/里克·霍姆斯/菲利普·卡斯诺夫/杰茜·缪勒/斯塔克·桑德斯/迈克尔·西里尔·克赖顿/威尔·丹顿/迪尔德丽·罗夫乔/迈克尔·斯图巴</li><li>片长：116分钟</li><li>影 片类型：剧情/惊悚/传记/历史</li><li>豆 瓣评分：8.2/10(from45,185users)</li><li>IMDB评分：7.2/10(from82,885users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的，是来自美国的电影《华盛顿邮报》。我记得此前给大家推荐过《聚焦》，那部电影讲的是波士顿环球报的故事。而本片从片名上你就能看出来，讲述的是华盛顿邮报的故事。同样都是讲报社的电影，两部电影讲出了各自不同的风格，不过同样都很精彩。</p><p>本片基于真实事件改编，剧情总体并不复杂，讲述的是华盛顿邮报揭露美国当时的越战黑幕，与尼克松政府「对着干」的故事。如果说《聚焦》的风格是尽力的克制，那么《华盛顿邮报》的风格就是与之相反的锋芒毕露。美国当时深陷越战泥潭，而政府却把战局的节节败退告知公众于步步胜利。在明知打不赢这场战争的情况下还依然偷偷往越南派兵。如果没有有良知的记着冒死将机密文件从五角大厦里偷出，华盛顿邮报将其公之于众，恐怕越战还将继续持续很久。</p><p>不得不提的是报社与政府之间的较量。他们捍卫着新闻自由，捍卫着美国宪法赋予新闻工作者的权利。「报纸不应为统治者服务，而是应该为被统治者服务」。这部电影虽然讲述的故事发生在40多年前，但是对于当世而言依然有很强烈的警示作用。「如果纽约时报和我们（华盛顿邮报）输了，那么自由新闻才是真的输了。」可以很自然的想到，如果当初华盛顿邮报在于政府的禁令面前败下阵来，那么1年后的水门事件也将同样的被压下来。而曝光水门事件促使尼克松下台的，正是华盛顿邮报。</p><p>看完电影真的非常感动，感动于那些新闻工作者为了国家，为了社会，为了人民在努力追求真相，拼死把真相曝光。可恨在于我们的当下，没有质量、没有深入调查、没有核实来源的假新闻、谣言却铺天盖地。不管是前段时间的「汤兰兰事件」，还是「慈溪被害女生事件」等等新闻，都是为了增加曝光量，却没有考虑到当事人、当事方的感受的新闻。一味追求标题党，撒手把事情甩锅给其他人，让当事人当事方得花十倍百倍的力气去辟谣。这种新闻是可恨的。而那些追求真理，曝光真相的新闻，比如曝光疫苗案、比如毒奶粉案等等的调查记者们，却因为触动了某些人的利益，触动了它们脆弱的神经，遭到掩盖、封杀、甚至人身威胁。演变成现在，我们很多的新闻、很多的细节不得不通过微信公众号、微博截图等等才能看到第一手的材料。因为一旦晚了，就是「该内容已被发布者删除」「该内容因违规无法查看」。这里面也是鱼龙混杂，有的人为了坚持正义，发出的文章无奈被封，而自己的账号也被封禁；有的人为了蹭热点不惜一切代价做出煽情的文章，而变相输出一些谣言。然而人们在这里面获取到信息后通常容易出现广泛传播。当局的做法通常是不论真假一并封杀。</p><p>《中华人民共和国宪法》第二章第三十五条规定：中华人民共和国公民有言论、出版、集会、结社、游行、示威的自由。</p><p>然而今天的真相是我们的「言论自由」是有代价的，通常只要触犯到某些人的利益就会遭到全面的封杀。我不知道它们看过《华盛顿邮报》之后会怎么想，恐怕会很害怕吧。「宜疏不宜堵」「水能载舟亦能覆舟」的道理，小学生都知道。不知道那些口口声声说着「为人民服务」的人，为什么不懂呢。好电影，值得一看。</p><hr><h3 id="2018-07-22-WEEK203-第十二人"><a href="#2018-07-22-WEEK203-第十二人" class="headerlink" title="2018-07-22 WEEK203 第十二人"></a>2018-07-22 WEEK203 第十二人</h3><p>第十二人——————————————Den 12. mann<br><img src="https://img.piegg.cn/week203.jpg?imgslim" alt="第十二人"></p><!--more--><ul><li>导演：哈罗德·兹瓦特</li><li>主演：乔纳森·莱斯·梅耶斯/托马斯·古勒斯塔德/玛丽·布洛克胡斯/维加·霍尔/马丁·基弗</li><li>片长：135分钟</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：7.8/10(from2,665users)</li><li>IMDB评分：7.5/10(from4,773users)</li></ul><p>Hi，各位好久不见！好久没给大家推荐战争类型的电影了。本次给大家推荐的是一部来自挪威的电影，讲述了一个12人的小队，最终只有第12个人生还的故事。这部电影最震撼的就是片头说的「这个故事里，最令人难以置信的是，确有其事。」。</p><p>跟敦刻尔克一样，这部电影讲述的不是消灭了多少德军，而是讲述了如何生还（或者「逃跑」）的故事。这个故事讲述的虽然是「一个人」，但是实际上讲的是一群人的故事。「我不是英雄，那些帮助了我的人才是英雄」。这部电影伟大之处在于给予一路上帮助主角的人足够多的镜头和描写。为了帮助主角逃生，很多人甚至会为此付出生命的代价。</p><p>这部取景很「冷」的电影，在冲破国境线的那一刻却格外地热血沸腾。好电影，值得一看。</p><hr><h3 id="2018-07-08-WEEK202-我不是药神"><a href="#2018-07-08-WEEK202-我不是药神" class="headerlink" title="2018-07-08 WEEK202 我不是药神"></a>2018-07-08 WEEK202 我不是药神</h3><p>我不是药神——————————————我不是药神<br><img src="https://img.piegg.cn/week202.jpg?imgslim" alt="我不是药神"></p><!--more--><ul><li>导演：文牧野</li><li>主演：徐峥/王传君/周一围/谭卓/章宇/杨新鸣/王佳佳/王砚辉/贾晨飞/龚蓓苾/宁浩/李乃文</li><li>片长：117分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：9.0/10(from350,132users)</li><li>IMDB评分：8.3/10(from372users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是刚上映的大热门《我不是药神》。其实光看名字和海报的时候，我以为只是徐峥的一部常规喜剧电影。然而自从点映以来就有不少朋友给我推荐。于是今天也去电影院看了，发现确实值得上豆瓣9.0的分数。「我们也拍出了韩国那样的电影」。这是我看完感慨最深的一点。</p><p>在审查严苛、国情如此的情况下我们还能拿出一部直击社会问题，反映社会现实和矛盾，并让不少人由衷落泪的电影，真的非常不容易。其实从前年的《湄公河行动》、去年的《战狼2》、今年的《红海行动》之后，我很害怕我们国家以后的「好」电影都只能是这类主旋律的动作片了。我们有《心迷宫》、《暴裂无声》等质量上乘的悬疑电影，也有逗男女老少开心一笑的《泰囧》、《夏洛特烦恼》等优质喜剧片等等。但是我们缺的是直击社会问题，挖掘人性的剧情电影。我们少了多少《辩护人》、少了多少未见的《熔炉》、少了多少难得的《Taxi Driver》。今天一部《我不是药神》让我看到了中国电影的未来还是有希望的。这部基于真实事件改编的电影，从影片一开始就会让你有种深深代入感——因为你也是千千万万中国人之一，这就会是发生在你身边的事。</p><p>不管是配乐、剪辑还是情节的把控，导演和主演们都让我们感到了深深的负责和认真。该给的镜头一个不少，该有的细节一个不缺，该哭的泪点一个不落。你知道这将是中国电影的一个里程碑式的电影么，这么棒的电影真的值得你去一看。</p><hr><h3 id="2018-06-27-WEEK201-寻梦环游记"><a href="#2018-06-27-WEEK201-寻梦环游记" class="headerlink" title="2018-06-27 WEEK201 寻梦环游记"></a>2018-06-27 WEEK201 寻梦环游记</h3><p>寻梦环游记——————————————Coco<br><img src="https://img.piegg.cn/week201.jpg?imgslim" alt="寻梦环游记"></p><!--more--><ul><li>导演：李·昂克里奇/阿德里安·莫利纳</li><li>主演：安东尼·冈萨雷斯/盖尔·加西亚·贝纳尔/本杰明·布拉特/阿兰纳·乌巴奇/芮妮·维克托/杰米·卡米尔/阿方索·阿雷奥/赫 伯特·西古恩萨/加布里埃尔·伊格莱西亚斯/隆巴多·博伊尔/安娜·奥菲丽亚·莫吉亚/娜塔丽·科尔多瓦/赛琳娜·露娜/爱德华·詹姆斯·奥莫斯/索菲亚·伊斯皮诺萨/卡拉·梅迪纳/黛娅娜·欧特里/路易斯·瓦尔德斯/布兰卡·阿拉切利/萨尔瓦多·雷耶斯/切奇·马林/奥克塔维·索利斯/约翰·拉岑贝格</li><li>片长：105分钟</li><li>影 片类型：喜剧/动画/音乐/奇幻</li><li>豆 瓣评分：9.0/10(from509,070users)</li><li>IMDB评分：8.5/10(from188,620users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是来自皮克斯的动画电影《寻梦环游记》。这部电影在当时上映的时候获得了很高的评价。不过我直到最近才看了它。不得不说确实是一部很赞的电影。关于这部电影有个有趣的段子，引进的时候，由于把审片的人都看哭了，所以本来是不能上映的亡灵题材的电影也过审了。暂且不考虑这个说法的真实性，从这个段子里你也能看出这部电影的硬实力确实很强。<br>这部是一部关于音乐，梦想和爱的电影。故事的构思很巧妙，背景设置在墨西哥也是别有一番风味。电影给我们营造了一个及其绚丽的亡灵世界。在这里大部分的生活是快乐的，不过也有令人揪心的问题——如果在人间没有人还记得你的话那么你将会在亡灵世界里消逝。这点真的非常赞，完美诠释了那句话：「人会死三次，第一次是在他停止呼吸的时候 ，从生物学上说他死了，他失去了思考的能力；第二次是在他下葬的时候，人们来参加他的葬礼，怀念他的过往和人生，然后在社会上他死了，活着的世界里不再会有他的位置；第三次是世界上最后一个记得他的人把他忘记的时候，那时候他才能算是真正的死了，永远的死了。」这个设定也带来了剧情的里的矛盾点和发展点。后续的情节铺开张弛有度，有情理之中也有意料之外。感动人心，好电影值得一看~</p><hr><h3 id="2018-06-13-WEEK200-燃烧"><a href="#2018-06-13-WEEK200-燃烧" class="headerlink" title="2018-06-13 WEEK200 燃烧"></a>2018-06-13 WEEK200 燃烧</h3><p>燃烧——————————————버닝<br><img src="https://img.piegg.cn/week200.png?imgslim" alt="燃烧"></p><!--more--><ul><li>导演：李沧东</li><li>主演：刘亚仁/史蒂文·元/全钟瑞/金秀京/崔承浩/玉子妍</li><li>片长：148分钟</li><li>影 片类型：剧情/悬疑</li><li>豆 瓣评分：8.0/10(from23,263users)</li><li>IMDB评分：7.9/10(from418users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是今年韩国一部大热的电影《燃烧》。这部电影并不是一部容易读懂的电影。改编自村上春树的《烧仓房》，不过导演也为这部电影注入了很多自己的思想。（建议可以看看《烧仓房》，是部短篇小说）这部电影的节奏比较缓慢，很多细节是慢慢地又完整地展现在你面前。而电影里最让人困惑，或者最烧脑，或者说加入了作者最深入的思考的部分，却又是那些可有可无的「线索」。它们有些到最后都没有得到导演给出的解释。开放式的结局，甚至开放式的剧情都是这部电影非常让人难以缓过神来的地方。而平淡地讲述故事的同时，也有着「最美之舞」的唯美画面。</p><p>聚焦着当下韩国年轻人的痛点，在讲述一场可疑的案件的同时，又让你不得不思考，自己活着是一个「little hunger」还是一个「greate hunger」。而为何有些人，莫名其妙地，年纪轻轻就成了「盖茨比」。不平等的阶层注定不平等的追求。好电影，值得一看。</p><hr><h3 id="2018-05-27-WEEK199-国际市场"><a href="#2018-05-27-WEEK199-国际市场" class="headerlink" title="2018-05-27 WEEK199 国际市场"></a>2018-05-27 WEEK199 国际市场</h3><p>国际市场——————————————국제시장<br><img src="https://img.piegg.cn/week199.jpg?imgslim" alt="国际市场"></p><!--more--><ul><li>导演：尹齐均</li><li>主演：黄晸玟/金允珍/吴达洙/张荣男/郑镇荣/罗美兰/金瑟祺/郑允浩/Stella Choe</li><li>片长：126分钟</li><li>影 片类型：剧情/家庭</li><li>豆 瓣评分：8.3/10(from34,907users)</li><li>IMDB评分：7.8/10(from2,500users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是来自韩国的《国际市场》。初看这部电影的名字，并不能看出什么名堂。不过这部电影类似于《阿甘正传》一样，描述了一部韩国的现代史。从6·25事件（可以认为是朝鲜战争全面爆发）开始，一直延续到如今。</p><p>这是目前韩国影史票房第二的电影。能获得如此巨大的成功，我想除了过硬的演员素质（黄晸玟、金允珍、吴达洙等实力派演员），编剧和导演对于情节穿插的到位把控，还有就是唤起了很多韩国人对于朝鲜战争过后，韩国从无到有，从落后朝鲜到超过朝鲜的那段历史的回忆。这部电影以主角德秀的成长作为主线，对父亲的承诺，对妹妹的愧疚，对姑姑的感恩等等。并不断加入一些暗藏的线索或者说「彩蛋」，在整体氛围是催人泪下的情况下，还能掺杂着不少喜剧的成分，非常具有这几年韩国高分电影的风格。</p><p>影片末尾的那句，「但是爸，我真的好累啊」让我不禁落泪。这部电影能直击你内心最容易被触动的角落，好电影，值得一看。</p><hr><h3 id="2018-05-23-WEEK198-暴烈无声"><a href="#2018-05-23-WEEK198-暴烈无声" class="headerlink" title="2018-05-23 WEEK198 暴烈无声"></a>2018-05-23 WEEK198 暴烈无声</h3><p>暴烈无声——————————————Wrath of Silence<br><img src="https://img.piegg.cn/week198.png?imgslim" alt="暴烈无声"></p><!--more--><ul><li>导演：忻钰坤</li><li>主演：宋洋/姜武/袁文康/谭卓/王梓尘/安琥</li><li>片长：120分钟</li><li>影 片类型：剧情/悬疑/犯罪</li><li>豆 瓣评分：8.3/10(from100,190users)</li><li>IMDB评分：7.2/10(from250users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是来自《心迷宫》导演的第二部佳作《暴烈无声》。好吧依然是一部从名字里看不出说啥的电影。有了《心迷宫》的成功铺垫，《暴烈无声》在经费上也算是大大地改善了。而且宋洋、姜武等实力派演员的出演也是给这部电影添色不少。</p><p>不过相比心迷宫的烧脑，这部电影打出的宣传语是：「烧脑，更烧心」。是的，这部电影虽然是一部悬疑片，但是不仅仅是一部悬疑片。导演其实是想借着这部电影，隐喻现实中的三类人。一类是在社会底层摸爬滚打，有苦说不出，有难没处诉的人；一类是生活过得还可以，努力工作努力养家糊口的中产阶级；一类是生活在社会顶层，物质生活富裕，但是依仗钱、权背地里做些违法乱纪之事的人。</p><p>我们常听「邪不压正，正义或许会迟到，但绝不会缺席」。不过看完这部电影，你会发现其实还是有不少的事，正义的缺席带给你我的，是多么无助，多么的无力。暴烈无声，拳头能换来的，是说不出的绝望。好电影，值得一看。</p><hr><h3 id="2018-05-14-WEEK197-至暗时刻"><a href="#2018-05-14-WEEK197-至暗时刻" class="headerlink" title="2018-05-14 WEEK197 至暗时刻"></a>2018-05-14 WEEK197 至暗时刻</h3><p>至暗时刻——————————————Darkest Hour<br><img src="https://img.piegg.cn/week197.png?imgslim" alt="至暗时刻"></p><!--more--><ul><li>导演：乔·赖特</li><li>主演：加里·奥德曼/克里斯汀·斯科特·托马斯/莉莉·詹姆斯/本·门德尔森/斯蒂芬·迪兰/萨缪尔·韦斯特/汉娜·斯蒂尔/罗纳德·皮卡普/乔丹·沃勒/理查德·拉姆斯登/安娜·伯内特/尼古拉斯·琼斯/查理·帕尔默·罗斯韦尔/布赖恩·佩蒂福/菲利普·马丁·布朗/安杰莉克·琼/希尔顿·麦克雷/詹姆斯·伊莱斯/杰瑞米·查亚德/马汀·麦格/迈克尔·海登/迈克尔·博特</li><li>片长：125分钟</li><li>影 片类型：剧情/传记/历史</li><li>豆 瓣评分：8.6/10(from145,583users)</li><li>IMDB评分：7.4/10(from95,095users)</li></ul><p>Hi，各位好久不见。这段时间确实比较忙，一直拖更我表示非常愧疚。本周给大家带来的是一部来自英国的电影《至暗时刻》。别看名字好像阴森恐怖，但是实际上它并不是一部恐怖电影。它是一部讲述英国著名首相丘吉尔的电影。</p><p>丘吉尔在面对重重困难，做出了一系列后世看来非常正确的决策。但是鲜有人知这些决策背后的故事。如果你知道敦刻尔克大撤退，那么你未必知道为了让敦刻尔克的30万英法联军撤回英国，为了多争取时间，牺牲了临近的一个英国旅（4000人）；你未必知道当时的情况下，征用民船已经是无奈之举，而且几乎是千钧一发之际才正好赶上撤军；你也许知道丘吉尔爱抽雪茄，但是你未必知道丘吉尔还嗜酒，个性分明……</p><p>这部电影里，加里·奥德曼把丘吉尔演绎得惟妙惟肖，十分令人印象深刻。也因此大家都在说他要因为出演丘吉尔这个角色拿到奥斯卡小金人了。好电影，值得一看！</p><hr><h3 id="2018-04-23-WEEK196-1987-黎明到来的那一天"><a href="#2018-04-23-WEEK196-1987-黎明到来的那一天" class="headerlink" title="2018-04-23 WEEK196 1987:黎明到来的那一天"></a>2018-04-23 WEEK196 1987:黎明到来的那一天</h3><p>1987:黎明到来的那一天——————————————일구팔칠<br><img src="https://img.piegg.cn/week196.jpg?imgslim" alt="1987:黎明到来的那一天"></p><!--more--><ul><li>导演：张俊焕</li><li>主演：金允锡/河正宇/柳海真/金泰梨/朴喜洵/李熙俊/..</li><li>片长：129分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：无</li><li>IMDB评分：8.0/10(from768users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的一部电影是国内豆瓣都「没有办法出现」的韩国电影《1987:黎明到来的那一天》。因为某些原因这部电影在国内被封杀，所以我也不好说得太多。去看看吧，好电影值得一看。</p><hr><h3 id="2018-04-08-WEEK195-头号玩家"><a href="#2018-04-08-WEEK195-头号玩家" class="headerlink" title="2018-04-08 WEEK195 头号玩家"></a>2018-04-08 WEEK195 头号玩家</h3><p>头号玩家——————————————Ready Player One<br><img src="https://img.piegg.cn/week195.jpg?imgslim" alt="头号玩家"></p><!--more--><ul><li>导演：史蒂文·斯皮尔伯格</li><li>主演：泰伊·谢里丹/ 奥利维亚·库克/本·门德尔森/马克·里朗斯/丽娜·维特/森崎温/赵家正/西蒙·佩吉/T·J·米勒/汉娜·乔恩-卡门/拉尔夫·尹爱森/苏珊·林奇/克莱尔·希金斯/劳伦斯·斯佩尔曼/佩蒂塔·维克斯/艾萨克·安德鲁斯</li><li>片长：140分钟</li><li>影 片类型：动作/科幻/冒险</li><li>豆 瓣评分：8.9/10(from311,268users)</li><li>IMDB评分：7.9/10(from68,363users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是最近影院的大热门《头号玩家》。这部电影的豆瓣评分有点「虚高」，不过不可否认确实是一部非常棒的科幻电影。这是斯皮尔伯格送给年轻人、玩家、动漫迷们一份最好的礼物。</p><p>和过往的科幻电影有所不同的是，故事发生在不远的未来，不过科技并没有发展到「变态」的程度。所以电影里的很多东西，包括VR都是在现有的基础上进行的升华。而营造出来的虚拟世界无疑是最吸引眼球的。有人说这部电影是一部彩蛋里插播电影的电影。确实这部电影里彩蛋特别多，但是不用担心，没有人会真的了解所有的彩蛋，所以哪怕你并不关心游戏、动漫、电影，你也能在电影院感受两个半小时的视听盛宴。</p><p>大概最感动的地方就是遇到你所认识、你所熟知的角色、游戏在电影中的一闪而过。你会想起当年在家里打红白机、小霸王的那个年代，你会想起当年守在电视机前只为等待一部好看的动画片的自己。这部电影想要告诉你的也是一样——那些在你脑海中挥之不去的，那些回忆，那些童年才是最真实的。现实世界终究是追求自由追求真实的，在虚拟世界里再如何成功也不过是过眼烟云，现实中的伙伴，生活才是你最应该珍惜的。好电影，值得去一看。</p><hr><h3 id="2018-03-14-WEEK194-启示录"><a href="#2018-03-14-WEEK194-启示录" class="headerlink" title="2018-03-14 WEEK194 启示录"></a>2018-03-14 WEEK194 启示录</h3><p>启示录——————————————Apocalypto<br><img src="https://img.piegg.cn/week194.jpg?imgslim" alt="启示录"></p><!--more--><ul><li>导演：梅尔·吉布森</li><li>主演：鲁迪·杨布拉德/达利娅·埃尔南德斯/乔纳森·布雷维尔/莫里斯·博德耶洛海德/劳尔·特鲁希洛/赫拉多·塔拉塞纳/卡洛斯·伊米里奥·巴厄兹/阿米尔卡尔·拉米瑞兹/伊斯雷尔·康特雷拉斯/伊斯雷尔·里<br>奥斯/玛利亚·迪亚兹/埃斯皮里迪恩·阿科斯塔·卡奇/梅拉·萨布罗/伊阿祖娅·拉里奥斯/艾贝尔·伍尔里奇</li><li>片长：139分钟</li><li>影 片类型：剧情/动作/冒险</li><li>豆 瓣评分：8.5/10(from46,606users)</li><li>IMDB评分：7.8/10(from257,854users)</li></ul><p>Hi，各位好久不见！这部电影是来自公众号的粉丝推荐的一部好电影。很开心来一起分享它！这部电影的背景是玛雅文明衰落时期的故事，但是实际上有些情节又与当时鼎盛的阿兹特克文明有所重合。不过抛去历史背景，这个发生在热带雨林里的故事，却是惊心动魄，让人叹为观止。</p><p>影片的节奏松紧有度。开篇的情节把主要的人物性格、特点都印刻在观众的脑海中。而到了中途，就开始了震撼的追逐。如果从片名里直译的《启示录》里你看不到大致的情节的话，台译版的《阿波卡猎逃》可能就会让你的肾上腺素有所提升。不过如果你读过或者知道圣经里的《启示录》的话，那么这个题目真是太恰当不过了。一场文明的毁灭与新的文明的重生。这是一部让你无法忘却的电影，「文明」世界带去的文明，无非也是野蛮的征服。好电影，值得一看。</p><hr><h3 id="2018-03-14-WEEK193-红海行动"><a href="#2018-03-14-WEEK193-红海行动" class="headerlink" title="2018-03-14 WEEK193 红海行动"></a>2018-03-14 WEEK193 红海行动</h3><p>红海行动——————————————红海行动<br><img src="https://img.piegg.cn/week193.jpg?imageslim" alt="红海行动"></p><!--more--><ul><li>导演：林超贤</li><li>主演：张译/黄景瑜/海清/杜江/蒋璐霞/尹昉/王强/郭郁滨/王雨甜/麦亨利/张涵予/王彦霖</li><li>片长：138分钟</li><li>影 片类型：剧情/动作/犯罪</li><li>豆 瓣评分：8.5/10(from321,371users)</li><li>IMDB评分：7.6/10(from1,254users)</li></ul><p>Hi，各位好久不见！前不久我刚去看了最近大热的《红海行动》。记得当初也给大家推荐过《湄公河行动》和《战狼2》。不得不说这两年来我们自己拍出来的战争、动作片的水准是越来越高了。本片的导演也是《湄公河行动》的导演林超贤。可以说自《湄公河行动》后的两年，真的是卷土重来。并且带来了质量更好，水平更高，更加真实而震撼的场面。</p><p>本片根据真实事件改编，还原度相当高。不仅影片出现的枪械、装备、坦克等都非常写实，而且一些镜头例如汽车炸弹、精密狙击、迫击炮狂轰滥炸等等都有很强的视觉冲击。而最震撼人心的，还有出现的很多「血腥」的场景——以往在国产电影里被剪掉无法搬上荧幕的战争的一些遗体、残骸。而整体剧情也非常紧凑，从头到尾都无尿点啊。而海陆空全面的镜头也让人大呼过瘾。同时，反战的主题也深入人心啊。好电影，值得一看！</p><hr><h3 id="2018-03-01-WEEK192-弱点"><a href="#2018-03-01-WEEK192-弱点" class="headerlink" title="2018-03-01 WEEK192 弱点"></a>2018-03-01 WEEK192 弱点</h3><p>弱点——————————————The Blind Side<br><img src="https://img.piegg.cn/week192.jpg?imageslim" alt="弱点"></p><!--more--><ul><li>导演：约翰·李·汉考克</li><li>主演：桑德拉·布洛克/蒂姆·麦格罗/昆东·亚伦/杰·海德/莉莉·柯林斯/雷·迈克金农/凯西·贝茨</li><li>片长：USA: 129 分钟</li><li>影 片类型：剧情/家庭/传记/运动</li><li>豆 瓣评分：8.4/10(from104,599users)</li><li>IMDB评分：7.7/10(from248,692users)</li></ul><p>Hi，各位好久不见，新年快乐呀！趁新年还未完全过去，赶紧来给大家推荐每周一部的好电影，拖更了好久哈哈。本周给大家推荐的是一部来自美国的温情电影《弱点》。不过我一直觉得翻译有问题，翻译成「盲点」应该更好点。</p><p>这部电影是根据原著《The Blind Side: Evolution of the Game》改编的电影，而原著的原型也是来自于真实的故事。所以说这部电影的真实感让人非常感动——片中的人大多都超出你的想象的好。与大部分的电影不同的是，它的矛盾点、冲突点特别少。虽然在一些细节的处理上有些过快，不过能够在两个小时里塞进一个橄榄球传奇球员从默默无闻青年时代到最后脱颖而出的选秀状元，可以说是真的很不容易了。我在看的时候一直在惯性思考着等着导演「耍把戏」，不过从头到尾都非常地温馨，非常的动人。</p><p>它是一部能够打动你的泪腺的电影，一部好电影，献给新年的第一部推荐。</p><hr><h3 id="2018-02-04-WEEK191-抓住那个家伙"><a href="#2018-02-04-WEEK191-抓住那个家伙" class="headerlink" title="2018-02-04 WEEK191 抓住那个家伙"></a>2018-02-04 WEEK191 抓住那个家伙</h3><p>抓住那个家伙——————————————몽타주<br><img src="https://img.piegg.cn/week191.jpg?imageslim" alt="抓住那个家伙"></p><!--more--><ul><li>导演：郑根燮</li><li>主演：金相庆/严正化/宋永彰/曹熙奉/刘承睦/李俊赫/朴哲民</li><li>片长：120分钟</li><li>影 片类型：剧情/惊悚/犯罪</li><li>豆 瓣评分：7.9/10(from25,085users)</li><li>IMDB评分：7.5/10(from3,342users)</li></ul><p>Hi，各位好久不见！本周依然给大家推荐一部有悬疑色彩的犯罪电影。这部来自韩国的电影从一开始就让我们感到一丝伤感。导演很擅长用暗色调渲染这种压抑而忧伤的气氛。所以从一开始我们就逐渐掉进这个陷阱中了。</p><p>整体上电影是双线并进，两条时间线互相交错，以至于到最后汇合的时候碰撞出的火花恐怕要让你拍案叫绝。两起案件，两个真相。和里面的警察一样，我们大多数人都会被眼前的“证据”蒙蔽，相信一些说不过去的“真相”。而很多事情是需要推敲，需要冷静的。</p><p>受害者也是加害者，这样的双重身份在电影里互相交织，让人性这个词又得以从电影剧本里脱颖而出。事实上，这部电影也是一部关于人性的思考，关于悔过的思考。好电影，值得一看~</p><hr><h3 id="2018-01-28-WEEK190-目击者追凶"><a href="#2018-01-28-WEEK190-目击者追凶" class="headerlink" title="2018-01-28 WEEK190 目击者追凶"></a>2018-01-28 WEEK190 目击者追凶</h3><p>目击者追凶——————————————目擊者<br><img src="https://img.piegg.cn/week190.jpg?imageslim" alt="目击者追凶"></p><!--more--><ul><li>导演：程伟豪</li><li>主演：庄凯勋/许玮甯/柯佳嬿/李铭顺/李淳/陈彦允/郑志伟/汤志伟/卜国耕</li><li>片长：117分钟</li><li>影 片类型：悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.1/10(from55,592users)</li><li>IMDB评分：7.0/10(from1,020users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是一部来自台湾的悬疑电影《目击者追凶》。我记得去年我曾推荐过一部大热的西班牙悬疑电影《看不见的客人》，精妙的剧本，峰会路转的剧情让很多人拍案叫绝。而这部来自宝岛台湾的电影也不逊色。</p><p>明线、暗线的堆叠，从一开始就埋下的伏笔。导演在一些细节的处理，比如一些闪回的镜头上做的是真的不错的。一次次小规模的反转铸就了最后令人吃惊而毛骨悚然的结局。这部电影里可以说基本没有“好人”。恐怕唯一的好人就是可怜的阿吉了。而所有其他出现在镜头里的主要角色，都有着外表和内在不同的反差。这也是这部电影可圈可点的地方。</p><p>而一部好的悬疑电影自然是到最后一刻才会完美收官。本片也不例外，片末的“鬼故事”，实在是画龙点睛之笔。好电影，值得一看。</p><hr><h3 id="2018-01-21-WEEK189-无问西东"><a href="#2018-01-21-WEEK189-无问西东" class="headerlink" title="2018-01-21 WEEK189 无问西东"></a>2018-01-21 WEEK189 无问西东</h3><p>无问西东——————————————Forever Young<br><img src="https://img.piegg.cn/week189.jpg?imageslim" alt="无问西东"></p><!--more--><ul><li>导演：李芳芳</li><li>主演：章子怡/黄晓明/张震/王力宏/陈楚生/韩童生/王盛德/米雪/保罗·菲利普·克拉克/祖锋/铁政/章泽天</li><li>片长：138分钟</li><li>影 片类型：剧情/爱情/战争</li><li>豆 瓣评分：7.5/10(from140,810users)</li><li>IMDB评分：6.5/10(from138users)</li></ul><p>Hi，各位好久不见！本次给大家推荐的是一部时隔5年重见天日的电影——《无问西东》。这部电影本来是打算献礼给清华大学建校100周年的，因为某些不可知的原因，一再推迟到如今才能上映。剧中的主演也都在这5年中结婚生子，变化之大也令人感慨。</p><p>既然是献礼给清华大学的电影，剧中自然少不了清华大学的身影。电影分成了4段故事来讲述。每段时间内发生的故事都有鲜明的时代特色。而4个故事之间的关联，也在影片“不经意”之间透露出来。而这样的安排也引起了一堆的不认可。然而我却觉得这样的安排非常棒。和云图的前世今生相比，这样的安排不仅更加贴近真实而且更加动人。</p><p>而每个故事里的主人公的演技我认为在当时，哪怕放到现在也都是非常不错的。就像豆瓣里有人说的，“最棒的王力宏和非常好的黄晓明”。两个小时，4个故事，横跨100年。这样庞大的题材，虽然导演确实在某些细节上处理的有些牵强，不过依旧不改这部电影交出的高分答卷。应对人生的选择，人声的苦难，你该如何继续？如果你没有看过《南渡北归》，你无法明白当年西南联大有多么不容易，当年的那些大家能够给本科生上课是有多么珍贵。电影最后给出的一个个那些年顶尖的学者，真是满满的感动和自豪。无问西东，砥砺前行。好电影，值得一看。</p><hr><h3 id="2018-01-08-WEEK188-三块广告牌"><a href="#2018-01-08-WEEK188-三块广告牌" class="headerlink" title="2018-01-08 WEEK188 三块广告牌"></a>2018-01-08 WEEK188 三块广告牌</h3><p>三块广告牌——————————————Three Billboards Outside Ebbing, Missouri<br><img src="https://img.piegg.cn/week188.jpg?imageslim" alt="三块广告牌"></p><!--more--><ul><li>导演：马丁·麦克唐纳</li><li>主演：弗兰西斯·麦克多蒙德/伍迪·哈里森/山姆·洛克威尔/艾比·考尼什/卢卡斯·赫奇斯/彼特·丁拉基/约翰·浩克斯/卡赖伯·兰德里·琼斯/凯瑟琳·牛顿/凯瑞·康顿/泽利科·伊万内克/萨玛拉·维文/克拉克·彼得斯/尼克·西塞</li><li>片长：115分钟</li><li>影 片类型：剧情/犯罪</li><li>豆 瓣评分：8.7/10(from20,455users)</li><li>IMDB评分：8.3/10(from31,903users)</li></ul><p>Hi，各位好久不见！忙完考试之后终于有时间来写本周的电影推荐了。本周给大家推荐的是去年底在美国上映（中国将在18年3月上映）的电影《三块广告牌》。</p><p>在这部充满美式幽默和美式愤怒的电影里，看到了久违的不靠煽情而让你动容的一部电影。不过我认为，真正让这部电影拥有如此好评的原因在于两点：</p><ol><li>导演（同时也是编剧）的讲故事的功力深厚</li><li>演员（尤其是科恩嫂）的演技强劲</li></ol><p>这部是一部讲述愤怒与善良，爱与恨的电影。愤怒不能解决问题，但是爱可以。影片塑造的多个人物都具有两面性——这也是本部电影最棒的地方。没有一个人是可以用好或者不好来形容的。每个人都有自己的阳光和阴暗面——而一开始我们不免进入了导演给我们设置的俗套。而随着剧情的发展你才会发现这一切都不是那么简单。“坏”警长其实不坏——相反还非常受人敬仰，“烂”警察其实不烂——相反他还自损三千地只为抓犯人等等。</p><p>而在被套路或者反套路的同时，你也逐渐了解到美国社会的诸多矛盾以及人的诸多美好品质。愤怒不能解决问题，但是善良与爱是可以的。好电影，值得一看。</p><hr><h3 id="2018-01-01-WEEK187-我能说"><a href="#2018-01-01-WEEK187-我能说" class="headerlink" title="2018-01-01 WEEK187 我能说"></a>2018-01-01 WEEK187 我能说</h3><p>我能说——————————————아이 캔 스피크<br><img src="https://img.piegg.cn/week187.jpg?imageslim" alt="我能说" title="我能说"></p><!--more--><ul><li>导演：金炫锡</li><li>主演：罗文姬/李帝勋/廉惠兰/朴哲民/李相喜/李知勋/郑妍周/金素真</li><li>片长：119分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.8/10(from19,693users)</li><li>IMDB评分：7.7/10(from195users)</li></ul><p>Hi，各位新年快乐~转眼之间一周一部好电影已经来到了第5个年头。前四个年头通过一周一部好电影我已经推送了186部各种主题，各种类型，各种风格的电影，希望新的一年里能够有更多的好电影能够分享给各位~</p><p>本周给大家推荐的电影是一部去年韩国的电影《我能说》。一部能用喜剧的形式来讲述“慰安妇”这个沉痛主题的电影，真的无不佩服编剧的功力以及演员的水平。两个主演的表演真的太动人了。</p><p>这部电影能分成两部分。前半部分以喜剧为主，讲述一个“鬼怪奶奶”的各种“鬼怪”行径。而前半部分用尽努力“掩盖”的欢乐，在后半段会被导演“无情”地打碎，同时打碎的还有观众的泪腺。而同时引出的是这部电影的主题啊——那些被人们忽略的受害者们，那些无法说出，不愿说出，不想说出自己曾经经历的受害者们。她们真的需要更多我们的关怀和帮助。国内今年的《二十二》也是同样的主题。不同的角度，不过都是同样的出发点和同样的愿望——日本政府的一句道歉。好电影，值得一看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2018-11-11-WEEK210-网络迷踪&quot;&gt;&lt;a href=&quot;#2018-11-11-WEEK210-网络迷踪&quot; class=&quot;headerlink&quot; title=&quot;2018-11-11 WEEK210 网络迷踪&quot;&gt;&lt;/a&gt;2018-11-11 WEEK210 网络迷踪&lt;/h3&gt;&lt;p&gt;网络迷踪——————————————Searching&lt;br&gt;&lt;img src=&quot;https://img.piegg.cn/week210.jpg?imgslim&quot; alt=&quot;网络迷踪&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;导演：阿尼什·查甘蒂&lt;/li&gt;&lt;li&gt;主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯尼/康纳·麦克雷斯/科林·伍德尔/约瑟夫·约翰·谢尔勒/阿什丽·艾德纳/托马斯·巴布萨卡/朱莉·内桑森/罗伊·阿布拉姆森/盖奇·&lt;br&gt;比尔托福/肖恩·奥布赖恩/瑞克·萨拉比亚/布拉德·阿布瑞尔/加布里埃尔D·安吉尔&lt;/li&gt;&lt;li&gt;片长：102分钟&lt;/li&gt;&lt;li&gt;影 片类型：剧情/悬疑/惊悚&lt;/li&gt;&lt;li&gt;豆 瓣评分：8.7/10(from85,981users)&lt;/li&gt;&lt;li&gt;IMDB评分：7.8/10(from38,178users)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
      <category term="周电" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/%E5%91%A8%E7%94%B5/"/>
    
    
      <category term="电影" scheme="https://molunerfinn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>PicGo的star数破1000的心路历程</title>
    <link href="https://molunerfinn.com/note-for-picgo/"/>
    <id>https://molunerfinn.com/note-for-picgo/</id>
    <published>2018-06-14T15:28:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>大概半年前（2017年11月28日）我在GitHub上开源了一个基于<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>的开源桌面应用<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>。其出发点是为了改善我在写博客的时候贴图困难的问题。在经过了半年的持续维护和一些宣传（<a href="https://sspai.com/post/42310" target="_blank" rel="noopener">《PicGo：基于 Electron 的图片上传工具》</a>、<a href="https://sspai.com/post/44495" target="_blank" rel="noopener">《图床上传工具PicGo v1.5更新：支持腾讯云COSv5版本、支持GitHub图床、支持上传前重命名文件等等》</a>等等）后，6月12日，它的star数也终于突破了1000的关卡。在这过程中我也学习了不少东西。在和大家交流的过程中，我才发现原来大家都有着这些需求，才发现我一开始的实现思路并非到位等等。谨以此文记录与PicGo有关的我的心路历程。</p><blockquote><p>赶巧前不久也有一个开发者chyingp的开源项目破了1000star，也有着类似的<a href="https://juejin.im/post/5b1717a86fb9a01e3e5ce540" target="_blank" rel="noopener">文章</a>，祝贺！</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fs892cewamj21ks0emq5n.jpg" alt=""></p><a id="more"></a><h2 id="项目诞生"><a href="#项目诞生" class="headerlink" title="项目诞生"></a>项目诞生</h2><p>我以前写博客的时候，由于一开始用的是七牛的图床，所以遇到要在markdown里贴图的时候就必须登录七牛，然后手动上传图片，再找到按钮来复制链接，然后复制到markdown里。要在markdown里显示一张图片我得经过上述4个步骤。</p><p>我自己的笔记本用的是mac，所以我就接触到了一款叫做<a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">iPic</a>的图床神器。在用它的时候我也知道了微博图床。iPic的功能和体验真的特别好。不过如果需要使用七牛等其他图床的时候，我就需要付费了。其实如果iPic支持windows的话，我可能就真的去付费了。（因为实验室的电脑是windows，所以我平时在实验室里得用windows来写东西）。仅为mac一个平台付费我有点不能接受。</p><p>于是我就在想能否我自己写一个工具来简化我的上传图片的流程呢，这个应用可以实现拖拽图片就上传，然后上传完自动复制链接到剪贴板里，我就只要粘贴到markdown里就好了。一开始想用swift写mac的应用，用C#写windows的应用。后来发现工作量不仅大，而且学习成本也很高。于是最后还是选择投入electron的怀抱。</p><p>一开始不选择electron主要是因为我的印象中electron的应用体积都挺大的（100MB以上），所以感觉体积可能有点不友好。不过后来我在用了<code>electron-vue</code>打包出来后发现体积是可以接受的范围（mac端大概50M，windows端大概38M），于是就决定用它来写了。用<code>electron-vue</code>的主要原因是我写vue比较多，想要学习成本低一些，这样开发只要学electron的部分就好了。</p><p>说干就干，在去年年底（11月下旬）我开始写这个应用。</p><h2 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h2><blockquote><p>文末会给出electron-vue开发的系列经验教程</p></blockquote><p>经过20多天的间断性地开发，我在12月12号发布了1.0.0版本。由于一开始是在mac上开发的，所以1.0.0版本也只支持了macOS。一开始支持的图床也不多，只支持了微博和七牛两个图床。</p><p>1.0.0版本的截图如下：</p><p><img src="https://user-images.githubusercontent.com/12621342/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" alt=""></p><p><img src="https://user-images.githubusercontent.com/12621342/34242857-d177930a-e658-11e7-9688-7405851dd5e5.gif" alt=""></p><p>基本实现了我预期的功能，类似iPic能够通过拖拽到顶部栏图标上传。并且为了今后支持windows平台（windows平台的任务栏图标不支持拖拽事件），我就做了一个主窗口，在主窗口里也有拖拽上传的区域。因为有了主窗口，我就顺便把图床的配置也放到了主窗口里。</p><p>应用做出来了，我也想让更多的人用到。于是我在北邮人论坛、cnode、v2ex还有掘金都发了文章。不过一开始看到的人寥寥无几，发了文章也没多少人看到和使用。后来我在少数派上发了同样的文章，意外地被推荐到了首页。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmvr6uah8rj21z20vk7wh" alt=""></p><p>这次的契机让PicGo意外地有了些用户和star数。在跟使用者交流的过程中我也开始逐步往PicGo里加功能和修复bug。在1月10日的时候，PicGo更新v1.3.1版本支持了windows系统。</p><p>因为开始有用户了，PicGo早期确实存在着不少功能的缺失，比如<code>快捷键上传</code>，其他常用图床的缺失等等。所以那时候是PicGo迭代最快的一段时间。通过大家在issue里的反馈，我也在不断打磨PicGo。可以看到截止6月14日，已经有61个被关闭的issue了。</p><p><img src="https://i.loli.net/2018/06/14/5b2223c52853f.png" alt=""></p><h2 id="项目改进"><a href="#项目改进" class="headerlink" title="项目改进"></a>项目改进</h2><p>用户体验这个东西真的并不是开发者在开发的时候能够立马就想到的。这点在开发PicGo上我体会很深。</p><p>比如增加<code>快捷键上传</code>这个功能，我一开始觉得自定义快捷键写起来比较麻烦，干脆我定一个大家基本用不到的快捷键吧。于是我默认给了一个【command/ctrl+shift+p】的快捷键。我自己用的时候没有什么问题。结果有人给我反馈说，快捷键跟某某某软件冲突了，能否给一个快捷键自定义的功能。这是我无法回避的一个问题。于是我就开始去学习如何加入自定义快捷键。并在不久之后实现了个这个<a href="https://github.com/Molunerfinn/PicGo/commit/37a784225e90c9d115367f056957dac88ebcf816" target="_blank" rel="noopener">功能</a>。</p><p>比如自定义链接格式的问题。我一开始给了大家4种复制链接的格式，分别是<code>markdown</code>、<code>HTML</code>、<code>URL</code>、<code>UBB</code>。本来以为这4种格式就足够大家平时使用了。后来有人提了一个<a href="https://github.com/Molunerfinn/PicGo/issues/25" target="_blank" rel="noopener">issue</a>，问PicGo能否自定义链接格式，因为他想基于HTML增加一些属性，比如大小居中等。我觉得这个使用场景确实是有的，于是我便在后来的某个<a href="https://github.com/Molunerfinn/PicGo/commit/4010a09fe48d8109456c3c1b37695f177336f2e4" target="_blank" rel="noopener">提交</a>里实现了这个功能。</p><p>当然并不是大家有这个需求我就一定要做。还有一些需求我觉得并不符合我对于PicGo的定位的，那么我就会给予回绝。比如<a href="https://github.com/Molunerfinn/PicGo/issues/53" target="_blank" rel="noopener">后期能否支持上传视频文件？</a>，由于PicGo的开发初衷只针对图片，所以在流程上（图片-&gt;base64）就不允许上传视频文件。于是我拒绝了这个需求。</p><p>还有一个对我以及PicGo这个项目影响深远的<a href="https://github.com/Molunerfinn/PicGo/issues/26" target="_blank" rel="noopener">issue</a>，ZetaoYang提出了一个想法：</p><p><img src="https://i.loli.net/2018/06/14/5b2228f31219a.png" alt=""></p><p>这个建议改变了我对PicGo开发的后续想法。我思考了好久，发现确实一步步增加默认的图床支持是不长远的。一个是重复性劳动太多（图床上传除了协议和加密方式不同之外，接收文件，转成base64和最后上传成功后存到本地的流程是一样的），一个是无止尽的图床支持其实也不应该。相比之下，把PicGo做成一个Core+Plugin模式的应用会更好。其中Core的部分可以单独只做图片接收和转码，并预留一些生命周期，供上传过程中不同的需求来调用。Core的部分可以单独发布成一个npm包。Plugin可以实现接入Core的生命周期，可以实现自己的上传逻辑，可以实现图片压缩、加水印等等其他功能。而PicGo只是在Core+Plugin的基础上套了一层electron的皮方便普通用户使用，而Core和Plugin可以独立拆出方便开发者使用和开发。这个也是PicGo的2.0版本将要做的事。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在开发PicGo的过程中我也深刻了解到，写一个DEMO不难，给这个DEMO注入你自己的思想和灵魂是难的。PicGo从一个一开始只是我想简化上传图片流程的玩具应用，发展到现在已经是不少用户的效率工具而言，其实一路走来也并不容易。现在大家对用户体验的要求越来越高，如果只沉醉在自己的DEMO里无法自拔，只会被更好的产品所淘汰。</p><p>开发PicGo也是一件很开心的事。大家给予我的赞赏和感谢，都是给我继续开发的动力。而我也发现越来越多的文章里，都提到了PicGo。如下：</p><ul><li><a href="https://juejin.im/post/5af0021e518825671547926e" target="_blank" rel="noopener">《老司机的神兵利器-效率工具》</a></li><li><a href="https://imwyc.com/picgo/" target="_blank" rel="noopener">《PicGo 强大的免费图床工具》</a></li><li><a href="https://lai.yuweining.cn/archives/2035/" target="_blank" rel="noopener">《PicGo：开源的图片管理工具》</a></li><li><a href="https://blog.csdn.net/weixin_39200308/article/details/80644336" target="_blank" rel="noopener">《图床神器PicGo》</a></li><li><a href="https://zhuanlan.zhihu.com/p/37873730" target="_blank" rel="noopener">《提升生活品质——个人效率工具与资讯网站推荐》</a></li><li><a href="https://sspai.com/post/44150" target="_blank" rel="noopener">《7 款 Windows 国产软件推荐》</a></li></ul><p>我想，得到你们的认可，把它写进你们的文章，这是对我最大的肯定，这个比star数更令我感到开心。</p><p>我在开发PicGo的过程中，也写了一个系列文章<a href="https://molunerfinn.com/tags/Electron-vue/">Electron-vue开发实战</a>。如果你也想学习electron或者electron-vue的开发的话，希望我的文章能够给你带来帮助。如果你之前没有听说过PicGo，那么不妨试试；如果你觉得它挺好用的，不妨点个star~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概半年前（2017年11月28日）我在GitHub上开源了一个基于&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;的开源桌面应用&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;。其出发点是为了改善我在写博客的时候贴图困难的问题。在经过了半年的持续维护和一些宣传（&lt;a href=&quot;https://sspai.com/post/42310&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《PicGo：基于 Electron 的图片上传工具》&lt;/a&gt;、&lt;a href=&quot;https://sspai.com/post/44495&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《图床上传工具PicGo v1.5更新：支持腾讯云COSv5版本、支持GitHub图床、支持上传前重命名文件等等》&lt;/a&gt;等等）后，6月12日，它的star数也终于突破了1000的关卡。在这过程中我也学习了不少东西。在和大家交流的过程中，我才发现原来大家都有着这些需求，才发现我一开始的实现思路并非到位等等。谨以此文记录与PicGo有关的我的心路历程。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;赶巧前不久也有一个开发者chyingp的开源项目破了1000star，也有着类似的&lt;a href=&quot;https://juejin.im/post/5b1717a86fb9a01e3e5ce540&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，祝贺！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/8700af19ly1fs892cewamj21ks0emq5n.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>小记VSCode插件amVim的改进以及插件开发</title>
    <link href="https://molunerfinn.com/vscode-extension-develop-1/"/>
    <id>https://molunerfinn.com/vscode-extension-develop-1/</id>
    <published>2018-06-13T14:09:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间在Mac上用VSCode的时候，发现<code>VSCodeVim</code>这个插件严重拖慢了我的开发效率。本来用<code>Vim</code>模式难道不应该是提高效率么？问题是在<code>Normal</code>模式下，光标的移动会有肉眼可见的长延时。比如我按着<code>j</code>，等我松开<code>j</code>后，光标还在移动，而且还移动了一会儿。预期的效果应该是按下移动，松开停止。为此我查了一下相关<a href="https://github.com/VSCodeVim/Vim/issues/2021" target="_blank" rel="noopener">issue</a>，发现跟我一样的情况的人还不少。（不过也有不少人没有这个问题，貌似跟显卡有关系？我的mac是集显的）。</p><p>卸载了<code>VSCodeVim</code>之后，光标移动的速度又恢复了正常，不过没有<code>Vim</code>模式的话非常别扭。所以我就开始看看VSCode还有没有其他<code>Vim</code>模式的插件。于是我又试了另外两个插件：<a href="https://github.com/74th/vscode-vim" target="_blank" rel="noopener">vimStyle</a>和<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank" rel="noopener">amVim</a>。最终我选择了后者。不仅是支持的Vim命令更多，还有就是开发者的维护一直在继续。而且很关键的一点，<code>amVim</code>的光标移动体验就是 <strong>如丝般顺滑</strong> ！</p><p>不过它有个让我很不习惯的地方：不支持<code>:</code>号调起VSCode的<code>Command Line</code>窗口，实现诸如<code>:w</code>保存，<code>:wq</code>退出等常见功能。这些功能在<code>VSCodeVim</code>里是支持的。于是我就在想有没有办法「移植」一下<code>VSCodeVim</code>的功能到<code>amVim</code>来，既能保持光标移动体验顺滑，又能用上<code>Command Line</code>的一些常用命令。所以开启了魔改模式，并在跟开发者的一系列交流后最终我提交的PR被<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/199" target="_blank" rel="noopener">merge</a>了。<br><img src="https://i.loli.net/2018/06/06/5b179b533f190.png" alt=""><br>本文记录一下我第一次对VSCode插件（修改）开发的过程。</p><a id="more"></a><h2 id="修改插件"><a href="#修改插件" class="headerlink" title="修改插件"></a>修改插件</h2><h3 id="开发前的准备"><a href="#开发前的准备" class="headerlink" title="开发前的准备"></a>开发前的准备</h3><p>VSCode的插件通常是用<code>TypeScript</code>来写的。如果你需要开发或者修改它，先要拥有<code>TypeScript</code>的开发环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn global add typescript</span><br></pre></td></tr></table></figure><p>通常<code>TypeScript</code>的项目都会用上<code>tslint</code>。所以你也最好全局安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tslint</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn global add tslint</span><br></pre></td></tr></table></figure><p>然后打开VSCode，安装一下<code>tslint</code>这个插件，它将通过我们上面安装在系统里的<code>tslint</code>给我们的项目提供代码检查。</p><p>修改别人的插件，可以先<code>fork</code>一份别人的代码。也为了之后方便提PR做准备。</p><p>然后就可以把插件<code>clone</code>到本地了。比如本文的<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank" rel="noopener">amVim-for-VSCode</a>。</p><h3 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h3><p>用VSCode打开这个项目，点击左侧的<code>debug</code>可以看到一个<code>launch extension</code>的配置：</p><p><img src="https://i.loli.net/2018/06/06/5b17a25905266.png" alt=""></p><p>运行它，你会得到另外一个窗口，这个就是可以调试插件功能的窗口了：</p><p><img src="https://i.loli.net/2018/06/06/5b17a2e5d0a1b.png" alt=""></p><h3 id="改进插件"><a href="#改进插件" class="headerlink" title="改进插件"></a>改进插件</h3><blockquote><p>我的改进源码在这里：<a href="https://github.com/Molunerfinn/amVim-for-VSCode" target="_blank" rel="noopener">https://github.com/Molunerfinn/amVim-for-VSCode</a> 作者合并之后做了一些修改，本文是以我的版本为主。</p></blockquote><p>为了实现<code>VSCodeVim</code>通过<code>:</code>调起VSCode的<code>inputBox</code>效果，我需要翻阅一下<code>VSCodeVim</code>的源代码。</p><p>大致效果如下：</p><p><img src="https://user-images.githubusercontent.com/12621342/40241750-61d5160c-5aee-11e8-9d21-6f96cbc4fa88.gif" alt=""></p><p>在查看了<code>amVim</code>和<code>VSCodeVim</code>在实现命令上的部分源码后，发现二者的实现上差距还是不小的。不过相比<code>VSCodeVim</code>代码的庞大（甚至还有neoVim的支持），<code>amVim</code>在实现上就比较精巧了。</p><p>在我的PR未被merge之前，<code>amVim</code>插件提供了一个功能，按<code>:</code>打开一个<code>GoToLine</code>的<code>inputBox</code>：</p><p><img src="https://i.loli.net/2018/06/06/5b17a73b1bf15.png" alt=""></p><p>不过只能用于输入数字并跳转到相应行数。好在查看release更新日志，追溯这个<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/192" target="_blank" rel="noopener">commit</a>，我们可以很容易找到它是如何实现的。</p><p><img src="https://i.loli.net/2018/06/06/5b17aa66c2030.png" alt=""></p><p>代码不多，就几行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Modes/Normal.ts</span></span><br><span class="line">&#123; <span class="attr">keys</span>: <span class="string">':'</span>, <span class="attr">actions</span>: [ActionCommand.goToLine] &#125;, <span class="comment">// 增加`:`打开GoToLine的inputBox的快捷键</span></span><br></pre></td></tr></table></figure><p>具体实现代码如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Actions/Command.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;commands&#125; <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> goToLine(): Thenable&lt;boolean | <span class="literal">undefined</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> commands.executeCommand(<span class="string">'workbench.action.gotoLine'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以是通过<code>vscode</code>的<code>commands</code>来打开的<code>gotoLine</code>的<code>inputBox</code>窗口。</p><p>再来看看<code>VSCodeVim</code>是如何打开<code>inputBox</code>的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd_line/commandLine.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CommandLine &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> PromptAndRun(initialText: <span class="built_in">string</span>, vimState: VimState): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vscode.window.activeTextEditor) &#123;</span><br><span class="line">      Logger.debug(<span class="string">'CommandLine: No active document'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cmd = <span class="keyword">await</span> vscode.window.showInputBox(<span class="keyword">this</span>.getInputBoxOptions(initialText)); <span class="comment">// 通过showInputBox打开</span></span><br><span class="line">    <span class="keyword">if</span> (cmd &amp;&amp; cmd[<span class="number">0</span>] === <span class="string">':'</span> &amp;&amp; configuration.cmdLineInitialColon) &#123;</span><br><span class="line">      cmd = cmd.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._history.add(cmd);</span><br><span class="line">    <span class="keyword">this</span>._history.save();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> CommandLine.Run(cmd!, vimState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> getInputBoxOptions(text: <span class="built_in">string</span>): vscode.InputBoxOptions &#123; <span class="comment">// inputBox的Options</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      prompt: <span class="string">'Vim command line'</span>,</span><br><span class="line">      value: configuration.cmdLineInitialColon ? <span class="string">':'</span> + text : text,</span><br><span class="line">      ignoreFocusOut: <span class="literal">false</span>,</span><br><span class="line">      valueSelection: [</span><br><span class="line">        configuration.cmdLineInitialColon ? text.length + <span class="number">1</span> : text.length,</span><br><span class="line">        configuration.cmdLineInitialColon ? text.length + <span class="number">1</span> : text.length,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到关键的部分是通过<code>vscode.window.showInputBox</code>打开的<code>inputBox</code>。所以我也根据这个关键的入口来一步步实现我想要的功能。</p><h4 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h4><p>参考<code>VSCodeVim</code>的实现，在<code>amVim</code>里可以大概分四个部分：</p><ol><li><code>src/Modes/Normal.ts</code>作为入口文件，当用户输入<code>:</code>键时触发后续功能。【已有】</li><li><code>src/Actions/CommandLine/CommandLine.ts</code>作为打开<code>inputBox</code>的入口函数，打开<code>inputBox</code>，然后负责把用户输入的内容传给下一级的<code>parser</code>，用于解析并执行相应命令。</li><li><code>src/Actions/CommandLine/Parser.ts</code>，负责接收上一级传进来的命令，然后找到命令对应的函数，并执行该函数。如果找不到相应则返回。</li><li><code>src/Actions/CommandLine/Commands/*</code>，存放各个命令的实现函数。</li></ol><p>其中<code>src/Actions/CommandLine/CommandLine.ts</code>的逻辑跟<code>VSCodeVim</code>的<code>src/cmd_line/commandLine.ts</code>非常类似。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ol><li>src/Actions/CommandLine/CommandLine.ts</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; parser &#125; <span class="keyword">from</span> <span class="string">'./Parser'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CommandLine &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Run(command: <span class="built_in">string</span> | <span class="literal">undefined</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!command || command.length === <span class="number">0</span>) &#123; <span class="comment">// 如果命令为空则直接返回</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> cmd = parser(command); <span class="comment">// 将命令传给parser并返回一个可执行的函数</span></span><br><span class="line">          <span class="keyword">if</span> (cmd) &#123;</span><br><span class="line">              <span class="keyword">await</span> cmd.execute(command); <span class="comment">// 调用该函数的execute方法</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> PromptAndRun(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vscode.window.activeTextEditor) &#123; <span class="comment">// 如果当前没有打开的激活的文本，则命令不执行，返回空。</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> cmd = <span class="keyword">await</span> vscode.window.showInputBox(CommandLine.getInputBoxOptions()); <span class="comment">// 打开inputBox</span></span><br><span class="line">          <span class="keyword">if</span> (cmd &amp;&amp; cmd[<span class="number">0</span>] === <span class="string">':'</span>) &#123;</span><br><span class="line">              cmd = cmd.slice(<span class="number">1</span>); <span class="comment">// 如果命令带有:则将它去掉并传给parser</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">await</span> CommandLine.Run(cmd);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> getInputBoxOptions(): vscode.InputBoxOptions &#123; <span class="comment">// 打开的inputBox框里的文本和一些其他配置</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          prompt: <span class="string">'Vim command line'</span>,</span><br><span class="line">          value: <span class="string">':'</span>,</span><br><span class="line">          ignoreFocusOut: <span class="literal">false</span>,</span><br><span class="line">          valueSelection: [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>src/Actions/CommandLine/Parser.ts</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Commands/Base'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteCommand <span class="keyword">from</span> <span class="string">'./Commands/Write'</span>;</span><br><span class="line"><span class="keyword">import</span> WallCommand <span class="keyword">from</span> <span class="string">'./Commands/WriteAll'</span>;</span><br><span class="line"><span class="keyword">import</span> QuitCommand <span class="keyword">from</span> <span class="string">'./Commands/Quit'</span>;</span><br><span class="line"><span class="keyword">import</span> QuitAllCommand <span class="keyword">from</span> <span class="string">'./Commands/QuitAll'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteQuitCommand <span class="keyword">from</span> <span class="string">'./Commands/WriteQuit'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteQuitAllCommand <span class="keyword">from</span> <span class="string">'./Commands/WriteQuitAll'</span>;</span><br><span class="line"><span class="keyword">import</span> VisualSplitCommand <span class="keyword">from</span> <span class="string">'./Commands/VisualSplit'</span>;</span><br><span class="line"><span class="keyword">import</span> NewFileCommand <span class="keyword">from</span> <span class="string">'./Commands/NewFile'</span>;</span><br><span class="line"><span class="keyword">import</span> VerticalNewFileCommand <span class="keyword">from</span> <span class="string">'./Commands/VerticalNewFile'</span>;</span><br><span class="line"><span class="keyword">import</span> GoToLineCommand <span class="keyword">from</span> <span class="string">'./Commands/GoToLine'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandParsers = &#123; <span class="comment">// 对于命令的解析，用哈希表做映射</span></span><br><span class="line">    w: WriteCommand,</span><br><span class="line">    write: WriteCommand,</span><br><span class="line">    wa: WallCommand,</span><br><span class="line">    wall: WallCommand,</span><br><span class="line"></span><br><span class="line">    q: QuitCommand,</span><br><span class="line">    quit: QuitCommand,</span><br><span class="line">    qa: QuitAllCommand,</span><br><span class="line">    qall: QuitAllCommand,</span><br><span class="line"></span><br><span class="line">    wq: WriteQuitCommand,</span><br><span class="line">    x: WriteQuitCommand,</span><br><span class="line"></span><br><span class="line">    wqa: WriteQuitAllCommand,</span><br><span class="line">    wqall: WriteQuitAllCommand,</span><br><span class="line">    xa: WriteQuitAllCommand,</span><br><span class="line">    xall: WriteQuitAllCommand,</span><br><span class="line"></span><br><span class="line">    vs: VisualSplitCommand,</span><br><span class="line">    vsp: VisualSplitCommand,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>: NewFileCommand,</span><br><span class="line">    vne: VerticalNewFileCommand,</span><br><span class="line">    vnew: VerticalNewFileCommand</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parser</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">CommandBase</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (commandParsers[input]) &#123;</span><br><span class="line">        <span class="keyword">return</span> commandParsers[input]; <span class="comment">// 接收inputBox里传来的命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(<span class="built_in">Number</span>(input))) &#123;</span><br><span class="line">        <span class="keyword">return</span> GoToLineCommand;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>命令的实现</li></ol><p>由于命令很多，我就举三个例子。一个是<code>w</code>，一个是<code>q</code>，和一个<code>wq</code>。VSCode自己的一些功能比如关闭当前文件、保存文件等都是有自己的command的。在实现Vim模式的时候，实际上最后也是去调用VSCode自带的功能而已。</p><h5 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WriteCommand <span class="keyword">extends</span> CommandBase &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> execute(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123; <span class="comment">// 暴露execute方法用于调用</span></span><br><span class="line">    <span class="keyword">await</span> vscode.commands.executeCommand(<span class="string">'workbench.action.files.save'</span>); <span class="comment">// 调用vscode的命令保存文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> WriteCommand();</span><br></pre></td></tr></table></figure><h5 id="Quit"><a href="#Quit" class="headerlink" title="Quit"></a>Quit</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> QuitCommand <span class="keyword">extends</span> CommandBase &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> execute(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> vscode.commands.executeCommand(<span class="string">'workbench.action.closeActiveEditor'</span>); <span class="comment">// 调用vscode的命令关闭当前的文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> QuitCommand();</span><br></pre></td></tr></table></figure><h5 id="WriteQuit"><a href="#WriteQuit" class="headerlink" title="WriteQuit"></a>WriteQuit</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Base'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteCommand <span class="keyword">from</span> <span class="string">'./Write'</span>;</span><br><span class="line"><span class="keyword">import</span> QuitCommand <span class="keyword">from</span> <span class="string">'./Quit'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WriteQuitCommand <span class="keyword">extends</span> CommandBase &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> execute(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> WriteCommand.execute();</span><br><span class="line">    <span class="keyword">await</span> QuitCommand.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> WriteQuitCommand();</span><br></pre></td></tr></table></figure><p>这一步就很有意思了，因为我们之前实现了<code>Write</code>和<code>Quit</code>的功能，所以可以在这里调用它们。看到这里你可能会有问题，虽然我知道VSCode有这些功能，但是你是怎么知道这些功能是怎么写的呢？</p><p>如果只是我这篇文章的话，我在实现Vim模式的这些命令的时候，大部分是参考了<code>VSCodeVim</code>的一些写法。它主要的命令实现在<code>src/cmd_line/commands/*</code>里。但是只这样显然还是不够的。因此我给出几个比较有用的地方供大家开发插件的时候参考：</p><ol><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/extensions/overview" target="_blank" rel="noopener">Extending Visual Studio Code</a>，介绍扩展VSCode的原理和给出了一些例子。</li><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/extensionAPI/overview" target="_blank" rel="noopener">Extensibility Reference</a>，介绍VSCode扩展的api文档。</li><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">Key Bindings for Visual Studio Code</a>，介绍VSCode的快捷键和相应的<strong>命令id</strong>。</li><li>VSCode本身的快捷键编辑面板：<br><img src="https://i.loli.net/2018/06/13/5b20c5d23fda2.png" alt=""></li></ol><p>说实话VSCode的文档写得不是特别好。我要实现一个功能，查找文档查了半天。其实其中很大一部分操作，你可以在上面的第3点、第4点里通过快捷键的提供的<code>Command id</code>去实现：</p><p><img src="https://i.loli.net/2018/06/13/5b20c6a5bcccd.png" alt=""></p><p>比如你要实现一个剪切的功能，有了<code>Command id</code>，你就可以通过<code>vscode.commands.executeCommand(&#39;editor.action.clipboardCutAction&#39;)</code>来实现。因此我推荐，如果你要实现的功能有些可以用已有快捷键实现的，那么就能在这个列表里找到对应的<code>Command id</code>来手动实现了。</p><p>至于其他的一些非快捷键提供的功能，就还需要阅读第2点的api文档做出更深层次的修改了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在改进完这个插件之后，我向作者提交了PR。在和作者交流后做出了一些修改，并最终被作者接受并合并。为开源项目贡献代码的感觉是真的很不错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间在Mac上用VSCode的时候，发现&lt;code&gt;VSCodeVim&lt;/code&gt;这个插件严重拖慢了我的开发效率。本来用&lt;code&gt;Vim&lt;/code&gt;模式难道不应该是提高效率么？问题是在&lt;code&gt;Normal&lt;/code&gt;模式下，光标的移动会有肉眼可见的长延时。比如我按着&lt;code&gt;j&lt;/code&gt;，等我松开&lt;code&gt;j&lt;/code&gt;后，光标还在移动，而且还移动了一会儿。预期的效果应该是按下移动，松开停止。为此我查了一下相关&lt;a href=&quot;https://github.com/VSCodeVim/Vim/issues/2021&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;，发现跟我一样的情况的人还不少。（不过也有不少人没有这个问题，貌似跟显卡有关系？我的mac是集显的）。&lt;/p&gt;&lt;p&gt;卸载了&lt;code&gt;VSCodeVim&lt;/code&gt;之后，光标移动的速度又恢复了正常，不过没有&lt;code&gt;Vim&lt;/code&gt;模式的话非常别扭。所以我就开始看看VSCode还有没有其他&lt;code&gt;Vim&lt;/code&gt;模式的插件。于是我又试了另外两个插件：&lt;a href=&quot;https://github.com/74th/vscode-vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vimStyle&lt;/a&gt;和&lt;a href=&quot;https://github.com/aioutecism/amVim-for-VSCode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;amVim&lt;/a&gt;。最终我选择了后者。不仅是支持的Vim命令更多，还有就是开发者的维护一直在继续。而且很关键的一点，&lt;code&gt;amVim&lt;/code&gt;的光标移动体验就是 &lt;strong&gt;如丝般顺滑&lt;/strong&gt; ！&lt;/p&gt;&lt;p&gt;不过它有个让我很不习惯的地方：不支持&lt;code&gt;:&lt;/code&gt;号调起VSCode的&lt;code&gt;Command Line&lt;/code&gt;窗口，实现诸如&lt;code&gt;:w&lt;/code&gt;保存，&lt;code&gt;:wq&lt;/code&gt;退出等常见功能。这些功能在&lt;code&gt;VSCodeVim&lt;/code&gt;里是支持的。于是我就在想有没有办法「移植」一下&lt;code&gt;VSCodeVim&lt;/code&gt;的功能到&lt;code&gt;amVim&lt;/code&gt;来，既能保持光标移动体验顺滑，又能用上&lt;code&gt;Command Line&lt;/code&gt;的一些常用命令。所以开启了魔改模式，并在跟开发者的一系列交流后最终我提交的PR被&lt;a href=&quot;https://github.com/aioutecism/amVim-for-VSCode/pull/199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;merge&lt;/a&gt;了。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/06/06/5b179b533f190.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;本文记录一下我第一次对VSCode插件（修改）开发的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="TypeScript" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/TypeScript/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
      <category term="TypeScript" scheme="https://molunerfinn.com/tags/TypeScript/"/>
    
      <category term="VSCode" scheme="https://molunerfinn.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>基于Koa2开发微信二维码扫码支付相关流程</title>
    <link href="https://molunerfinn.com/koa2-wechatpay/"/>
    <id>https://molunerfinn.com/koa2-wechatpay/</id>
    <published>2018-05-15T13:50:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在开发一个功能，要求是通过微信二维码进行扫码支付。这个情景我们屡见不鲜了，各种电子商城、线下的自动贩卖机等等都会有这个功能。平时只是使用者，如今变为开发者，也是有不小的坑。所以特此写一篇博客记录一下。</p><blockquote><p><strong>注</strong>： 要开发微信二维码支付，你必须要有相应的商户号的权限，否则你是无法开发的。若无相应权限，本文不推荐阅读。</p></blockquote><a id="more"></a><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>打开微信支付的文档，我们可以看到两种支付模式：<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_4" target="_blank" rel="noopener">模式一</a>和<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5" target="_blank" rel="noopener">模式二</a>。这二者的流程图微信的文档里都给出了（不过说实话画得真的有点丑）。</p><p>文档里指出了二者的区别：</p><blockquote><p>模式一开发前，商户必须在公众平台后台设置支付回调URL。URL实现的功能：接收用户扫码后微信支付系统回调的productid和openid。</p></blockquote><blockquote><p>模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url，商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。注意：code_url有效期为2小时，过期后扫码不能再发起支付。</p></blockquote><p>模式一是我们平时在网购的时候比较常见的，会弹出一个专门的页面用于扫码支付，然后支付成功后这个页面会再次跳转回回调页面，通知你支付成功。第二种的话想对少一些，不过第二种开发起来相对简单点。<strong>本文主要介绍模式二的开发</strong>。</p><h2 id="搭建Koa2的简单开发环境"><a href="#搭建Koa2的简单开发环境" class="headerlink" title="搭建Koa2的简单开发环境"></a>搭建Koa2的简单开发环境</h2><p>快速搭建Koa2的开发环境我推荐可以使用<a href="https://github.com/17koa/koa-generator" target="_blank" rel="noopener">koa-generator</a>。脚手架能帮我们省去Koa项目一开始的一些基本中间件的书写步骤。（如果你想学习Koa最好自己搭建一个。如果你已经会Koa了就可以使用一些快速脚手架了。）</p><p>首先全局安装<code>koa-generator</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g koa-generator</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">yarn global add koa-generator</span><br></pre></td></tr></table></figure><p>然后找一个目录用来存放Koa项目，我们打算给这个项目取个名字叫做<code>koa-wechatpay</code>，然后就可以输入<code>koa2 koa-wechatpay</code>。然后脚手架会自动创建相应文件夹<code>koa-wechatpay</code>，并生成基本骨架。进入这个文件夹，安装相应的插件。输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><p>接着你可以输入<code>npm start</code> 或者 <code>yarn start</code>来运行项目（默认监听在3000端口）。</p><p>如果不出意外，你的项目跑起来了，然后我们用postman测试一下：</p><blockquote><p>这条路由是在<code>routes/index.js</code>里。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1frc14ddfn9j21iq0r2n0p.jpg" alt=""></p><p>如果你看到了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"koa2 json"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就说明没问题。（如果有问题，检查一下是不是端口被占用了等等。）</p><p>接下来在<code>routes</code>文件夹里我们新建一个<code>wechatpay.js</code>的文件用来书写我们的流程。</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>跟微信的服务器交流很关键的一环是签名必须正确，如果签名不正确，那么一切都白搭。</p><p>首先我们需要去公众号的后台获取我们所需要的如下相应的id或者key的信息。其中<code>notify_url</code>和<code>server_ip</code>是用于当我们支付成功后，微信会主动往这个url<code>post</code>支付成功的信息。</p><p>签名算法如下：<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3</a></p><p>为了签名正确，我们需要安装一下<code>md5</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install md5 --save</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">yarn add md5</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">'md5'</span>)</span><br><span class="line"><span class="keyword">const</span> appid = <span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">const</span> mch_id = <span class="string">'yyy'</span></span><br><span class="line"><span class="keyword">const</span> mch_api_key = <span class="string">'zzz'</span></span><br><span class="line"><span class="keyword">const</span> notify_url = <span class="string">'http://xxx/api/notify'</span> <span class="comment">// 服务端可访问的域名和接口</span></span><br><span class="line"><span class="keyword">const</span> server_ip = <span class="string">'xx.xx.xx.xx'</span> <span class="comment">// 服务端的ip地址</span></span><br><span class="line"><span class="keyword">const</span> trade_type = <span class="string">'NATIVE'</span> <span class="comment">// NATIVE对应的是二维码扫码支付</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="string">'XXX的充值支付'</span> <span class="comment">// 用于显示在支付界面的提示词</span></span><br></pre></td></tr></table></figure><p>然后开始写签名函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signString = <span class="function">(<span class="params">fee, ip, nonce</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tempString = <span class="string">`appid=<span class="subst">$&#123;appid&#125;</span>&amp;body=<span class="subst">$&#123;body&#125;</span>&amp;mch_id=<span class="subst">$&#123;mch_id&#125;</span>&amp;nonce_str=<span class="subst">$&#123;nonce&#125;</span>&amp;notify_url=<span class="subst">$&#123;notify_url&#125;</span>&amp;out_trade_no=<span class="subst">$&#123;nonce&#125;</span>&amp;spbill_create_ip=<span class="subst">$&#123;ip&#125;</span>&amp;total_fee=<span class="subst">$&#123;fee&#125;</span>&amp;trade_type=<span class="subst">$&#123;trade_type&#125;</span>&amp;key=<span class="subst">$&#123;mch_api_key&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> md5(tempString).toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>fee</code>是要充值的费用，以分为单位。比如要充值1块钱，<code>fee</code>就是100。ip是个比较随意的选项，只要符合规则的ip经过测试都是可以的，下文里我用的是<code>server_ip</code>。<code>nonce</code>就是微信要求的不重复的32位以内的字符串，通常可以使用订单号等唯一标识的字符串。</p><p>由于跟微信的服务器交流都是用xml来交流，所以现在我们要手动组装一下post请求的<code>xml</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xmlBody = <span class="function">(<span class="params">fee, nonce_str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> xml = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;xml&gt;</span></span><br><span class="line"><span class="string">    &lt;appid&gt;<span class="subst">$&#123;appid&#125;</span>&lt;/appid&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;<span class="subst">$&#123;body&#125;</span>&lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;mch_id&gt;<span class="subst">$&#123;mch_id&#125;</span>&lt;/mch_id&gt;</span></span><br><span class="line"><span class="string">    &lt;nonce_str&gt;<span class="subst">$&#123;nonce_str&#125;</span>&lt;/nonce_str&gt;</span></span><br><span class="line"><span class="string">    &lt;notify_url&gt;<span class="subst">$&#123;notify_url&#125;</span>&lt;/notify_url&gt;</span></span><br><span class="line"><span class="string">    &lt;out_trade_no&gt;<span class="subst">$&#123;nonce_str&#125;</span>&lt;/out_trade_no&gt;</span></span><br><span class="line"><span class="string">    &lt;total_fee&gt;<span class="subst">$&#123;fee&#125;</span>&lt;/total_fee&gt;</span></span><br><span class="line"><span class="string">    &lt;spbill_create_ip&gt;<span class="subst">$&#123;server_ip&#125;</span>&lt;/spbill_create_ip&gt;</span></span><br><span class="line"><span class="string">    &lt;trade_type&gt;NATIVE&lt;/trade_type&gt;</span></span><br><span class="line"><span class="string">    &lt;sign&gt;<span class="subst">$&#123;signString(fee, server_ip, nonce_str)&#125;</span>&lt;/sign&gt;</span></span><br><span class="line"><span class="string">    &lt;/xml&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    xml,</span><br><span class="line">    out_trade_no: nonce_str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你怕自己的签名的<code>xml</code>串有问题，可以提前在微信提供的<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=20_1" target="_blank" rel="noopener">签名校验工具</a>里先校验一遍，看看是否能通过。</p></blockquote><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>因为需要跟微信服务端发请求，所以我选择了<code>axios</code>这个在浏览器端和node端都能发起ajax请求的库。</p><p>安装过程不再赘述。继续在<code>wechatpay.js</code>写发请求的逻辑。</p><p>由于微信给我们返回的也将是一个xml格式的字符串。所以我们需要预先写好解析函数，将xml解析成js对象。为此你可以安装一个<a href="https://github.com/Leonidas-from-XIV/node-xml2js" target="_blank" rel="noopener">xml2js</a>。安装过程跟上面的类似，不再赘述。</p><p>微信会给我们返回一个诸如下面格式的<code>xml</code>字符串：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span><span class="tag">&lt;<span class="name">return_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">return_code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">return_msg</span>&gt;</span>&lt;![CDATA[OK]]&gt;<span class="tag">&lt;/<span class="name">return_msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appid</span>&gt;</span>&lt;![CDATA[wx742xxxxxxxxxxxxx]]&gt;<span class="tag">&lt;/<span class="name">appid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mch_id</span>&gt;</span>&lt;![CDATA[14899xxxxx]]&gt;<span class="tag">&lt;/<span class="name">mch_id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nonce_str</span>&gt;</span>&lt;![CDATA[R69QXXXXXXXX6O]]&gt;<span class="tag">&lt;/<span class="name">nonce_str</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sign</span>&gt;</span>&lt;![CDATA[79F0891XXXXXX189507A184XXXXXXXXX]]&gt;<span class="tag">&lt;/<span class="name">sign</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">result_code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prepay_id</span>&gt;</span>&lt;![CDATA[wx152316xxxxxxxxxxxxxxxxxxxxxxxxxxx]]&gt;<span class="tag">&lt;/<span class="name">prepay_id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trade_type</span>&gt;</span>&lt;![CDATA[NATIVE]]&gt;<span class="tag">&lt;/<span class="name">trade_type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code_url</span>&gt;</span>&lt;![CDATA[weixin://wxpay/xxxurl?pr=dQNakHH]]&gt;<span class="tag">&lt;/<span class="name">code_url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们的目标是转为如下的js对象，好让我们用js来操作数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  return_code: <span class="string">'SUCCESS'</span>, <span class="comment">// SUCCESS 或者 FAIL</span></span><br><span class="line">  return_msg: <span class="string">'OK'</span>,</span><br><span class="line">  appid: <span class="string">'wx742xxxxxxxxxxxxx'</span>,</span><br><span class="line">  mch_id: <span class="string">'14899xxxxx'</span>,</span><br><span class="line">  nonce_str: <span class="string">'R69QXXXXXXXX6O'</span>,</span><br><span class="line">  sign: <span class="string">'79F0891XXXXXX189507A184XXXXXXXXX'</span>,</span><br><span class="line">  result_code: <span class="string">'SUCCESS'</span>,</span><br><span class="line">  prepay_id: <span class="string">'wx152316xxxxxxxxxxxxxxxxxxxxxxxxxxx'</span>,</span><br><span class="line">  trade_type: <span class="string">'NATIVE'</span>,</span><br><span class="line">  code_url: <span class="string">'weixin://wxpay/xxxurl?pr=dQNakHH'</span> <span class="comment">// 用于生成支付二维码的链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们写一个函数，调用<code>xml2js</code>来解析xml：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将XML转为JS对象</span></span><br><span class="line"><span class="keyword">const</span> parseXML = <span class="function">(<span class="params">xml</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    xml2js.parseString(xml, &#123;<span class="attr">trim</span>: <span class="literal">true</span>, <span class="attr">explicitArray</span>: <span class="literal">false</span>&#125;, (err, json) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        rej(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res(json.xml)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码返回了一个<code>Promise</code>对象，因为<code>xml2js</code>的操作是在回调函数里返回的结果，所以为了配合Koa2的<code>async</code>、<code>await</code>，我们可以将其封装成一个<code>Promise</code>对象，将解析完的结果通过<code>resolve</code>返回回去。这样就能用<code>await</code>来取数据了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'https://api.mch.weixin.qq.com/pay/unifiedorder'</span> <span class="comment">// 微信服务端地址</span></span><br><span class="line"><span class="keyword">const</span> pay = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> form = ctx.request.body <span class="comment">// 通过前端传来的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> orderNo = <span class="string">'XXXXXXXXXXXXXXXX'</span> <span class="comment">// 不重复的订单号</span></span><br><span class="line">  <span class="keyword">const</span> fee = form.fee <span class="comment">// 通过前端传来的费用值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = xmlBody(fee, orderNo) <span class="comment">// fee是费用，orderNo是订单号（唯一）</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.post(url, &#123;</span><br><span class="line">    data: data.xml</span><br><span class="line">  &#125;).then(<span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> resJson = <span class="keyword">await</span> parseXML(res.data)</span><br><span class="line">    <span class="keyword">return</span> resJson <span class="comment">// 拿到返回的数据</span></span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (res.return_code === <span class="string">'SUCCESS'</span>) &#123; <span class="comment">// 如果返回的</span></span><br><span class="line">    <span class="keyword">return</span> ctx.body = &#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">      message: <span class="string">'请求成功'</span>,</span><br><span class="line">      code_url: res.code_url, <span class="comment">// code_url就是用于生成支付二维码的链接</span></span><br><span class="line">      order_no: orderNo <span class="comment">// 订单号</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    success: <span class="literal">false</span>,</span><br><span class="line">    message: <span class="string">'请求失败'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/api/pay'</span>, pay)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>然后我们要将这个router挂载到根目录的<code>app.js</code>里去。</p><p>找到之前默认的两个路由，一个<code>index</code>，一个<code>user</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>)</span><br><span class="line"><span class="keyword">const</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>)</span><br><span class="line"><span class="keyword">const</span> wechatpay = <span class="built_in">require</span>(<span class="string">'./routes/wechatpay'</span>) <span class="comment">// 加在这里</span></span><br></pre></td></tr></table></figure><p>然后到页面底下挂载这个路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line">app.use(users.routes(), users.allowedMethods())</span><br><span class="line">app.use(wechatpay.routes(), users.allowedMethods()) <span class="comment">// 加在这里</span></span><br></pre></td></tr></table></figure><p>于是你就可以通过发送<code>/api/pay</code>来请求二维码数据啦。（如果有跨域需要自己考虑解决跨域方案，可以跟Koa放在同域里，也可以开一层proxy来转发，也可以开CORS头等等）</p><p><strong>注意</strong>， 本例里是用前端来生成二维码，其实也可以通过后端生成二维码，然后再返回给前端。不过为了简易演示，本例采用前端通过获取<code>code_url</code>后，在前端生成二维码。</p><h2 id="展示支付二维码"><a href="#展示支付二维码" class="headerlink" title="展示支付二维码"></a>展示支付二维码</h2><p>前端我用的是<code>Vue</code>，当然你可以选择你喜欢的前端框架。这里关注点在于通过拿到刚才后端传过来的<code>code_url</code>来生成二维码。</p><p>在前端，我使用的是<a href="https://github.com/xkeshi/vue-qrcode" target="_blank" rel="noopener">@xkeshi/vue-qrcode</a>这个库来生成二维码。它调用特别简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueQrcode <span class="keyword">from</span> <span class="string">'@xkeshi/vue-qrcode'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    VueQrcode</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在前端里用<code>&lt;vue-qrcode&gt;</code>的组件来生成二维码了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vue-qrcode</span> <span class="attr">:value</span>=<span class="string">"codeUrl"</span> <span class="attr">:options</span>=<span class="string">"&#123; size: 200 &#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>放到Dialog里就是这样的效果：</p><blockquote><p>文本是我自己添加的</p></blockquote><p><img src="http://mofinn123-1251750343.costj.myqcloud.com/wechat-pay.png" alt=""></p><h2 id="付款成功自动刷新页面"><a href="#付款成功自动刷新页面" class="headerlink" title="付款成功自动刷新页面"></a>付款成功自动刷新页面</h2><p>有两种将支付成功写入数据库的办法。</p><p>一种是在打开了扫码对话框后，不停向微信服务端轮询支付结果，如果支付成功，那么就向后端发起请求，告诉后端支付成功，让后端写入数据库。</p><p>一种是后端一直开着接口，等微信主动给后端的<code>notify_url</code>发起post请求，告诉后端支付结果，让后端写入数据库。然后此时前端向后端轮询的时候应该是去数据库取轮询该订单的支付结果，如果支付成功就关闭Dialog。</p><p>第一种比较简单但是不安全：试想万一用户支付成功的同时关闭了页面，或者用户支付成功了，但是网络有问题导致前端没法往后端发支付成功的结果，那么后端就一直没办法写入支付成功的数据。</p><p>第二种虽然麻烦，但是保证了安全。所有的支付结果都必须等微信主动向后端通知，后端存完数据库后再返回给前端消息。这样哪怕用户支付成功的同时关闭了页面，下次再打开的时候，由于数据库已经写入了，所以拿到的也是支付成功的结果。</p><p>所以<code>付款成功自动刷新页面</code>这个部分我们分为两个部分来说：</p><h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><p>Vue的data部分<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  payStatus: <span class="literal">false</span>, <span class="comment">// 未支付成功</span></span><br><span class="line">  retryCount: <span class="number">0</span>, <span class="comment">// 轮询次数，从0-200</span></span><br><span class="line">  orderNo: <span class="string">'xxx'</span>, <span class="comment">// 从后端传来的order_no</span></span><br><span class="line">  codeUrl: <span class="string">'xxx'</span> <span class="comment">// 从后端传来的code_url</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在methods里写一个查询订单信息的方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">handleCheckBill () &#123;</span><br><span class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.payStatus &amp;&amp; <span class="keyword">this</span>.retryCount &lt; <span class="number">120</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.retryCount += <span class="number">1</span></span><br><span class="line">      axios.post(<span class="string">'/api/check-bill'</span>, &#123; <span class="comment">// 向后端请求订单支付信息</span></span><br><span class="line">        orderNo: <span class="keyword">this</span>.orderNo</span><br><span class="line">      &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.data.success) &#123;</span><br><span class="line">            <span class="keyword">this</span>.payStatus = <span class="literal">true</span></span><br><span class="line">            location.reload() <span class="comment">// 偷懒就用reload重新刷新页面</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleCheckBill()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      location.reload()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在打开二维码Dialog的时候，这个方法就启用了。然后就开始轮询。我订了一个时间，200s后如果还是没有付款信息也自动刷新页面。实际上你可以自己根据项目的需要来定义这个时间。</p><h3 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h3><p>前端到后端只有一个接口，但是后端有两个接口。一个是用来接收微信的推送，一个是用来接收前端的查询请求。</p><p>先来写最关键的微信的推送请求处理。由于我们接收微信的请求是在Koa的路由里，并且是以流的形式传输的。需要让Koa支持解析xml格式的body，所以需要安装一个<a href="https://github.com/stream-utils/raw-body" target="_blank" rel="noopener">rawbody</a>来获取xml格式的body。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理微信支付回传notify</span></span><br><span class="line"><span class="comment">// 如果收到消息要跟微信回传是否接收到</span></span><br><span class="line"><span class="keyword">const</span> handleNotify = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> xml = <span class="keyword">await</span> rawbody(ctx.req, &#123;</span><br><span class="line">    length: ctx.request.length,</span><br><span class="line">    limit: <span class="string">'1mb'</span>,</span><br><span class="line">    encoding: ctx.request.charset || <span class="string">'utf-8'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> parseXML(xml) <span class="comment">// 解析xml</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res.return_code === <span class="string">'SUCCESS'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.result_code === <span class="string">'SUCCESS'</span>) &#123; <span class="comment">// 如果都为SUCCESS代表支付成功</span></span><br><span class="line">      <span class="comment">// ... 这里是写入数据库的相关操作</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始回传微信</span></span><br><span class="line">      ctx.type = <span class="string">'application/xml'</span> <span class="comment">// 指定发送的请求类型是xml</span></span><br><span class="line">      <span class="comment">// 回传微信，告诉已经收到</span></span><br><span class="line">      <span class="keyword">return</span> ctx.body = <span class="string">`&lt;xml&gt;</span></span><br><span class="line"><span class="string">        &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;</span></span><br><span class="line"><span class="string">        &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br><span class="line"><span class="string">      &lt;/xml&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果支付失败，也回传微信</span></span><br><span class="line">  ctx.status = <span class="number">400</span></span><br><span class="line">  ctx.type = <span class="string">'application/xml'</span></span><br><span class="line">  ctx.body = <span class="string">`&lt;xml&gt;</span></span><br><span class="line"><span class="string">    &lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;</span></span><br><span class="line"><span class="string">    &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br><span class="line"><span class="string">  &lt;/xml&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/api/notify'</span>, handleNotify)</span><br></pre></td></tr></table></figure><p>这里的坑就是Koa处理微信回传的xml。如果不知道是以<code>raw-body</code>的形式回传的，会调试半天。。</p><p>接下来这个就是比较简单的给前端回传的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkBill = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> form = ctx.request.body</span><br><span class="line">  <span class="keyword">const</span> orderNo = form.orderNo</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> 数据库操作</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result) &#123; <span class="comment">// 如果订单支付成功</span></span><br><span class="line">    <span class="keyword">return</span> ctx.body = &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.status = <span class="number">400</span></span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    success: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/api/check-bill'</span>, checkBill)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，一整个基于Koa2的微信二维码支付流程就简单演示完了，由于不是公开的项目，所以没有实际的GitHub仓库。不过基本上关键的代码我都已经注释出来啦。我参考了不少人的实现，曾考虑过用一些比如<code>wechatpay</code>的npm库，不过最终还是自己解决了。这里面感谢很多前人的分享，也希望我这篇文章能给你一些帮助。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>微信支付文章</p><p><a href="https://www.itbaby.me/blog/59e21af45d21b31fcd4e02c6" target="_blank" rel="noopener">https://www.itbaby.me/blog/59e21af45d21b31fcd4e02c6</a></p><p><a href="https://juejin.im/post/5a8e84faf265da4e7e10c92f" target="_blank" rel="noopener">https://juejin.im/post/5a8e84faf265da4e7e10c92f</a></p><p>返回接口</p><p><a href="http://webcache.googleusercontent.com/search?q=cache:iFC0HZuFB1gJ:jeffdeng.me/wx/2017/03/13/wx-platform-conect.html+&amp;cd=4&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:iFC0HZuFB1gJ:jeffdeng.me/wx/2017/03/13/wx-platform-conect.html+&amp;cd=4&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us</a></p><p>XML流处理</p><p><a href="https://blog.csdn.net/yxz1025/article/details/52313221" target="_blank" rel="noopener">https://blog.csdn.net/yxz1025/article/details/52313221</a></p><p><a href="https://juejin.im/post/5a6c558ef265da3e4b77030f" target="_blank" rel="noopener">https://juejin.im/post/5a6c558ef265da3e4b77030f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在开发一个功能，要求是通过微信二维码进行扫码支付。这个情景我们屡见不鲜了，各种电子商城、线下的自动贩卖机等等都会有这个功能。平时只是使用者，如今变为开发者，也是有不小的坑。所以特此写一篇博客记录一下。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;： 要开发微信二维码支付，你必须要有相应的商户号的权限，否则你是无法开发的。若无相应权限，本文不推荐阅读。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/Nodejs/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
      <category term="Koa" scheme="https://molunerfinn.com/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>【NOTE】观察者模式VS订阅发布模式</title>
    <link href="https://molunerfinn.com/observer-vs-pubsub-pattern/"/>
    <id>https://molunerfinn.com/observer-vs-pubsub-pattern/</id>
    <published>2018-05-12T23:34:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看了一篇<a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">《不好意思，观察者模式跟发布订阅模式就是不一样》</a>的文章之后对于这两个模式产生了比较浓厚的兴趣。不过奈何我的水平有限，看完那篇文章还是不能理解。不过在和朋友讨论之后，我想我应该是弄懂了。所以特地记下一篇笔记，以便回头翻阅的时候能够想起来。如果理解有误，欢迎在下方评论指出，一起讨论！</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有人说这两个模式其实是一个模式。我想这句话的对错对半分吧。它们有类似的地方，不过也不能说完全一致。先来一张图，这张图解释了<code>观察者模式</code>和<code>发布订阅模式</code>在流程上的一些区别：</p><p><img src="https://img.piegg.cn/observer-pubsub.png?imageslim" alt=""></p><p>左边是观察者模式，右边是订阅发布模式。</p><p>简单阐述二者的模型：</p><p>观察者模式里，观察者（Observer）直接订阅（subscribe）主题（Subject），而当主题被激活的时候，会触发（fire）观察者里的事件。</p><p>订阅发布模式里，订阅者（Subscriber）通过监听（on）事件总线（Event Bus）里的事件，当事件总线里的事件被触发（emit）的时候，订阅者将会执行相应的操作。而这里需要注意的是，事件总线里的事件是通过发布者（Publisher）进行发布（publish）和 通知事件总线 <strong>触发</strong> 的。</p><blockquote><p>注：事件总线也有说法叫为调度中心。本质上是一样的。不过因为写Vue时候习惯用Event Bus来说了，所以本文的调度中心皆以事件总线称呼。</p></blockquote><p>所以事件总线本身不独自发布和触发事件，它会借由发布者来操作。这是跟观察者模式有着比较大的区别的地方。</p><p>当然只看这两张图和上面的解释，应该还是无法很好的理解。下面这张图能把流程讲得更清楚点。</p><p><img src="https://img.piegg.cn/observer-vs-pubsub-2.png?imageslim" alt=""></p><p>这个例子可以理解为这样：左边是微信里的<code>微商-顾客</code>之间的关系。右边是<code>商家-淘宝-顾客</code>之间的关系。</p><p>观察者模式：顾客关注了微商的商品，微商会记住顾客关注的商品，一旦上新就直接 <strong>私聊</strong> 通知所有关注这个商品的顾客。这里的顾客就相当于观察者，这里的微商就相当于主题。<br>订阅发布模式：顾客通过淘宝（APP或者网站）关注了商家的商品，商家一旦上新就通过淘宝（APP或者网站）向关注了它的顾客 <strong>群发</strong> 消息。这里的顾客就是订阅者，这里的淘宝就是事件总线，这里的商家就是发布者。</p><p>所以可以看出，观察者模式的模型跟发布订阅模型里，差距就差在有没有一个中央的事件总线。如果有这个事件总线，我们就可以认为是个发布订阅模型。如果没有，那么就可以认为是个观察者模型。因为其实它们都实现了一个关键的功能：发布事件-订阅事件并触发事件。</p><p>下面用代码简单解释一下。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>由于最近在学习TypeScript，所以下面的代码也会用TypeScript来书写。</p></blockquote><p>我们先写一个定义观察者和主题的文件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer-pattern.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Subjects &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> Observer &#123;</span><br><span class="line">  subject: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">subject: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subject = subject</span><br><span class="line">  &#125;</span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This <span class="subst">$&#123;this.subject&#125;</span> was fired!`</span>)</span><br><span class="line">    <span class="keyword">this</span>.subject = <span class="string">`Done`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题</span></span><br><span class="line"><span class="keyword">class</span> Subject &#123;</span><br><span class="line">  <span class="comment">// 根据主题的不同收集相应的订阅者</span></span><br><span class="line">  subjects: Subjects = &#123;&#125;</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  add (subject, observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.subjects[subject]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解除订阅</span></span><br><span class="line">  remove (subject, observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subjects[subject].splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  fire (subject): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.notify())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  Observer,</span><br><span class="line">  Subject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是在调用的时候，是这样调用的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> op <span class="keyword">from</span> <span class="string">'./observer-pattern'</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> op.Observer(<span class="string">'click'</span>)</span><br><span class="line"><span class="keyword">let</span> subjects = <span class="keyword">new</span> op.Subject()</span><br><span class="line">subjects.add(<span class="string">'click'</span>, observer)</span><br><span class="line">subjects.fire(<span class="string">'click'</span>) <span class="comment">// subjects 主动通知</span></span><br></pre></td></tr></table></figure><p>经过上述调用，subjects触发观察者订阅的click事件，<code>observer.subject</code>的值将会变为<code>Done</code>（原先为<code>click</code>）。</p><h2 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h2><p>接下来我们来实现一些订阅发布模式。订阅发布模式最关键的地方就在于中间的<code>Event Bus</code>部分。它接管着事件总线的订阅和发布。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pubsub.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Subjects &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Event Bus</span></span><br><span class="line"><span class="keyword">class</span> EventBus &#123;</span><br><span class="line">  subjects: Subjects = &#123;&#125;</span><br><span class="line">  on (subject, callback): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.subjects[subject]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  off (subject, callback = <span class="literal">null</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject] = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">        <span class="keyword">if</span> (item === callback) &#123;</span><br><span class="line">          <span class="keyword">this</span>.subjects[subject].splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  emit (subject, data = <span class="literal">null</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].forEach(<span class="function"><span class="params">item</span> =&gt;</span> item(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> EventBus()</span><br></pre></td></tr></table></figure><p>可以看出在这里的<code>EventBus</code>和观察者模式里的<code>Subject</code>几乎一致对吧。但是需要注意的是，最后一行里，我们<code>export default new EventBus()</code>，所以我们在项目里不同的地方<code>import</code>它，都会指向同一个<code>Event Bus</code>实例，这样的话就可以起到一个事件总线的作用了。它不在乎谁来监听，谁来发布。只要有人监听了，就把它放进监听队列中。只要有人发布了事件，就从相应的监听队列中触发回调。不过所有相关的事件都必须经过<code>Event Bus</code>这个实例，而不能越过它直接由发布者通知监听者。</p><blockquote><p>再次祭出这张图</p></blockquote><p><img src="https://img.piegg.cn/observer-vs-pubsub-2.png?imageslim" alt=""></p><p>所以在订阅发布模型里，发布者或者订阅者的身份已经被弱化。发布者可以在任何时候发布事件，而订阅者可能只是一个回调函数。而最关键的事件总线部分，则是发布订阅模型的核心。</p><p>如果你用过Vue的<code>Event Bus</code>，相信不会陌生。接下来我们来用用我们刚才写的简单的<code>Event Bus</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'./pubsub.ts'</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我收到了新的商品通知：'</span>, val) <span class="comment">// 收到消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bus.on(<span class="string">'newItem'</span>, people) <span class="comment">// 订阅newItem这个消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merchant = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123; <span class="comment">// 由商户向event bus发布新商品</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123;</span><br><span class="line">    item: val</span><br><span class="line">  &#125;</span><br><span class="line">  bus.emit(<span class="string">'newItem'</span>, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merchant(<span class="string">'Book'</span>) <span class="comment">// 发布</span></span><br></pre></td></tr></table></figure><p>所以你可以看到，这个事件总线是可以单独抽离出来的。如果要把我们这个文件丢到一个现有的项目里也是完全没问题的。</p><p>其实在写Vue组件通信的时候，你如果用到了<code>Event Bus</code>的话，也是一样的。在全局声明一个<code>new Vue()</code>做<code>Event Bus</code>总线，然后在不同的组件里只要引入了这个事件总线，就能订阅或者发布不同的消息。这个就是一个非常典型的订阅发布模型。</p><p>而如果只是Vue的父子组件通信，子组件用的是<code>this.$emit</code>来触发事件，父组件用的是<code>this.$on</code>这样的方式去订阅事件，那么你可以认为这个就是一个简单的观察者模型。因为它们之间的联系是紧密耦合的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管是观察者模式也好，订阅发布模式也好，关键在于实现了在某个特定时间触发某个特定事件，从而触发监听这个特定事件的组件进行相应操作的功能。这个设计模式在很多时候非常有用。平时只是用到了它，但是没有深入去看看如何实现，这次借由这个机会把二者的关系和区别记录下来，也算是给自己加深了印象。</p><p>本文的代码你可以在我的学习仓库<a href="https://github.com/Molunerfinn/FE-Learning/tree/master/design-pattern" target="_blank" rel="noopener">FE-Learning</a>找到。如有错误欢迎指出！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zcfy.cc/article/observer-vs-pub-sub-pattern-hacker-noon" target="_blank" rel="noopener">https://www.zcfy.cc/article/observer-vs-pub-sub-pattern-hacker-noon</a></p><p><a href="http://blog.zxbing0066.com/design-patterns/2016/09/12/observer-pattern.html" target="_blank" rel="noopener">http://blog.zxbing0066.com/design-patterns/2016/09/12/observer-pattern.html</a></p><p><a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">https://juejin.im/post/5af05d406fb9a07a9e4d2799</a></p><p><a href="https://www.cnblogs.com/weebly/p/5279952.html" target="_blank" rel="noopener">https://www.cnblogs.com/weebly/p/5279952.html</a></p><p><a href="https://www.jianshu.com/p/3098b1176357" target="_blank" rel="noopener">https://www.jianshu.com/p/3098b1176357</a></p><p><a href="https://www.zhihu.com/question/23486749/answer/314072549" target="_blank" rel="noopener">https://www.zhihu.com/question/23486749/answer/314072549</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看了一篇&lt;a href=&quot;https://juejin.im/post/5af05d406fb9a07a9e4d2799&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《不好意思，观察者模式跟发布订阅模式就是不一样》&lt;/a&gt;的文章之后对于这两个模式产生了比较浓厚的兴趣。不过奈何我的水平有限，看完那篇文章还是不能理解。不过在和朋友讨论之后，我想我应该是弄懂了。所以特地记下一篇笔记，以便回头翻阅的时候能够想起来。如果理解有误，欢迎在下方评论指出，一起讨论！&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://molunerfinn.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="note" scheme="https://molunerfinn.com/tags/note/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
      <category term="JS" scheme="https://molunerfinn.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>【NOTE】进程-线程-协程 关系与区别</title>
    <link href="https://molunerfinn.com/process-thread-coroutine/"/>
    <id>https://molunerfinn.com/process-thread-coroutine/</id>
    <published>2018-05-11T22:02:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>一个进程好比是一个程序，它是 <strong>资源分配的最小单位</strong> 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。</p><p>电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 <strong>「微进程」</strong> 。它是 <strong>程序执行过程中的最小单元</strong> 。</p><p>一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：</p><p>拖动进度条-&gt;画面更新-&gt;声音更新。你会明显感到画面和声音和进度条不同步。</p><p>但是加上了线程之后，线程能够共享进程的大部分资源，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程在线程中实现调度。你可以理解为它是 <strong>「微线程」</strong> 。它的调度不来自于CPU，而是完全来自于用户控制（可以理解为用代码控制流程）。协程的执行效率非常高，它的切换不是线程切换，没有线程切换的开销。而且只要线程越多，协程的性能优势就越明显。协程不需要多线程的锁机制，只需要判断状态即可。不过协程本身无法利用多核CPU，因为它基于线程，而线程又依赖于进程。</p><p>在JS里，常见的协程就是ES6的<code>yield Generator</code>或者ES7的<code>async await</code>。我们知道JS引擎是单线程的。所以在处理异步任务队列的时候，以往我们会陷入「回调金字塔」或者「回调地狱」。而有了协程之后我们可以在代码层面上来控制我们的程序。</p><p>比如我们有这么一个需求，等两个请求都返回之后，用它们的返回值共同做些事。（此处不用<code>Promise.all()</code>来实现，不是说不行，而是为了更好地说明主题）</p><p><strong>ES6 + co</strong> 的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> getData = <span class="keyword">yield</span> axios.get(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="keyword">const</span> postData = <span class="keyword">yield</span> axios.post(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(getData, postData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>ES7</strong> 的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> getData = <span class="keyword">await</span> axios.get(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="keyword">const</span> postData = <span class="keyword">await</span> axios.post(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(getData, postData)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上述用「同步」的方式写的代码实际上依然是异步执行的。不过因为了有协程，在单线程的JS里也能够让我们在代码层面上实现了任务调度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以说三者虽然是不同的东西，但是有着很密切的关系和类似的特性。它们的关系是从大到小，从上而下的。没有进程也就没有线程也就没有协程。总的来说，在多核处理器的情况下，多进程+多协程可以发挥最优的性能。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.jianshu.com/p/f11724034d50" target="_blank" rel="noopener">进程，线程，协程与并行，并发</a></li><li><a href="http://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank" rel="noopener">进程和线程、协程的区别</a></li><li><a href="https://blog.csdn.net/blateyang/article/details/78088851" target="_blank" rel="noopener">进程、线程和协程的比较</a></li><li><a href="http://jsonliangyoujun.iteye.com/blog/2358274" target="_blank" rel="noopener">线程、进程与处理器</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://molunerfinn.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="note" scheme="https://molunerfinn.com/tags/note/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>基于Electron-vue的图床上传工具PicGo v1.5更新说明</title>
    <link href="https://molunerfinn.com/picgo-v1.5-update/"/>
    <id>https://molunerfinn.com/picgo-v1.5-update/</id>
    <published>2018-05-08T21:25:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>经过一个多月的努（lan）力（duo）开发，基于electron的图床上传工具<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>终于迎来了一个minor版本的更新。如果你对此感兴趣，不妨看看都更新了哪些有趣而实用的功能吧。</p><a id="more"></a><h3 id="支持GitHub图床"><a href="#支持GitHub图床" class="headerlink" title="支持GitHub图床"></a>支持GitHub图床</h3><p>早先PicGo所支持的图床基本上都是属于国内的服务商提供的图床（如七牛、腾讯云COS等），这次更新加入了GitHub图床的支持。用GitHub做图床其实是不少写博客的朋友的做法。免费、原生支持HTTPS、GitHub仓库易于管理、和issue等功能无缝衔接都是它的优点。如果能接受GitHub在国内的访问速度不是特别快的缺点的话，用它来做你的图床是个不错的选择。来看看在PicGo里如何配置它：</p><p><strong>1. </strong>首先你得有一个GitHub账号。注册GitHub就不用我多言。</p><p><strong>2. </strong>新建一个仓库</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/create_new_repo.png" alt=""></p><p>记下你取的仓库名。</p><p><strong>3. </strong>生成一个token用于PicGo操作你的仓库：</p><p>访问：<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/generate_new_token.png" alt=""></p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20180508210435.png" alt=""></p><p><strong>注意：</strong>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/copy_token.png" alt=""></p><p><strong>4. </strong>配置PicGo</p><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在PicGo里我要设定的仓库名就是<code>Molunerfinn/test</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/setup_github.png" alt=""></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/success.png" alt=""></p><h3 id="支持腾讯云COS-v5版本"><a href="#支持腾讯云COS-v5版本" class="headerlink" title="支持腾讯云COS v5版本"></a>支持腾讯云COS v5版本</h3><blockquote><p>在支持腾讯云COS的路上，我可谓是费了一番心血。首先是官方提供的node-sdk对我来说基本属于瘫痪状态，只能上传具体文件而不能上传base64编码后的文件。而且居然还有v4和v5两个版本的COS，甚至两个版本的认证签名、上传url等等都<strong>完！全！不！同！</strong>。由于之前我只有v4版本的COS权限，只能开发和测试出v4版本的上传。而近来发现很多朋友用的都已经是v5版本的了，所以我提交了一个工单向腾讯云申请了v5版本的权限，没想到很快就给我派发权限了。于是就有了v5版本的面世。目前市面上能同时支持v4、v5版本COS的估计也只有PicGo了！</p></blockquote><p>如果你是v5用户，但是之前下载了PicGo却不能用的话，别担心，v1.5版本的配置跟之前的配置几乎一致，而且可以一键切换v4\v5版本。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/v5_setup.png" alt=""></p><p><strong>1. </strong>获取你的APPID、SecretId和SecretKey</p><p>访问：<a href="https://console.cloud.tencent.com/cam/capi" target="_blank" rel="noopener">https://console.cloud.tencent.com/cam/capi</a></p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/get_key_id_secret.png" alt=""></p><p><strong>2. </strong>获取bucket名以及存储区域代号</p><p>访问：<a href="https://console.cloud.tencent.com/cos5/bucket" target="_blank" rel="noopener">https://console.cloud.tencent.com/cos5/bucket</a></p><p>创建一个存储桶。然后找到你的存储桶名和存储区域代号：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/get_bucket_area.png" alt=""></p><p>v5版本的存储桶名称格式是<code>bucket-appId</code>，类似于<code>xxxx-12312313</code>。存储区域代码和v4版本的也有所区别，v5版本的如我的是<code>ap-beijing</code>，别复制错了。</p><p><strong>3. </strong>选择v5版本并点击确定</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/choose_v5.png" alt=""></p><p>然后记得点击<code>设为默认图床</code>，这样上传才会默认走的是腾讯云COS。</p><h3 id="支持编辑相册的图片信息"><a href="#支持编辑相册的图片信息" class="headerlink" title="支持编辑相册的图片信息"></a>支持编辑相册的图片信息</h3><p>有些时候可能上传的图片的url事后需要更改，比如修改http到https，比如加上一些操作后缀（例：七牛图床支持的<code>?imgslim</code>）等等。PicGo本次的更新也让你能够更方便地管理你的图片库。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo_edit_info.gif" alt=""></p><h3 id="支持上传图片前重命名文件名"><a href="#支持上传图片前重命名文件名" class="headerlink" title="支持上传图片前重命名文件名"></a>支持上传图片前重命名文件名</h3><p>PicGo总共有三种上传模式：</p><ol><li>menubar图标拖拽上传（仅支持macOS）</li><li>主窗口拖拽或者选择图片上传</li><li>剪贴板图片（最常见的是截图）上传（支持自定义快捷键）</li></ol><p>其中前两种都是可以明确获得文件名，而第三种无法获取文件名（因为剪贴板里有些图片比如截图根本就不存在文件名），所以PicGo此前采取的规则是使用时间戳来命名剪贴板里的图片。这也导致了无法自定义文件名的问题。本次更新你可以选择开启「上传前重命名」这个选项：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/rename_before_upload.png" alt=""></p><p>之后你在上传的时候就会弹出一个小窗口让你重命名文件。如果你不想重命名，点击确定、取消或者直接关闭这个窗口都是可以的。如果你想要重命名就在输入框里输入想要更改的名字，然后点击确定即可。另外这个特性也支持批量上传，如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo_rename.gif" alt=""></p><h3 id="支持查看当前上传的图床"><a href="#支持查看当前上传的图床" class="headerlink" title="支持查看当前上传的图床"></a>支持查看当前上传的图床</h3><p>在主窗口的上传区，你可以直观地看到当前默认上传的图床，再也不用到处找当前的默认图床是哪个啦。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/current_picbed.png" alt=""></p><h3 id="支持显示或隐藏相应的图床"><a href="#支持显示或隐藏相应的图床" class="headerlink" title="支持显示或隐藏相应的图床"></a>支持显示或隐藏相应的图床</h3><p>很多时候你并不会使用上PicGo给你提供的全部的图床。所以为了精简显示你可以只选择你想要的图床来显示，这样侧边栏也就不会出现滚动条了。不过需要注意的是，这个仅仅是显示/隐藏而并不是剔除相应的功能。假如你隐藏了七牛云，你依然是可以通过七牛云来上传图片的。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picbed-choose.gif" alt=""></p><h3 id="支持开机自启动"><a href="#支持开机自启动" class="headerlink" title="支持开机自启动"></a>支持开机自启动</h3><p>如果你觉得每次开机要主动开启PicGo是一件麻烦事，不妨试试让它开机自启吧~</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/autoStart.png" alt=""></p><h3 id="修复若干bugs"><a href="#修复若干bugs" class="headerlink" title="修复若干bugs"></a>修复若干bugs</h3><p>v1.5不光更新了上述功能，也修复了不少问题。其中一个尤为重要的是从v1.4.1开始的一个bug——macOS的menubar无法拖拽上传。该bug也在这个版本被修复。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PicGo第一个稳定版本是在少数派上发布的，详见<a href="https://sspai.com/post/42310" target="_blank" rel="noopener">PicGo：基于 Electron 的图片上传工具</a>。支持macOS和windows双平台，开源免费，界面美观，也得到了很多朋友的认可。本次更新也是充分聆听了大家的<a href="https://github.com/Molunerfinn/PicGo/issues/29" target="_blank" rel="noopener">意见</a>。如果你对它有什么意见或者建议，也欢迎在<a href="https://github.com/Molunerfinn/PicGo/issues" target="_blank" rel="noopener">issues</a>里指出。如果你喜欢它，不妨给它点个star或者请我喝杯咖啡（PicGo的GitHub<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">首页</a>有赞助的二维码）？</p><blockquote><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><blockquote><p>Windows用户请下载<code>.exe</code>文件，macOS用户请下载<code>.dmg</code>文件。</p></blockquote><p>Happy uploading！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过一个多月的努（lan）力（duo）开发，基于electron的图床上传工具&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;终于迎来了一个minor版本的更新。如果你对此感兴趣，不妨看看都更新了哪些有趣而实用的功能吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战4——通过CI发布以及更新的方式</title>
    <link href="https://molunerfinn.com/electron-vue-5/"/>
    <id>https://molunerfinn.com/electron-vue-5/</id>
    <published>2018-04-24T14:11:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。</p><a id="more"></a><h2 id="LOGO的准备"><a href="#LOGO的准备" class="headerlink" title="LOGO的准备"></a>LOGO的准备</h2><p>经过前面几篇文章的实战，我相信大家已经对于构建一个基本的electron应用没有太多的问题了。本文主要阐述一下如何让我们的应用通过CI系统来自动帮我们构建应用，然后发布给用户使用。以及之后如果有更新，要如何通知用户更新。</p><p>当然，在此之前，我们还需要做一件事：给你应用加上好看的LOGO。LOGO的设计和制作不在本文的设计范围内。为了我们的应用能够跨平台地使用，不同平台上应用的LOGO尺寸和格式也不尽相同。三个平台所需的图片格式如下：</p><ul><li>Linux - png</li><li>macOS - icns</li><li>Windows - ico</li></ul><p>准备一张1024*1024以下，256*256以上（长宽一致）的png图片，(推荐512 * 512）然后我们可以用一些工具来实现从png到其他两种格式。搜索png转ico或者png转icns的话有很多在线转换的网站，可以去上面在线转换。在mac上我推荐用的是<a href="http://www.img2icnsapp.com/" target="_blank" rel="noopener">image2icon</a>这个工具。</p><p>然后我们将所得的三个图片文件，放到electron-vue项目根目录的<code>build/icons/</code>目录下。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqnr7sfuvjj20h806cglq.jpg" alt=""></p><h2 id="不同平台的构建配置"><a href="#不同平台的构建配置" class="headerlink" title="不同平台的构建配置"></a>不同平台的构建配置</h2><p>本文我们主要采用electron-vue已经配置好的基于<a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a>的构建脚本来进行我们的应用构建。构建脚本会读取<code>package.json</code>里的<code>build</code>字段里的配置来进行构建。electron-vue默认的配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "productName": "ElectronVue",</span><br><span class="line">  "appId": "org.simulatedgreg.electron-vue",</span><br><span class="line">  "dmg": &#123;</span><br><span class="line">    "contents": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "directories": &#123;</span><br><span class="line">    "output": "build"</span><br><span class="line">  &#125;,</span><br><span class="line">  "files": [</span><br><span class="line">    "dist/electron",</span><br><span class="line">    "node_modules/",</span><br><span class="line">    <span class="string">"package.json"</span></span><br><span class="line">  ],</span><br><span class="line">  "mac": &#123;</span><br><span class="line">    "icon": "build/icons/icon.icns"</span><br><span class="line">  &#125;,</span><br><span class="line">  "win": &#123;</span><br><span class="line">    "icon": "build/icons/icon.ico"</span><br><span class="line">  &#125;,</span><br><span class="line">  "linux": &#123;</span><br><span class="line">    "icon": "build/icons"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单讲述一下build配置里的一些字段的含义。</p><p>首先<code>productName</code>是你的应用的名字。<code>appId</code>的作用是用于Windows平台区分应用的标识。（<strong>注意</strong>该配置必须配置，而且稍后会有使用该配置的地方。如果不配置不使用的话，构建出来的Windows平台的应用将无法发送eletron的桌面通知）<code>dmg</code>这个配置里描述了macOS平台里，打开<code>dmg</code>安装包后显示的界面里的信息。如下图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqnrlfwfcej20u00mct9y.jpg" alt=""></p><p>表示了有两个标识，一个是应用文件，坐标是<code>(130, 150)</code>， 一个是应用文件夹的快捷方式，坐标是<code>(410, 150)</code>。</p><p><code>directories</code>的<code>output</code>字段是你应用打包完生成的文件放置的目录。</p><p><code>files</code>指明了要打包的目录。</p><p>而<code>mac</code>，<code>win</code>，<code>linux</code>是针对三个平台的不同的配置了。可以看出默认的配置里对它们的配置都是指向了不同的icon图标（也就是上一节所说的LOGO）。</p><p>PicGo在实际开发中，针对一些情况对默认的<code>build</code>配置项做出了一些增改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "productName": "PicGo",</span><br><span class="line">  "appId": "com.molunerfinn.picgo",</span><br><span class="line">  "directories": &#123;</span><br><span class="line">    "output": "build"</span><br><span class="line">  &#125;,</span><br><span class="line">  "files": [</span><br><span class="line">    <span class="string">"dist/electron/**/*"</span></span><br><span class="line">  ],</span><br><span class="line">  "dmg": &#123;</span><br><span class="line">    "contents": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "mac": &#123;</span><br><span class="line">    "icon": "build/icons/icon.icns",</span><br><span class="line">    "extendInfo": &#123;</span><br><span class="line">      "LSUIElement": 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "win": &#123;</span><br><span class="line">    "icon": "build/icons/icon.ico",</span><br><span class="line">    "target": "nsis"</span><br><span class="line">  &#125;,</span><br><span class="line">  "nsis": &#123;</span><br><span class="line">    "oneClick": false,</span><br><span class="line">    "allowToChangeInstallationDirectory": true</span><br><span class="line">  &#125;,</span><br><span class="line">  "linux": &#123;</span><br><span class="line">    "icon": "build/icons"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>由于PicGo在macOS上主要是一个顶部栏应用，所以在底部docker栏我并不想拥有一个占位的图标，所以在<code>mac</code>字段里加入了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"extendInfo": &#123;</span><br><span class="line">  "LSUIElement": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属性。参考相关<a href="https://github.com/electron-userland/electron-builder/issues/1456" target="_blank" rel="noopener">issue</a>。</p><p>在Windows平台上，默认打包出来的安装包并没有办法选择安装的路径，只会默认装到C盘的用户目录。这个并不是我们想要的。我们想要的是让用户自己选择安装的路径。</p><p>所以需要修改<code>windows</code>的一些配置以及加上一个<code>nsis</code>的配置来实现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"win": &#123;</span><br><span class="line">  "icon": "build/icons/icon.ico",</span><br><span class="line">  "target": "nsis"</span><br><span class="line">&#125;,</span><br><span class="line">"nsis": &#123;</span><br><span class="line">  "oneClick": false,</span><br><span class="line">  "allowToChangeInstallationDirectory": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于目前我还没有打包过Linux平台的应用，所以Linux相关的配置暂时先不做修改。</p><h3 id="Windows平台打包的一个小坑"><a href="#Windows平台打包的一个小坑" class="headerlink" title="Windows平台打包的一个小坑"></a>Windows平台打包的一个小坑</h3><p>还记得前面说到的一个配置：<code>appId</code>么，这个配置需要我们在主进程<code>index.js</code>里也要使用。否则打包后的应用将失去Windows平台的应用通知功能。这个<code>appId</code>是可以任意取的，只要保证不和其他应用重复即可。对于PicGo而言，<code>appId</code>是<code>com.molunerfinn.picgo</code>。</p><p>打开你的<code>main/index.js</code>，在Windows平台的时候加上这个<code>appId</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">'../../package.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">  app.setAppUserModelId(pkg.build.appId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了通知的那个问题。</p><h2 id="通过CI系统自动构建与发布"><a href="#通过CI系统自动构建与发布" class="headerlink" title="通过CI系统自动构建与发布"></a>通过CI系统自动构建与发布</h2><h3 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h3><p>发布应用其实是一个比较繁琐的活，往往跟你的版本控制绑在一块，所以通常在项目开始的阶段就要有所布局。我说说我的做法吧，不一定很科学，不过简单易行。</p><ol><li>仓库主要两个分支，一个dev一个master。平时在dev上开发，只有在发布新版的时候merge到master上。</li><li>书写简单的更新版本的脚本，一键打tag+push到GitHub。</li><li>结合CI系统，自动构建master分支的代码，并将应用推送到GitHub仓库去。</li></ol><p>其中简单的更新版本的脚本我是在<code>package.json</code>里写了简单的<code>scripts</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "patch": "npm version patch &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 小版本</span><br><span class="line">  "minor": "npm version minor &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 次版本</span><br><span class="line">  "major": "npm version major &amp;&amp; git push origin master &amp;&amp; git push origin --tags"  // 大版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面用到了npm的一个命令，<code>npm version [options]</code>，具体可以参考version的<a href="https://docs.npmjs.com/cli/version" target="_blank" rel="noopener">文档</a>。简单来说，它能够自动帮你升级版本，修改<code>package.json</code>里的version，并打上相应的git tag，很方便。</p><p>举个例子，一个符合语义的版本号通常由如下三个部分组成：<code>major.minor.patch</code>，比如<code>1.5.3</code>。如果我运行了<code>npm run patch</code>，那么将会将小版本更新：<code>1.5.4</code>，同时修改<code>package.json</code>里的<code>version</code>字段为<code>1.5.4</code>并自动打上一个git tag <code>1.5.4</code>，并将这个修改和tag推送到远端。</p><p>不过需要注意的是，一开始我是通过electron-vue自带的<code>npm run build</code>这个脚本让CI去执行构建，但是发现无法自动上传到GitHub的release里。所以通过查阅相关资料后，发现最简单的就是把对应的npm scripts命名为<code>release</code>。于是我把原本的<code>npm run build</code>的脚本复制了一遍，起了一个新名<code>release</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...</span><br><span class="line">  "release": "node .electron-vue/build.js &amp;&amp; electron-builder",</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CI相关"><a href="#CI相关" class="headerlink" title="CI相关"></a>CI相关</h3><p>说到这里都还没说到CI系统。什么是CI？可以参考阮一峰老师给出的解释<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">《持续集成是什么？》</a>。我们如果每次发布应用都需要我们在本地构建，然后手动上传到GitHub（或者其他地方）去，然后让别人能下载的话，未免太累了。而且通常我们开发electron应用就是为了能够跨平台，但是要构建不同的平台的应用意味着我们要在不同的平台分别构建。这也是不能忍受的。</p><p>于是网上有一些第三方的CI系统，它们能够帮我们，在某些分支（比如master）发生了某些更新（比如更新了tag）的时候帮我们执行某些脚本（比如构建、测试）。这样就省却了我们在本地、多平台构建的烦心事，而且让一些都变得「自动化」了起来。</p><p>有了CI之后，我的electron应用的发布就变成这样的流程了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqq9mnpumwj20rb04bt9a.jpg" alt=""></p><p>这样，我们只需要Push代码足矣。</p><p>针对Linux或者macOS的构建，我们可以使用<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a>，针对Windows平台的构建，我们可以使用<a href="https://www.appveyor.com/" target="_blank" rel="noopener">AppVeyor</a>。一个好消息是，它们对于在GitHub上的开源项目都是可以免费构建的，并且和GitHub的仓库结合地特别好，配置也比较简单，可以说的非常良心了。</p><p>在使用它们之前，我们需要给予它们一定的权限让它们能够访问我们的GitHub仓库。所以需要：</p><ol><li>用你的GitHub账号注册它们，才能获取你的仓库列表。</li><li>在GitHub上生成<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">token</a>，赋予CI系统读写你的仓库的权限。生成token的具体操作可以查看之前我写的一篇针对hexo持久化构建的<a href="https://molunerfinn.com/hexo-travisci-https/">文章</a>。</li><li>针对不同的CI平台创建不同的配置文件，好让它们知道你要它们执行什么操作。不过electron-vue很友好地为我们准备了Travis-CI的配置文件模板<code>.travis.yml</code>和AppVeyor的配置文件模板<code>appveyor.yml</code>。所以我们基本上只需要在它们的基础上小修改即可。</li></ol><h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis-CI"></a>Travis-CI</h3><p>注册并登录Travis-CI后，找到你要构建的仓库，然后打开，点击设置进入如下页面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi438l5g9sj218a0wmn1u.jpg" alt=""></p><p>配置一下环境变量，名为<code>GH_TOKEN</code>，token的值就是上一步我们在GitHub生成的token。等会会有用。</p><p>PicGo经过修改后的<code>.travis.yml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Commented sections below can be used to run tests on the CI server</span></span><br><span class="line"><span class="comment"># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br><span class="line"><span class="attr">osx_image:</span> <span class="string">xcode8.3</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">c</span></span><br><span class="line"><span class="attr">matrix:</span></span><br><span class="line"><span class="attr">  include:</span></span><br><span class="line"><span class="attr">  - os:</span> <span class="string">osx</span></span><br><span class="line">  <span class="comment"># - os: linux</span></span><br><span class="line"><span class="attr">    env:</span> <span class="string">CC=clang</span> <span class="string">CXX=clang++</span> <span class="string">npm_config_clang=1</span></span><br><span class="line"><span class="attr">    compiler:</span> <span class="string">clang</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"$HOME/.electron"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"$HOME/.cache"</span></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"><span class="attr">  apt:</span></span><br><span class="line"><span class="attr">    packages:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">libgnome-keyring-dev</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">icnsutils</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">/tmp/git-lfs</span> <span class="string">&amp;&amp;</span> <span class="string">curl</span> <span class="bullet">-L</span> <span class="attr">https://github.com/github/git-lfs/releases/download/v1.2.1/git-lfs-$([</span></span><br><span class="line">  <span class="string">"$TRAVIS_OS_NAME"</span> <span class="string">==</span> <span class="string">"linux"</span> <span class="string">]</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">"linux"</span> <span class="string">||</span> <span class="string">echo</span> <span class="string">"darwin"</span><span class="string">)-amd64-1.2.1.tar.gz</span></span><br><span class="line">  <span class="string">| tar -xz -C /tmp/git-lfs --strip-components 1 &amp;&amp; /tmp/git-lfs/git-lfs pull</span></span><br><span class="line"><span class="string"></span><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">nvm</span> <span class="string">install</span> <span class="number">8.9</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">curl</span> <span class="bullet">-o-</span> <span class="bullet">-L</span> <span class="attr">https://yarnpkg.com/install.sh</span> <span class="string">| bash</span></span><br><span class="line"><span class="string">- source ~/.bashrc</span></span><br><span class="line"><span class="string">- npm install -g xvfb-maybe</span></span><br><span class="line"><span class="string">- yarn</span></span><br><span class="line"><span class="string"></span><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">release</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">yarn</span> <span class="string">run</span> <span class="attr">build:docs</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">docs/dist</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Molunerfinn"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"marksz@teamsz.xyz"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Travis build docs"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span>  <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@github.com/Molunerfinn/PicGo.git"</span> <span class="attr">master:gh-pages</span></span><br></pre></td></tr></table></figure><p>抛去很多前置依赖（比如C++编译库之类的）和构建环境（是什么系统，是什么语言），那些都是electron-vue给我们预置好的。我们需要注意的仅仅是几个部分：</p><ol><li>script</li><li>branches</li><li>after_script</li></ol><p><code>script</code>是当系统和环境和依赖都准备好之后，你要CI运行的命令。在这里我运行了两个命令，一个是<code>npm run release</code>，这个就是打包构建应用啦，并且执行了这个命令之后，<code>electron-builder</code>会自动将生成好的安装包推送到我们GitHub仓库的draft release里。另一个是构建PicGo<a href="https://molunerfinn.com/PicGo/">主页</a>的命令<code>yarn run build:docs</code>。</p><p><code>branches</code>声明了你要在哪些分支在GitHub接收到了代码更新之后就构建，这里我们自然选择的是master。</p><p><code>after_script</code>是当你执行完script里的脚本之后要做的事。可以为空。对于我而言主要在这个部分将上一步构建好的PicGo主页推送到GitHub的<code>gh-pages</code>分支。当然如果你的应用有使用说明、文档之类的网站，也可以在这里进行构建和推送。</p><p>注意到，在<code>after_script</code>命令的最后一行，有个<code>${GH_TOKEN}</code>，这个就是我们之前在Travis-CI配置里配置的环境变量<code>GH_TOKEN</code>。用环境变量的好处是不会暴露你的TOKEN，只有构建系统知道。</p><h3 id="AppVeyor"><a href="#AppVeyor" class="headerlink" title="AppVeyor"></a>AppVeyor</h3><p>有了之前的经验，AppVeyor就更简单了。注册登录后，我们在主页添加一个PROJECT，选中你要构建的仓库。然后找到SETTING设置：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqawmvu6sj21ji06e3z0.jpg" alt=""></p><p>然后在左侧的<code>Genral</code>一栏的内容区中，找到构建的分支为master，以及设置我们仅在<code>tag</code>更新的时候构建：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqazwrslxj21600emjse.jpg" alt=""></p><blockquote><p>当然这个都是根据项目实际来的配置，我只是说PicGo的项目是这样配置的。</p></blockquote><p>然后在左侧的<code>Environment</code>区，找到环境变量配置，我们依然写入<code>GH_TOKEN</code>:</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqb1ufhj7j21ow0gydhu.jpg" alt=""></p><p><strong>修改完配置都别忘了拉到底部去保存！</strong></p><p>这样就算配置完了网页端的。而现在我们来看看<code>appveyor.yml</code>这个配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Commented sections below can be used to run tests on the CI server</span></span><br><span class="line"><span class="comment"># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="string">.&#123;build&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span> <span class="string">Visual</span> <span class="string">Studio</span> <span class="number">2017</span></span><br><span class="line"><span class="attr">platform:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">x64</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%APPDATA%\npm-cache'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%USERPROFILE%\.electron'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%USERPROFILE%\AppData\Local\Yarn\cache'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">init:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">core.autocrlf</span> <span class="string">input</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="attr">  - ps:</span> <span class="string">Install-Product</span> <span class="string">node</span> <span class="number">8</span> <span class="string">x64</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">reset</span> <span class="bullet">--hard</span> <span class="string">HEAD</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node</span> <span class="bullet">--version</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_script:</span></span><br><span class="line">  <span class="comment">#- yarn test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span> <span class="string">off</span></span><br></pre></td></tr></table></figure><p>依然是只需要关注我们所关心的配置即可。一个是<code>branches</code>，一个是<code>build_script</code>。有了<code>Travis-CI</code>的<code>.travis.yml</code>的经验，我相信你也能很快理解它。</p><p>经过上述配置之后，你已经实现了一个简单的前端工程的自动化构建推送流程了。而今你只需要关注代码提交，应用的构建都将会由CI系统自动帮你完成。当然CI系统也不仅仅是拿来构建electron应用的，正如你所见的，你能想到的其他项目的构建、测试其实它都能帮你通过预定义好的脚本完成。</p><h3 id="发布Release"><a href="#发布Release" class="headerlink" title="发布Release"></a>发布Release</h3><p>当CI构建玩应用，会将其推送到你的GitHub的release页面成为一个<code>draf</code>（草稿），你可以编辑这个草稿，加上标题和更新说明，就可以点击<code>publish</code>发布你的新版本的应用啦。</p><h2 id="electron应用的更新"><a href="#electron应用的更新" class="headerlink" title="electron应用的更新"></a>electron应用的更新</h2><p>electron应用的自动更新其实社区有很好的解决方案<a href="https://github.com/electron-userland/electron-builder/tree/master/packages/electron-updater" target="_blank" rel="noopener">electron-updater</a>。而electron-vue也在主进程的<code>main/index.js</code>里预先帮我们写好了一段注释的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; autoUpdater &#125; from 'electron-updater'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoUpdater.on('update-downloaded', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   autoUpdater.quitAndInstall()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.on('ready', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   if (process.env.NODE_ENV === 'production') &#123;</span></span><br><span class="line"><span class="comment">//     autoUpdater.checkForUpdates()</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>只要引入autoUpdater就能自动帮我们检查更新和自动下载安装更新。不过，凡事都有不过。这个方式虽然很简单，但是它需要的条件比较严格，需要你拥有证书用于应用签名。而macOS平台下的证书需要你申请开发者，一年99$的费用让我望而却步。</p><p>于是我只能退而求其次，能不能通过查询GitHub的release版本号，来比对当前版本，是否需要更新，并提醒用户呢？经过尝试，发现可行。我的实现方法如下:</p><p>我首先写了一个<code>updateChecker</code>的助手：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dialog, shell &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../../datastore'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">'../../../package.json'</span></span><br><span class="line"><span class="keyword">const</span> version = pkg.version</span><br><span class="line"><span class="keyword">const</span> release = <span class="string">'https://api.github.com/repos/Molunerfinn/PicGo/releases/latest'</span></span><br><span class="line"><span class="keyword">const</span> downloadUrl = <span class="string">'https://github.com/Molunerfinn/PicGo/releases/latest'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkVersion = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> showTip = db.read().get(<span class="string">'picBed.showUpdateTip'</span>).value()</span><br><span class="line">  <span class="keyword">if</span> (showTip === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    db.read().set(<span class="string">'picBed.showUpdateTip'</span>, <span class="literal">true</span>).write()</span><br><span class="line">    showTip = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 自动更新的弹窗如果用户没有设置不再提醒，就可以去查询是否需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (showTip) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(release)</span><br><span class="line">    <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> latest = res.data.name <span class="comment">// 获取版本号</span></span><br><span class="line">      <span class="keyword">const</span> result = compareVersion2Update(version, latest) <span class="comment">// 比对版本号，如果本地版本低于远端则更新</span></span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        dialog.showMessageBox(&#123;</span><br><span class="line">          type: <span class="string">'info'</span>,</span><br><span class="line">          title: <span class="string">'发现新版本'</span>,</span><br><span class="line">          buttons: [<span class="string">'Yes'</span>, <span class="string">'No'</span>],</span><br><span class="line">          message: <span class="string">'发现新版本，更新了很多功能，是否去下载最新的版本？'</span>,</span><br><span class="line">          checkboxLabel: <span class="string">'以后不再提醒'</span>,</span><br><span class="line">          checkboxChecked: <span class="literal">false</span></span><br><span class="line">        &#125;, (res, checkboxChecked) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (res === <span class="number">0</span>) &#123; <span class="comment">// if selected yes</span></span><br><span class="line">            shell.openExternal(downloadUrl)</span><br><span class="line">          &#125;</span><br><span class="line">          db.read().set(<span class="string">'picBed.showUpdateTip'</span>, !checkboxChecked).write()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if true -&gt; update else return false</span></span><br><span class="line"><span class="keyword">const</span> compareVersion2Update = <span class="function">(<span class="params">current, latest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentVersion = current.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item))</span><br><span class="line">  <span class="keyword">const</span> latestVersion = latest.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item))</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentVersion[i] &lt; latestVersion[i]) &#123;</span><br><span class="line">      flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> checkVersion</span><br></pre></td></tr></table></figure><p>然后在<code>main/index.js</code>里，我在app准备启动的时候，调用这个更新助手：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> uploader <span class="keyword">from</span> <span class="string">'./utils/uploader.js'</span></span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  updateChecker()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就能在启动应用的时候弹出更新提示：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqbm19ptvj20nc08swf7" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要地讲述了electron应用用上CI系统帮我们自动化构建和推送，以及在没有申请开发者，没有证书用于应用的代码签名的情况下如何告知用户进行应用更新。要做一个健壮的应用就应该考虑到应用的版本发布、版本更新和对用户的更新通知。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;系列文章&lt;/a&gt;或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;之前的文章&lt;/a&gt;跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前后端路由与前后端渲染</title>
    <link href="https://molunerfinn.com/fe-be-router-render/"/>
    <id>https://molunerfinn.com/fe-be-router-render/</id>
    <published>2018-03-27T21:26:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>最近经常会遇到有人问诸如类似下面的问题：</p><ul><li>为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了<code>/</code>的页面呢</li><li>为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢</li><li>啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢</li></ul><p>这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。</p><p>老手可以绕道，去看些更有用的文章吧~</p><a id="more"></a><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p><a href="https://zhuanlan.zhihu.com/p/24814675" target="_blank" rel="noopener">理解Web路由</a>这篇文章讲得特别好了。</p><blockquote><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。</p></blockquote><p>访问的URL会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个URL什么东西。路由就是在做一个匹配的工作。</p><h2 id="从后端路由讲起"><a href="#从后端路由讲起" class="headerlink" title="从后端路由讲起"></a>从后端路由讲起</h2><p>在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入<code>www.baidu.com</code>到你看到网页这个过程中经历了什么」其实讲的也是这个道理。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fproibqucxj20lu03odg9.jpg" alt=""></p><p>在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个<code>404</code>状态码。这也是我们常说的<code>404 NOT FOUND</code>的由来。</p><h3 id="URL与Methods"><a href="#URL与Methods" class="headerlink" title="URL与Methods"></a>URL与Methods</h3><p>如果你关注RESTful API，那么将会很熟悉下面四种发起请求的类型：<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>。</p><blockquote><p>它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong> ——来自阮一峰<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">《理解RESTful架构》</a></p></blockquote><p>虽然上面说的是RESTful API，但是实际上我们在地址栏输入一个URL，并回车的时候，是以<code>GET</code>请求发出去的。这也体现了，URL地址和请求的method也应该是一一对应。下面给出一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">'/user/:id'</span>, addUser)</span><br></pre></td></tr></table></figure><p>假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：<code>http://xxx.com/user/123</code>的话是无法访问到的，也会返回一个404。因为后端只配了一个<code>post</code>方法的路由。如果要接受这个请求，那么必须有如下的路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/user/:id'</span>, getUser) <span class="comment">// 配置get路由</span></span><br><span class="line">router.post(<span class="string">'/user/:id'</span>, addUser)</span><br></pre></td></tr></table></figure><h3 id="后端路由与服务端渲染"><a href="#后端路由与服务端渲染" class="headerlink" title="后端路由与服务端渲染"></a>后端路由与服务端渲染</h3><p>前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。</p><p>如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的<strong>服务端渲染</strong>。</p><p>服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。</p><p>node.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。</p><p>不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。</p><p>于是，我们开始进入了前端路由的时代。</p><h2 id="过渡到前端路由"><a href="#过渡到前端路由" class="headerlink" title="过渡到前端路由"></a>过渡到前端路由</h2><p>前端路由——顾名思义，<strong>页面跳转的URL规则匹配</strong>由前端来控制。而前端路由主要是有两种显示方式：</p><ul><li>带有hash的前端路由，优点是兼容性高。缺点是URL带有<code>#</code>号不好看</li><li>不带hash的前端路由，优点是URL不带<code>#</code>号，好看。缺点是既需要浏览器支持也需要后端服务器支持</li></ul><p>前端路由应用最广泛的例子就是当今的SPA的web项目。不管是Vue、React还是Angular的页面工程，都离不开相应配套的router工具。前端路由带来的最明显的好处就是，地址栏URL的跳转不会白屏了——这也得益于前端渲染带来的好处。</p><h3 id="前端路由与前端渲染"><a href="#前端路由与前端渲染" class="headerlink" title="前端路由与前端渲染"></a>前端路由与前端渲染</h3><p>讲前端路由就不能不说前端渲染。我以Vue项目为例。如果你是用官方的<code>vue-cli</code>搭配webpack模板构建的项目，你有没有想过你的浏览器拿到的html是什么样的？是你页面长的那样有<code>button</code>有<code>form</code>的样子么？我想不是的。在生产模式下，你看看构建出来的<code>index.html</code>长什么样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"xxxx.xxx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"yyyy.yyy.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"zzzz.zzz.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常长上面这个样子。可以看到，这个其实就是你的浏览器从服务端拿到的html。这里面空荡荡的只有一个<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>这个入口的div以及下面配套的一系列js文件。所以你看到的页面其实是通过那些js渲染出来的。这也是我们常说的前端渲染。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fproyjjjlij20jg03oq3a.jpg" alt=""></p><p>前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合前端路由，无缝的页面切换体验自然是对用户友好的。不过带来的坏处就是对SEO不友好，毕竟搜索引擎的爬虫只能爬到上面那样的html，对浏览器的版本也会有相应的要求。</p><p>需要明确的是，只要在浏览器地址栏输入URL再回车，是一定会去后端服务器请求一次的。而如果是在页面里通过点击按钮等操作，利用router库的api来进行的URL更新是不会去后端服务器请求的。</p><h4 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h4><p>hash模式利用的是浏览器不会对<code>#</code>号后面的路径对服务端发起路由请求。也即在浏览器里输入如下这两个地址：<code>http://localhost/#/user/1</code>和<code>http://localhost/</code>其实到服务端都是去请求<code>http://localhost</code>这个页面的内容。</p><p>而前端的router库通过捕捉<code>#</code>号后面的参数、地址，来告诉前端库（比如Vue）渲染对应的页面。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过router的api进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回<code>http://localhost</code>对应的html，剩下具体是哪个页面，就由前端路由去判断便可。</p><h4 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h4><p>不带<code>#</code>号的路由，也就是我们通常能见到的URL形式。router库要实现这个功能一般都是通过HTML5提供的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">history</a>这个api。比如<code>history.pushState()</code>可以向浏览器地址栏push一个URL，而这个URL是不会向后端发起请求的！通过这个特性，便能很方便地实现漂亮的URL。不过需要注意的是，这个api对于IE9及其以下版本浏览器是不支持的，IE10开始支持，所以对于浏览器版本是有要求的。vue-router会检测浏览器版本，当无法启用history模式的时候会自动降级为hash模式。</p><p>上面说了，你在页面里的跳转，通常是通过router的api去进行的跳转，router的api调用的通常是<code>history.pushState()</code>这个api，所以跟后端没什么关系。但是<strong>一旦你从浏览器地址栏里输入一个地址，比如<code>http://localhost/user/1</code></strong>,这个URL是会向后端发起一个get请求的。后端路由表里如果没有配置相应的路由，那么自然就会返回一个404了！这也就是很多朋友在生产模式遇到404页面的原因。</p><p>那么很多人会问了，那为什么我在开发模式下没问题呢？那是因为<code>vue-cli</code>在开发模式下帮你启动的那个<code>express</code>开发服务器帮你做了这方面的配置。理论上在开发模式下本来也是需要配置服务端的，只不过<code>vue-cli</code>都帮你配置好了，所以你就不用手动配置了。</p><p>那么该如何配置呢？其实在生产模式下配置也很简单，参考vue-router给出的<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">配置例子</a>。一个原则就是，在所有后端路由规则的最后，配置一个规则，如果前面其他路由规则都不匹配的情况下，就执行这个规则——把构建好的那个<code>index.html</code>返回给前端。这样就解决了后端路由抛出的404的问题了，因为只要你输入了<code>http://localhost/user/1</code>这地址，那么由于后端其他路由都不匹配，那么就会返回给浏览器<code>index.html</code>。</p><p>浏览器拿到这个html之后，router库就开始工作，开始获取地址栏的URL信息，然后再告诉前端库（比如Vue）渲染对应的页面。到这一步就跟hash模式是类似的了。</p><p>当然，由于后端无法抛出404的页面错误，404的URL规则自然是交给前端路由来决定了。你可以自己在前端路由里决定什么URL都不匹配的404页面应该显示什么。</p><h2 id="前端路由与服务端渲染"><a href="#前端路由与服务端渲染" class="headerlink" title="前端路由与服务端渲染"></a>前端路由与服务端渲染</h2><p>虽然前端渲染有诸多好处，不过SEO的问题，还是比较突出的。所以react、vue等框架在后来也在服务端渲染上做着自己的努力。基于前端库的服务端渲染跟以前基于后端语言的服务端渲染又有所不同。前端框架的服务端渲染大多依然采用的是前端路由，并且由于引入了状态统一、vnode等等概念，它们的服务端渲染对服务器的性能要求比php等语言基于的字符串填充的模板引擎渲染对于服务器的性能要求高得多。所以在这方面不仅是框架本身在不断改进算法、优化，服务端的性能也必须要有所提升。当初掘金换成SSR的时候也遇到了对应的性能问题，就是这个原因。</p><p>当然在二者之间，也出现了预渲染的概念。也即先在服务端构建出一部分静态的html文件，用于直出浏览器。然后剩下的页面再通过常用的前端渲染来实现。通常我们可以把首页采用预渲染的方式。这个的好处是明显的，兼顾了SEO和服务器的性能要求。不过它无法做到全站SEO，生产构建阶段耗时也会有所提高，这也是遗憾所在。</p><p>关于预渲染，可以考虑使用<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>这个webapck的插件，它的3.x版本开始使用<strong>puppeteer</strong>来构建html文件了。</p><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>得益于前端路由和现代前端框架的完整的前后端渲染能力，跟页面渲染、组织、组件相关的东西，后端终于可以不用再参与了。</p><p>前后端分离的开发模式也逐渐开始普及。前端开始更加注重页面开发的工程化、自动化，而后端则更专注于api的提供和数据库的保障。代码层面上耦合度也进一步降低，分工也更加明确。我们也摆脱了当初「刀耕火种」的web开发年代。撒花~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过此文能够让你对于前后端路由和前后端渲染有所了解。在实际开发的过程中，也不应该仅仅关注于自己所在的领域，相关的领域也要有所涉猎，这样才能面对问题游刃有余。</p><blockquote><p>注：文中的图我使用OmniGraffle制作。转载请注明作者！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近经常会遇到有人问诸如类似下面的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了&lt;code&gt;/&lt;/code&gt;的页面呢&lt;/li&gt;&lt;li&gt;为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢&lt;/li&gt;&lt;li&gt;啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。&lt;/p&gt;&lt;p&gt;老手可以绕道，去看些更有用的文章吧~&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://molunerfinn.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="笔记" scheme="https://molunerfinn.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战3——跨平台的一些兼容措施</title>
    <link href="https://molunerfinn.com/electron-vue-4/"/>
    <id>https://molunerfinn.com/electron-vue-4/</id>
    <published>2018-03-20T14:40:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="跨平台的重要性"><a href="#跨平台的重要性" class="headerlink" title="跨平台的重要性"></a>跨平台的重要性</h2><p>虽然electron在大多数情况下的跨平台措施已经帮我们做得很好了。不过需要注意的是，不同平台必然存在细节上的差异。我们在书写跨平台应用的时候，如果只在自己书写平台下测试通过的话是不足以说明我们的应用是健壮的。（当然如果你只想提供给某个平台那另当别论）所以针对不同的发布平台，就需要做一些兼容性措施。</p><p>就我自己的感受而言，macOS平台支持的特性相对比较多，而这里面又很多是独有的，所以很多能在macOS上实现的功能却不一定能在windows上实现。所以对于windows用户而言，在保证整体应用的可用性的情况下，就有可能要相应地做一些妥协和牺牲。不过在windows上的一些操作习惯也可以反过来服务于macOS平台。这点我会在下面给出一个例子详细说明。</p><h2 id="留意不同平台的独有功能"><a href="#留意不同平台的独有功能" class="headerlink" title="留意不同平台的独有功能"></a>留意不同平台的独有功能</h2><p>在开发electron应用的时候，很多时候我们只注意去查找api名，却容易忽视这个api能够使用的平台。在官方文档里，对于一些独占的api，大多都会有标识标出：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpifmc1muoj21mo0ti0wa.jpg" alt=""></p><p>不过需要注意的是一些未有平台标识的api里的配置项，也有可能是某个平台的独占：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpifrhg1r8j21k804w0tt.jpg" alt=""></p><p>平时开发的过程中，用到文档的地方还是需要细细留心，避免后续不必要的麻烦。</p><h2 id="跨平台措施入门"><a href="#跨平台措施入门" class="headerlink" title="跨平台措施入门"></a>跨平台措施入门</h2><p>上面讲了这么多，该到实例的时候了。在electron应用中，通常来说<code>renderer</code>进程的东西不需要做太多的跨平台措施——毕竟不管是哪个平台，都是跑在Chrome里的页面。所以大多数情况下，这个方面的工作会放在<code>main</code>进程里。不过也有例外：</p><h3 id="title-bar的操作区处理"><a href="#title-bar的操作区处理" class="headerlink" title="title-bar的操作区处理"></a>title-bar的操作区处理</h3><p>下面是PicGo的windows版：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpig60gzw6j20m80ciwf1.jpg" alt=""></p><p>下面是PicGo的macOS版：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpig71431kj218g0p0tav.jpg" alt=""></p><p>可以发现除了颜色有些区别之外，顶部的<code>title-bar</code>操作栏也有些区别。macOS的程序窗口习惯将窗口的缩放、关闭按钮放在窗口的左上角。而windows程序则相反，它们喜欢放在窗口的右上角。所以为了迎合用户的操作习惯，我们在开发electron程序的时候也应该注意到这一点。</p><p>当然，如果是通过普通的<code>BrowserWindow</code>创建的窗口，那么将会自动拥有常见的macOS、windows的顶部栏，以及默认的样式。</p><p>我在这里想说的是如果想要更加美观的界面，通常我们喜欢「沉浸式」的顶部栏。对于macOS而言，沉浸式的顶部栏就是将顶部栏的三个操作按钮直接「嵌入」窗口主题的左上角。而对于windows而言，只能删去顶部的三个操作按钮，自己用前端的方式来实现了。所以这个地方两个平台的差异性就出来了。</p><p>在<code>main</code>进程里创建该窗口的时候，主要代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSettingWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    height: <span class="number">450</span>,</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 当window创建的时候不用打开</span></span><br><span class="line">    center: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    resizable: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>, <span class="comment">// 窗口模糊的样式</span></span><br><span class="line">    transparent: <span class="literal">true</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>, <span class="comment">// title-bar的样式——隐藏顶部栏的横条，把操作按钮嵌入窗口</span></span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123; <span class="comment">// 如果平台是win32，也即windows</span></span><br><span class="line">    options.show = <span class="literal">true</span> <span class="comment">// 当window创建的时候打开</span></span><br><span class="line">    options.frame = <span class="literal">false</span> <span class="comment">// 创建一个frameless窗口，详情：https://electronjs.org/docs/api/frameless-window</span></span><br><span class="line">    options.backgroundColor = <span class="string">'#3f3c37'</span></span><br><span class="line">  &#125;</span><br><span class="line">  settingWindow = <span class="keyword">new</span> BrowserWindow(options)</span><br><span class="line"></span><br><span class="line">  settingWindow.loadURL(settingWinURL)</span><br><span class="line"></span><br><span class="line">  settingWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    settingWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的工具是通过<code>process.platform</code>来判断不同的平台。当前可能的值有：</p><ul><li>‘aix’</li><li>‘darwin’</li><li>‘freebsd’</li><li>‘linux’</li><li>‘openbsd’</li><li>‘sunos’</li><li>‘win32’</li></ul><p>在这里我们基本上只需要关心<code>darwin</code>（macOS）、<code>win32</code>（windows）、<code>linux</code>（Linux）这三个平台即可。注意，由于electron的对于<code>renderer</code>进程的加持，在<code>renderer</code>进程里也能直接使用<code>process.platform</code>来判断当前的操作系统。这是一个很方便的特性。</p><p>针对windows平台，由于采用了<a href="https://electronjs.org/docs/api/frameless-window" target="_blank" rel="noopener">frameless-window</a>，所以我们需要手动「绘制」顶部的缩放和关闭按钮，并配上相应的事件来模拟真实的按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fake-title-bar"</span>&gt;</span></span><br><span class="line">  PicGo - &#123;&#123; version &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"handle-bar"</span> <span class="attr">v-if</span>=<span class="string">"process.platform === 'win32'"</span>&gt;</span><span class="comment">&lt;!-- 如果是windows平台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-minus"</span> @<span class="attr">click</span>=<span class="string">"minimizeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-close"</span> @<span class="attr">click</span>=<span class="string">"closeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相应的事件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">minimizeWindow () &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = BrowserWindow.getFocusedWindow()</span><br><span class="line">  <span class="built_in">window</span>.minimize()</span><br><span class="line">&#125;,</span><br><span class="line">closeWindow () &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = BrowserWindow.getFocusedWindow()</span><br><span class="line">  <span class="built_in">window</span>.close()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>简单来说就是调用了<code>BrowserWindow</code>的方法来获取当前激活的窗口，然后再对这个窗口进行缩小或关闭的操作。其实也不难对吧！</p><h3 id="任务栏图标交互"><a href="#任务栏图标交互" class="headerlink" title="任务栏图标交互"></a>任务栏图标交互</h3><p>针对不同的平台，我对PicGo的任务栏图标交互也有所区别。对于macOS而言，点击顶部菜单栏的时候会弹出一个小窗口：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fma907llb5j20m30ed46a" alt=""></p><p>由于macOS的顶部栏图标可以接受拖拽事件，所以就针对macOS的顶部栏制作了顶部栏图标对应的小窗口。让大部分操作不经过主窗口也能实现。而对于windows而言，没有顶部栏，取而代之的是位于底部栏的右侧的任务栏，通常点击任务栏里的图标就会把应用的主窗口调出来。所以为了迎合不同平台的操作习惯，我对于这个地方也做了相应的兼容性适配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'click'</span>, () =&gt; &#123; <span class="comment">// 不管是顶部栏的图标还是任务栏的图标都是Tray组件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果是macOS平台</span></span><br><span class="line">    <span class="keyword">let</span> img = clipboard.readImage()</span><br><span class="line">    <span class="keyword">let</span> obj = []</span><br><span class="line">    <span class="keyword">if</span> (!img.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 从剪贴板来的图片默认转为png</span></span><br><span class="line">      <span class="keyword">const</span> imgUrl = <span class="string">'data:image/png;base64,'</span> + Buffer.from(img.toPNG(), <span class="string">'binary'</span>).toString(<span class="string">'base64'</span>)</span><br><span class="line">      obj.push(&#123;</span><br><span class="line">        width: img.getSize().width,</span><br><span class="line">        height: img.getSize().height,</span><br><span class="line">        imgUrl</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    toggleWindow() <span class="comment">// 打开小窗口</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.webContents.send(<span class="string">'clipboardFiles'</span>, obj)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.hide()</span><br><span class="line">    <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123; <span class="comment">// 如果主窗口未创建</span></span><br><span class="line">      createSettingWindow() <span class="comment">// 创建</span></span><br><span class="line">      settingWindow.show() <span class="comment">// 并打开</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      settingWindow.show() <span class="comment">// 如果已存在，打开</span></span><br><span class="line">      settingWindow.focus() <span class="comment">// 并激活</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="窗口关闭与应用退出"><a href="#窗口关闭与应用退出" class="headerlink" title="窗口关闭与应用退出"></a>窗口关闭与应用退出</h3><p>在windows平台上，通常我们把应用的窗口都关了之后也就默认把这个应用给退出了。而如果在macOS系统上却不是这样。我们把应用的窗口关闭了，但是并非完全退出这个应用。所以为了实现这个操作习惯，我们也可以增加一个情况判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123; <span class="comment">// 当窗口都被关闭了</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果不是macOS</span></span><br><span class="line">    app.quit() <span class="comment">// 应用退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要地讲述了electron应用在跨平台开发的时候的一些注意事项。可能很多人会觉得奇怪我为啥把这个章节单独拎出来讲。很多时候我们只关注于应用的开发过程，把应用的功能实现是很多情况下的「终极」目标。然而真实情况是，应用的功能实现只是「基本」目标。一个应用要给用户使用的话必然不仅要考虑到应用的功能，还必须考虑用户的使用习惯。要站在用户的角度来做应用。而不是做自嗨型的应用。所以这篇文章也希望能够帮助想要开发electron应用的你。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-melody v1.5 supports slides &amp; iframe</title>
    <link href="https://molunerfinn.com/slide-support/"/>
    <id>https://molunerfinn.com/slide-support/</id>
    <published>2018-03-06T19:57:52.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-theme-melody-v1-5"><a href="#hexo-theme-melody-v1-5" class="headerlink" title="hexo-theme-melody v1.5"></a>hexo-theme-melody <small>v1.5</small></h2><p>Supports iframe &amp; slides. You can use a layout called <code>slides</code> to enabled the slides layout.</p><p>Also you can add a <code>iframe</code> front-matter with the <code>slides</code> layout in your <code>md</code> file to enable the iframe page.</p><p>===</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="1-Add-a-slides-page"><a href="#1-Add-a-slides-page" class="headerlink" title="1. Add a slides page"></a>1. Add a slides page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page slides</span><br><span class="line"><span class="built_in">cd</span> ./<span class="built_in">source</span>/slides</span><br></pre></td></tr></table></figure><p>===</p><h3 id="2-Add-the-layout-type"><a href="#2-Add-the-layout-type" class="headerlink" title="2. Add the layout type"></a>2. Add the layout type</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.md</span><br></pre></td></tr></table></figure><p>Add a type called <code>slides</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">slides</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-03</span><span class="bullet">-06</span> <span class="number">20</span><span class="string">:24:48</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">slides</span></span><br></pre></td></tr></table></figure><p>===</p><h3 id="3-Modified-the-melody-yml"><a href="#3-Modified-the-melody-yml" class="headerlink" title="3. Modified the melody.yml"></a>3. Modified the melody.yml</h3><p>Add slides default config:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slide:</span></span><br><span class="line"><span class="attr">  separator:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  separator_vertical:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  charset:</span> <span class="string">utf-8</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">black</span></span><br><span class="line"><span class="attr">  mouseWheel:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="string">slide</span></span><br><span class="line"><span class="attr">  transitionSpeed:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  parallaxBackgroundImage:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundSize:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundHorizontal:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  parallaxBackgroundVertical:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><blockquote><p>See reveal.js <a href="https://github.com/hakimel/reveal.js#configuration" target="_blank" rel="noopener">config</a></p></blockquote><p>===</p><h3 id="4-Write-a-md-file-with-slides-layout"><a href="#4-Write-a-md-file-with-slides-layout" class="headerlink" title="4. Write a md file with slides layout"></a>4. Write a md file with slides layout</h3><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure><p>Then you will get a post of slides type.</p><p>===</p><h2 id="Slides-layout-with-iframe"><a href="#Slides-layout-with-iframe" class="headerlink" title="Slides layout with iframe"></a>Slides layout with iframe</h2><p>If you want to add a website whatever you like within an iframe, try this:</p><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">iframe: https://the-url-whatever-you-like</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>Then you will get a post of iframe.</p><p>===</p><h2 id="Configurate-single-slides-in-md"><a href="#Configurate-single-slides-in-md" class="headerlink" title="Configurate single slides in md"></a>Configurate single slides in md</h2><p>The slides config in <code>meldoy.yml</code> can change whole slides page.</p><p>But if you set the config in the md file, it will effect the single page.</p><p>==</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">slide:</span><br><span class="line">  theme: white</span><br><span class="line">  transition: zoom</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure><p>===</p><h1 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy!"></a>Enjoy!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo-theme-melody-v1-5&quot;&gt;&lt;a href=&quot;#hexo-theme-melody-v1-5&quot; class=&quot;headerlink&quot; title=&quot;hexo-theme-melody v1.5&quot;&gt;&lt;/a&gt;hexo-theme-melody &lt;s
      
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="hexo" scheme="https://molunerfinn.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>用新版的Chrome把PWA网站添加到桌面，获得媲美原生应用的体验</title>
    <link href="https://molunerfinn.com/PC-Chrome-PWA/"/>
    <id>https://molunerfinn.com/PC-Chrome-PWA/</id>
    <published>2018-03-03T16:12:00.000Z</published>
    <updated>2018-11-19T15:29:00.610Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2018.03.06 更新：</strong>非PWA网站也能通过独立窗口而非浏览器打开。具体看「注意事项」。</p><h2 id="PWA是什么"><a href="#PWA是什么" class="headerlink" title="PWA是什么"></a>PWA是什么</h2><p>引用自<a href="http://harttle.land/2017/01/28/pwa-explore.html" target="_blank" rel="noopener">Harttle.Land</a>的说法：</p><blockquote><p><a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">PWA</a>(Progressive Web Apps)是 Google 最近在提的一种 Web App 形态 （或者如 Wikipedia 所称的“软件开发方法”）。 Harttle 能找到的关于 PWA 最早的一篇文章是 2015年6月 Alex Russell 的一篇博客： <a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/" target="_blank" rel="noopener">Progressive apps escaping tabs without losing our soul</a>， <strong>让 Web App 从标签页跳出来，同时保持 Web 的灵魂。</strong></p></blockquote><blockquote><p>如 Alex 所述，PWA 意图让 Web 在保留其本质（开放平台、易于访问、可索引）的同时， 在离线、交互、通知等方面达到类似 App 的用户体验。按 <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">Google 官方的解释</a> PWA 具有这些特性：Reliable, Fast, Engaging。</p></blockquote><p>它比原生应用更轻量，但是却比现有的Web APP的功能更加丰富。最大也是最关键的区别是它能够脱离浏览器的「束缚」（虽然依然是基于浏览器的技术），能够把PWA网站添加到你的桌面上，不管是PC操作系统还是手机操作系统，类似于一个原生应用一样，并且拥有媲美原生应用的体验。</p><p>它也能拥有原生APP应用一般的启动闪屏，它也能像原生APP应用一般能有消息推送——不过要知道，它源自Web，通常只有传统APP的体积的十分之一甚至更小。它不用等待下载安装的时间，打开网页的时候就已经「下载」并且「安装」完毕。</p><p>要想体验这项技术，如果你是安卓用户，那最新版的Chrome已经支持；如果你是iOS用户，可以等待3月份的11.3版本更新；如果你是PC电脑用户，那么来看看怎么在电脑上也体验体验PWA吧。</p><a id="more"></a><h2 id="配置Chrome"><a href="#配置Chrome" class="headerlink" title="配置Chrome"></a>配置Chrome</h2><p>首先更新你的Chrome版本到64或以上。</p><p>然后在地址栏输入<code>chrome://flags</code>，找到<code>Desktop PWAs</code>的选项将其<code>Enabled</code>了，然后Chrome会提示你重启浏览器。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozgv6nxloj20l7050q37" alt=""></p><p>重启浏览器后，PWA添加到桌面的特性就已经具备了。</p><h2 id="将PWA网站添加到桌面"><a href="#将PWA网站添加到桌面" class="headerlink" title="将PWA网站添加到桌面"></a>将PWA网站添加到桌面</h2><p>我这里使用的是我的<a href="https://molunerfinn.com">博客</a>（基于自己写的<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>主题搭建的）。打开网站，然后在浏览器右侧找到设置的按钮。接下去我针对Windows平台和macOS平台做分开讲解。</p><h3 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h3><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznbd9gcdj20x10iw4mx" alt=""></p><p>Windows平台找到<code>添加到桌面</code>这个按钮，点击，然后会出现一个确认框：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznebsdhvj20w50gwhba" alt=""></p><p>点击添加。然后你就可以在桌面上看到相应的图标：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozng6ajhhj20bq09hwj9" alt=""></p><p>双击打开：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznhijnsdj20q30gjx1u" alt=""></p><p>你会发现打开了一个没有浏览器痕迹的网页，或者说是个应用——这就是PWA了。PWA支持离线启动技术，即使在没网的情况下也能启动应用。不过在需要网络条件下才能发送的请求依然需要网络环境。</p><h3 id="macOS平台"><a href="#macOS平台" class="headerlink" title="macOS平台"></a>macOS平台</h3><p>相对于Windows平台比较简单的操作，macOS平台的操作相对有点绕弯，不过也大致相同。macOS的Chrome无法一次性就把PWA应用添加到桌面。需要先把PWA网站生成一个app应用，然后你再手动把这个app应用以快捷方式复制到桌面。</p><p>接下来是具体步骤：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozny8dva4j20zk0m81kx" alt=""></p><p>打开一个PWA网站，此处依然以我的<a href="https://molunerfinn.com">博客</a>作为例子，然后再右侧找到配置菜单，下拉选中<code>添加到“应用”文件夹</code>。然后等待几秒钟，会出现一个对话框：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo1ww7ubj20zj0cnx29" alt=""></p><p>此时这个PWA应用已经生成完毕了。我们点击添加。之后你就可以在你的应用列表看到它了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo2gf2xij20zk0m8qcm" alt=""></p><p>不过如果你要在你的桌面上添加这个应用的话，还需要找到这个app的位置，一般是在<code>/Users/你的用户名/Applications/Chrome\ Apps.localized/</code>这个文件夹下。用finder打开：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo545tmij20h50470tp" alt=""></p><p>然后选中这个应用，按住<code>alt+command</code>键把它拖拽到桌面上，就会生成一个快捷方式啦。这个方法也同样适用于其他应用。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果是非PWA应用，也会有<code>添加到桌面</code>或者<code>添加到应用文件夹</code>的选项。不过当你双击打开它们的时候依然会调用Chrome浏览器去打开，跟以前的书签的作用无差别。</p><p><strong>不过</strong>，依然可以通过一个小操作来实现。感谢@<a href="https://weibo.com/5319395630" target="_blank" rel="noopener">RiiSan</a>指出我原文的错误。</p><p>前置步骤跟之前说的一样，然后打开<code>chrome://apps</code>，找到你制作的应用，然后右键，选择<code>在窗口中打开</code>。那么就能获得跟PWA应用单独窗口的类似体验。不过它是不具备PWA离线打开的能力哦，只是纯粹的一个网页通过独立窗口打开而已。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fp32grp8nmj21ns0s8k4a" alt=""></p><p>目前<code>Desktop PWAs</code>还是实验性的功能，所以有可能出现不稳定的情况，依照自己的情况作出决定~</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>就目前来说，我能想到的比较理想的使用条件是，在一些功能性网站支持PWA的情况下，是不用再去下它们的桌面客户端了，直接通过PWA添加到桌面，就能像使用原生应用一样使用它们啦。比如推特，比如Medium等。</p><p>下面给出一个别人总结的PWA网站列表，可以去体验一波~</p><p><a href="https://github.com/hemanth/awesome-pwa" target="_blank" rel="noopener">https://github.com/hemanth/awesome-pwa</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2018.03.06 更新：&lt;/strong&gt;非PWA网站也能通过独立窗口而非浏览器打开。具体看「注意事项」。&lt;/p&gt;&lt;h2 id=&quot;PWA是什么&quot;&gt;&lt;a href=&quot;#PWA是什么&quot; class=&quot;headerlink&quot; title=&quot;PWA是什么&quot;&gt;&lt;/a&gt;PWA是什么&lt;/h2&gt;&lt;p&gt;引用自&lt;a href=&quot;http://harttle.land/2017/01/28/pwa-explore.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Harttle.Land&lt;/a&gt;的说法：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PWA&lt;/a&gt;(Progressive Web Apps)是 Google 最近在提的一种 Web App 形态 （或者如 Wikipedia 所称的“软件开发方法”）。 Harttle 能找到的关于 PWA 最早的一篇文章是 2015年6月 Alex Russell 的一篇博客： &lt;a href=&quot;https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Progressive apps escaping tabs without losing our soul&lt;/a&gt;， &lt;strong&gt;让 Web App 从标签页跳出来，同时保持 Web 的灵魂。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如 Alex 所述，PWA 意图让 Web 在保留其本质（开放平台、易于访问、可索引）的同时， 在离线、交互、通知等方面达到类似 App 的用户体验。按 &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 官方的解释&lt;/a&gt; PWA 具有这些特性：Reliable, Fast, Engaging。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它比原生应用更轻量，但是却比现有的Web APP的功能更加丰富。最大也是最关键的区别是它能够脱离浏览器的「束缚」（虽然依然是基于浏览器的技术），能够把PWA网站添加到你的桌面上，不管是PC操作系统还是手机操作系统，类似于一个原生应用一样，并且拥有媲美原生应用的体验。&lt;/p&gt;&lt;p&gt;它也能拥有原生APP应用一般的启动闪屏，它也能像原生APP应用一般能有消息推送——不过要知道，它源自Web，通常只有传统APP的体积的十分之一甚至更小。它不用等待下载安装的时间，打开网页的时候就已经「下载」并且「安装」完毕。&lt;/p&gt;&lt;p&gt;要想体验这项技术，如果你是安卓用户，那最新版的Chrome已经支持；如果你是iOS用户，可以等待3月份的11.3版本更新；如果你是PC电脑用户，那么来看看怎么在电脑上也体验体验PWA吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="PWA" scheme="https://molunerfinn.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb</title>
    <link href="https://molunerfinn.com/electron-vue-3/"/>
    <id>https://molunerfinn.com/electron-vue-3/</id>
    <published>2018-02-12T21:04:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li>跨平台的一些兼容措施</li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="数据持久化存储的必要性"><a href="#数据持久化存储的必要性" class="headerlink" title="数据持久化存储的必要性"></a>数据持久化存储的必要性</h2><p>不像平时很多人写的一些demo，就是请求一下api然后把web页面展示出来就了事了。electron应用毕竟是个桌面级应用，如果思维还留在纯web开发的思路上，那么也就失去了用electron的意义了吧。</p><p>数据持久化存储实际上对于后端很熟悉。通常是指的是把内存里的数据以不同的存储模型存储到磁盘上，在需要的时候再从存储模型里读取读入内存中的整个流程。这里面的存储模型通常就是我们熟悉的数据库。说到数据库，很多人会想到MySQL，Mongodb，SQLite等等。常见的这些数据库都是Server-Client模式的，需要启动服务端——通常我们装的就是这个。但是你一般很少见到叫别人装个桌面软件的同时，叫别人配数据库的吧。</p><p>因为有些数据我们必须在本地存下来，方便下次使用的时候读取。而对于electron来说，既然让用户装MySQL、Mongodb是不太优雅的解决办法的话，那么如果能用其他方式，将数据存到本地而不用用户操心如何存储的，对我们和用户来说都是一件好事。</p><h2 id="纯JavaScript数据库的选择"><a href="#纯JavaScript数据库的选择" class="headerlink" title="纯JavaScript数据库的选择"></a>纯JavaScript数据库的选择</h2><p>既然是JS技术栈的，于是我就找了一些纯JavaScript实现的数据库。经过初步筛选，我找到如下两个：</p><ol><li><a href="https://github.com/louischatriot/nedb" target="_blank" rel="noopener">nedb</a> 7800star（2018-02-12）</li><li><a href="https://github.com/typicode/lowdb" target="_blank" rel="noopener">lowdb</a> 7269star（2018-02-12）</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>其中就目前来看，nedb用的更为广泛，star数更多（截止2018-02-12），而且有很多讲到nedb和electron配合使用的文章。不过，nedb已经有快两年没有维护了，而且原生不支持Promise，采用的是异步回调（虽然可以通过第三方插件实现Promise）。</p><p>lowdb是用JSON为基本存储结构基于lodash开发的，有lodash的加持，用起来很顺手。优势在于它在持续的维护，有不少好用的插件。并且很关键的是同步操作，采用链式调用的写法，写起来有种jQuery的感觉。再者，用JSON存储的数据，不管是调用还是备份都很方便，这也是让我很喜欢的一点。</p><p>综上，PicGo采用的是lowdb。</p><h2 id="lowdb的初始化"><a href="#lowdb的初始化" class="headerlink" title="lowdb的初始化"></a>lowdb的初始化</h2><p>由于electron给main进程和renderer进程都置入了Node的<code>fs</code>模块，所以我们可以很方便的在两端都使用跟<code>fs</code>相关的操作。而lowdb本质上就是通过<code>fs</code>来读写JSON文件实现的，正好符合我们的要求。所以根据官方给出的文档，我们首先先初始化一下。</p><p><strong>为了操作<code>fs</code>更方便，不妨安装一个<a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener">fs-extra</a>。</strong></p><p>创建一个<code>datastore.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = app.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><p>接着我们在main进程和renderer进程里就可以这样引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span> <span class="comment">// 取决于你的datastore.js的位置</span></span><br></pre></td></tr></table></figure><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>如果仅仅是上面的基本操作，那么这篇文章未免也太简单了。关于electron引入lowdb的踩坑之路现在才开始。</p><h4 id="1-renderer进程要使用remote模块"><a href="#1-renderer进程要使用remote模块" class="headerlink" title="1. renderer进程要使用remote模块"></a>1. renderer进程要使用remote模块</h4><p>首先由上面的初始化能明显看到一个问题。<code>app</code>模块是main进程里特有的，renderer进程应该使用<code>remote.app</code>模块。所以上面的代码在<code>renderer</code>进程里会报错。</p><p>因此第一次修改，使其既能跑在main进程也能跑在renderer进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app, remote &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 引入remote模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app <span class="comment">// 根据process.type来分辨在哪种模式使用哪种模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><h4 id="2-开发模式和生产模式初始化路径问题"><a href="#2-开发模式和生产模式初始化路径问题" class="headerlink" title="2. 开发模式和生产模式初始化路径问题"></a>2. 开发模式和生产模式初始化路径问题</h4><p>在开发模式的时候，通过<code>APP.getPath(&#39;userData&#39;)</code>获取到的路径形如：<code>/Users/molunerfinn/Library/Application Support/Electron</code>（macOS下）。这个是一个已经自动创建好的路径。所以在开发模式的时候，初始化路径是已经存在的。</p><p>然而在生产模式下不是这样。生产模式下，第一次打开应用的过程中，<code>APP.getPath(&#39;userData&#39;)</code>获取的路径并未创建，而<code>datastore.js</code>却已经被加载。所以这个时候初始化路径并不存在。用户在第一次打开应用的时候就会遇到如下报错：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fodwgwq9k6j20nc176dov" alt=""></p><p>所以我们必须在<code>datastore.js</code>里做一次路径是否存在的判断：</p><blockquote><p>此处的fs是来自fs-extra模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123; <span class="comment">// 如果不存在路径</span></span><br><span class="line">    fs.mkdirpSync(STORE_PATH) <span class="comment">// 就创建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化数据"><a href="#3-初始化数据" class="headerlink" title="3. 初始化数据"></a>3. 初始化数据</h4><p>因为有的时候我们需要预先指定数据库的基本结构，比如是个数组，这样我们就初始化为<code>[]</code>。如果是个Object，有具体值，就指定为具体值。而初始化数据结构不应该在每次对数据读写的时候来判断，应该在数据库一开始创建的时候就初始化，所以写在<code>datastore.js</code>里是合适的。</p><p>比如我要初始化上传列表应该是一个数组，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123; <span class="comment">// 先判断该值存不存在</span></span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write() <span class="comment">// 不存在就创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-唯一标识的id字段"><a href="#4-唯一标识的id字段" class="headerlink" title="4. 唯一标识的id字段"></a>4. 唯一标识的id字段</h4><p>用过MySQL的人大多都会在表里初始化一个自增的id字段作为数据的唯一标识。而lowdb虽然无法很方便地创建一个自增的id字段，但是通过<a href="https://github.com/typicode/lodash-id" target="_blank" rel="noopener">lodash-id</a>这个插件可以很方便地为每个新增的数据自动加上一个唯一标识的id字段。</p><p>形如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"weibo"</span>,</span><br><span class="line">  <span class="attr">"width"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"7f247aa7-ffeb-4bb1-87f1-a0d69824ec78"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化也很方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId) <span class="comment">// 通过._mixin()引入</span></span><br></pre></td></tr></table></figure><h3 id="初始化完整代码"><a href="#初始化完整代码" class="headerlink" title="初始化完整代码"></a>初始化完整代码</h3><p>通过上述的踩坑，PicGo的初始化代码如下，仅供参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remote, app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app</span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123;</span><br><span class="line">    fs.mkdirpSync(STORE_PATH)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'picBed'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'picBed'</span>, &#123;</span><br><span class="line">    current: <span class="string">'weibo'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'shortKey'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'shortKey'</span>, &#123;</span><br><span class="line">    upload: <span class="string">'CommandOrControl+Shift+P'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db</span><br></pre></td></tr></table></figure><h2 id="lowdb的基本操作"><a href="#lowdb的基本操作" class="headerlink" title="lowdb的基本操作"></a>lowdb的基本操作</h2><p>数据库的基本操作无非就是CURD。</p><blockquote><p>它代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作。</p></blockquote><p>下面介绍lowdb的基本使用方法。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>主要通过<code>set()</code>或者<code>defaults()</code>方法。其中<code>defaults()</code>专门针对空JSON文件进行初始化。（不过用set也是可以实现类似的，如上一小节说到的初始化）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.defaults(&#123; <span class="attr">posts</span>: [], <span class="attr">user</span>: &#123;&#125;, <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  .write() <span class="comment">// 一定要显式调用write方法将数据存入JSON</span></span><br></pre></td></tr></table></figure><p><strong>注意任何写的操作，都必须显式的使用<code>write()</code>方法来保存。</strong></p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).value() <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>当然还可以用lodash的一些方法来查询你的JSON。</p><p>比如<code>find()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .find(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  .value()</span><br></pre></td></tr></table></figure><p><strong>注意任何读的操作，都必须显式使用<code>value()</code>方法来获取值。</strong></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>通过不同的方法对不同的结构来更新。</p><p>比如针对对象就用赋值，针对数组就用<code>push()</code>或者<code>insert()</code>（lowdb-id提供的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).insert(&#123; <span class="comment">// 对数组进行insert操作</span></span><br><span class="line">  title: <span class="string">'xxx'</span>,</span><br><span class="line">  content: <span class="string">'xxxx'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>针对对象可以直接用<code>set()</code>来更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user.name'</span>, <span class="string">'typicode'</span>) <span class="comment">// 通过set方法来对对象操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user'</span>, &#123;</span><br><span class="line">  name: <span class="string">'typicode'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>很灵活对吧。</p><p>针对原有的数据进行更新的可以用update。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.update(<span class="string">'count'</span>, n =&gt; n + <span class="number">1</span>) <span class="comment">// update方法使用已存在的值来操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可以通过<code>remove()</code>方法删除一个符合条件的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .remove(&#123; <span class="attr">title</span>: <span class="string">'low!'</span> &#125;)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>可以通过<code>unset</code>来删除一个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.unset(<span class="string">'user.name'</span>)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以通过<code>lodash-id</code>提供的<code>removeById()</code>来删除指定id的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .removeById(id)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h2 id="lowdb实际使用的坑"><a href="#lowdb实际使用的坑" class="headerlink" title="lowdb实际使用的坑"></a>lowdb实际使用的坑</h2><p>lowdb在使用的过程中会遇到一个大坑在于，如果就按照基本操作，那么有可能出现我在<code>main</code>进程里存入的值，在<code>renderer</code>进程里读不到。</p><p>为啥？因为直接引用的<code>db</code>实际上只是那个时刻在内存里的数据。lowdb在使用过程中会把JSON数据读入内存中。只有在需要写操作的时候才会将新的数据写入磁盘。</p><p>main进程和renderer进程拿到的db都是应用打开时所读取的。在没有额外处理的情况下，在main进程拿到的内存里的db，和renderer拿到的内存里的db不是同一个db，也就是所谓的不是一个db的两份引用，而是一个db的两份拷贝。main进程对其进行的操作，renderer进程是不知道的。换句话说，main进程对db进行了任何读写操作，renderer拿到的db依然是当初应用打开时所读取的db。所以就会遇到main进程更新了数据，而renderer进程依然无法拿到新的数据。</p><p>那有没有办法解决呢？有的。就是有点麻烦。那就是在所有的db操作的最开始，都重新读取一遍db的最新状态：</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.read().get(<span class="string">'xxx'</span>).value()</span><br><span class="line"></span><br><span class="line">db.read().set(<span class="string">'xxx'</span>, <span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure><p>强制在每个db操作前，都通过read()刷新一遍内存区，这样就能保证拿到的数据都是最新的啦。</p><h2 id="Vue里使用lowdb的便捷方法"><a href="#Vue里使用lowdb的便捷方法" class="headerlink" title="Vue里使用lowdb的便捷方法"></a>Vue里使用lowdb的便捷方法</h2><p>类似于很多人会在Vue里把axios挂在vue的原型链上一样，我们也可以用类似的方法来方便我们在Vue里使用lowdb。</p><p>打开Vue项目的入口文件，通常是<code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$db = db</span><br></pre></td></tr></table></figure><p>这样我们就可以在项目里，用<code>this.$db</code>的方法来使用lowdb啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地介绍了lowdb以及lowdb在electron里的使用。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;跨平台的一些兼容措施&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战1——Main进程和Renderer进程的简单开发</title>
    <link href="https://molunerfinn.com/electron-vue-2/"/>
    <id>https://molunerfinn.com/electron-vue-2/</id>
    <published>2018-01-17T10:55:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li>引入基于Lodash的json database——lowdb</li><li>跨平台的一些兼容措施</li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="Main进程和Renderer进程的基本认识"><a href="#Main进程和Renderer进程的基本认识" class="headerlink" title="Main进程和Renderer进程的基本认识"></a>Main进程和Renderer进程的基本认识</h2><p>从上一篇文章结尾部分我们运行成功的一个electron-vue的<a href="https://molunerfinn.com/electron-vue-1/#electron-vue%E5%AE%89%E8%A3%85">DEMO</a>来直观看看这两个进程的粗浅认识：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnh28jgs8nj20ms098wge" alt=""></p><p>可以看到Main进程管理的是这个app窗口（<a href="https://electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">BrowserWindow</a>），而Renderer进程负责的就是我们熟悉的页面UI渲染。不过实际上，它们远远不仅如此。下面一张图能够把它们所支持、管理的electron或者原生的模块大致列出来：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhcn82n7sj21wu1fmn6v" alt="main &amp; renderer process tree"></p><blockquote><p>图中列出来的大部分模块都是我们会在开发过程中用到的。</p></blockquote><p>它们有各自的模块，也有共有的模块比如<code>clipboard</code>等。还有一部分是Main进程里的模块，不过可以通过<code>remote</code>模块，让renderer进程也能使用。比如<code>Menu</code>比如<code>shell</code>等。</p><p>了解一下哪些模块在哪些进程里，哪些模块可以通过<code>remote</code>模块让renderer进程也能使用是有必要的，这样我们后续开发的时候才能正确的使用。</p><p>上面的模块可能有些从名字里并不能看出作用是啥，没关系，后续的内容会慢慢涉及。</p><h2 id="Main进程开发"><a href="#Main进程开发" class="headerlink" title="Main进程开发"></a>Main进程开发</h2><p>上面说到了Main进程一个显著的作用就是创建app的窗口。我们来看看这个是怎么实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; app, BrowserWindow &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 从electron引入app和BrowserWindow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span> <span class="comment">// 开发模式的话走webpack-dev-server的url</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建窗口</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initial window options</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">563</span>,</span><br><span class="line">    useContentSize: <span class="literal">true</span>,</span><br><span class="line">    width: <span class="number">1000</span></span><br><span class="line">  &#125;) <span class="comment">// 创建一个窗口</span></span><br><span class="line"></span><br><span class="line">  mainWindow.loadURL(winURL) <span class="comment">// 加载窗口的URL -&gt; 来自renderer进程的页面</span></span><br><span class="line"></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow) <span class="comment">// app准备好的时候创建窗口</span></span><br></pre></td></tr></table></figure><p>暂且先不管渲染进程里的页面长什么样，在app准备好的时候打开一个窗口只需要调用一个创建<code>BrowserWindow</code>的方法即可。</p><p>main进程里的开发有点当年写<code>jQuery</code>的样子，比较多的是事件驱动型的写法。</p><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>首先需要注意的是<a href="https://electronjs.org/docs/api/app" target="_blank" rel="noopener">app</a>的模块。这个模块是electron应用的骨架。它掌管着整个应用的生命周期钩子，以及很多其他事件钩子。</p><p>app的常用生命周期钩子如下：</p><ul><li><code>will-finish-launching</code> 在应用完成基本启动进程之后触发</li><li><code>ready</code> 当electron完成初始化后触发</li><li><code>window-all-closed</code> 所有窗口都关闭的时候触发，在windows和linux里，所有窗口都退出的时候<strong>通常</strong>是应用退出的时候</li><li><code>before-quit</code> 退出应用之前的时候触发</li><li><code>will-quit</code> 即将退出应用的时候触发</li><li><code>quit</code> 应用退出的时候触发</li></ul><p>而我们通常会在<code>ready</code>的时候执行创建应用窗口、创建应用菜单、创建应用快捷键等初始化操作。而在<code>will-quit</code>或者<code>quit</code>的时候执行一些清空操作，比如解绑应用快捷键。</p><p>特别的，在非<code>macOS</code>的系统下，通常一个应用的所有窗口都退出的时候，也是这个应用退出之时。所以可以配合<code>window-all-closed</code>这个钩子来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123; <span class="comment">// 当操作系统不是darwin（macOS）的话</span></span><br><span class="line">    app.quit() <span class="comment">// 退出应用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了上面说的生命周期钩子之外，还有一些常用的事件钩子：</p><ul><li><code>active</code>（仅macOS）当应用处于激活状态时</li><li><code>browser-window-created</code> 当一个BrowserWindow被创建的时候</li><li><code>browser-window-focus</code> 当一个BrowserWindow处于激活状态的时候</li></ul><p>这些钩子需要配合一些具体场景来做出具体的操作。比如当一个BrowserWindow处于激活状态的时候修改窗口的title值。</p><p>当然，app这个模块除了上述的一些事件钩子之外，还有一些很常用的方法：</p><ul><li><code>app.quit()</code> 用于退出应用</li><li><code>app.getPath(name)</code> 用于获取一些系统目录，对于存放应用的配置文件等很有用</li><li><code>app.focus()</code> 用于激活应用，不同系统激活逻辑<a href="https://electronjs.org/docs/api/app#appfocus" target="_blank" rel="noopener">不一样</a></li></ul><p>这些事件和方法都是怎么知道的呢？当然是<a href="https://electronjs.org/docs/" target="_blank" rel="noopener">官方文档</a>了。不过并不需要一开始就通读一遍官方的api文档。官方的api文档更多的作用是用来查阅，当你要开发到某个功能的时候再去查它能否有对应的api、怎么使用。</p><h3 id="BrowserWindow"><a href="#BrowserWindow" class="headerlink" title="BrowserWindow"></a>BrowserWindow</h3><p>BrowserWindow模块用于创建最常见的应用窗口。对于不同系统，创建的窗口的默认样式也不太一样。下面来看看macOS和windows的窗口在外观上的区别：</p><p>mac版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncs5yv0qdj21jk0wi44h" alt=""></p><p>windows版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdibuabmj20rq0h2whl" alt=""></p><p>可以看到二者在窗口顶部的操作区（最小化、最大化、关闭）和标题的位置以及菜单的位置还是有明显的不同的。它们跟系统原生的窗口是一致的。不过如果你想要美化一下也是没问题的。比如：</p><p>mac版的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic" alt="picgo-mac"></p><p>和windows的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdb9mj1uj20m80ci3yz" alt="picgo-windows"></p><p>其中mac版用了系统的操作区，而windows则没有用系统的操作区，而是用图标模拟的。不过同样的地方是都未使用系统默认的<code>titlebar</code>。这个之后会结合<code>renderer</code>进程来说。</p><p>让我们来看看创建一个BrowserWindow的常用配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span> = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">900</span>, <span class="comment">// 高</span></span><br><span class="line">    width: <span class="number">400</span>, <span class="comment">// 宽</span></span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 创建后是否显示</span></span><br><span class="line">    frame: <span class="literal">false</span>, <span class="comment">// 是否创建frameless窗口</span></span><br><span class="line">    fullscreenable: <span class="literal">false</span>, <span class="comment">// 是否允许全屏</span></span><br><span class="line">    center: <span class="literal">true</span>, <span class="comment">// 是否出现在屏幕居中的位置</span></span><br><span class="line">    backgroundColor: <span class="string">'#fff'</span> <span class="comment">// 背景色，用于transparent和frameless窗口</span></span><br><span class="line">    titleBarStyle: <span class="string">'xxx'</span> <span class="comment">// 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等</span></span><br><span class="line">    resizable: <span class="literal">false</span>, <span class="comment">// 是否允许拉伸大小</span></span><br><span class="line">    transparent: <span class="literal">true</span>, <span class="comment">// 是否是透明窗口（仅macOS）</span></span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>, <span class="comment">// 窗口模糊的样式（仅macOS）</span></span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span> <span class="comment">// 当页面被置于非激活窗口的时候是否停止动画和计时器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 以及其他可选配置</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.loadURL(url)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.on(<span class="string">'closed'</span>, () =&gt; &#123; <span class="built_in">window</span> = <span class="literal">null</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口的长宽自然不必说，需要指定。其中需要注意的几个比较重要的就是，<code>frame</code>这个选项，默认是<code>true</code>。如果选择了<code>false</code>则会创建一个<code>frameless</code><a href="https://electronjs.org/docs/api/frameless-window" target="_blank" rel="noopener">窗口</a>，创建一个没有顶部工具栏、没有border的窗口。这个也是我们在windows系统下自定义顶部栏的基础。</p><p>像上述PicGo的主窗口的配置，就是通过如下的配置实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSettingWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    height: <span class="number">450</span>,</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    show: <span class="literal">false</span>,</span><br><span class="line">    frame: <span class="literal">true</span>,</span><br><span class="line">    center: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    resizable: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>,</span><br><span class="line">    transparent: <span class="literal">true</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123; <span class="comment">// 针对windows平台做出不同的配置</span></span><br><span class="line">    options.show = <span class="literal">true</span> <span class="comment">// 创建即展示</span></span><br><span class="line">    options.frame = <span class="literal">false</span> <span class="comment">// 创建一个frameless窗口</span></span><br><span class="line">    options.backgroundColor = <span class="string">'#3f3c37'</span> <span class="comment">// 背景色</span></span><br><span class="line">  &#125;</span><br><span class="line">  settingWindow = <span class="keyword">new</span> BrowserWindow(options)</span><br><span class="line"></span><br><span class="line">  settingWindow.loadURL(settingWinURL)</span><br><span class="line"></span><br><span class="line">  settingWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    settingWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟<code>app</code>模块一样，<code>BrowserWindow</code>也有很多常用的事件钩子：</p><ul><li><code>closed</code> 当窗口被关闭的时候</li><li><code>focus</code> 当窗口被激活的时候</li><li><code>show</code> 当窗口展示的时候</li><li><code>hide</code> 当窗口被隐藏的时候</li><li><code>maxmize</code> 当窗口最大化时</li><li><code>minimize</code> 当窗口最小化时</li><li><code>...</code></li></ul><p>当然，也依然有很多实用的方法：</p><ul><li><code>BrowserWindow.getFocusedWindow()</code> [静态方法]获取激活的窗口</li><li><code>win.close()</code> [实例方法，下同]关闭窗口</li><li><code>win.focus()</code> 激活窗口</li><li><code>win.show()</code> 显示窗口</li><li><code>win.hide()</code> 隐藏窗口</li><li><code>win.maximize()</code> 最大化窗口</li><li><code>win.minimize()</code> 最小化窗口</li><li><code>win.restore()</code> 从最小化窗口恢复</li><li><code>...</code></li></ul><p>针对不同的业务逻辑你需要对窗口进行不一样的操作。这个需要跟你的项目需求相匹配。比如上述说到的，windows的顶部的操作区（放大、缩小、关闭按钮）就可以通过icon模拟+实例方法来实现。</p><h3 id="Tray"><a href="#Tray" class="headerlink" title="Tray"></a>Tray</h3><p>一开始看这个名字你可能并不知道这个是个什么东西。可以把它理解为不同系统的任务栏里的图标组件吧。</p><p>比如在macOS里，<code>Tray</code>配合上图标之后就是顶部栏里的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijxxj5gkj215i01at9b" alt=""></p><p>比如在windows里，<code>Tray</code>配合上图标之后就是windows右下角的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijzo4hgbj20gl016a9z" alt=""></p><p>需要注意的是，windows和macOS里，图标的大小都是<code>16*16</code>px。macOS下顶部栏的图标通常都是走<code>黑白</code>路线，所以可以为两种系统分别准备不同的图标。<code>PicGo</code>里<code>Tray</code>的生成代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic) <span class="comment">// 指定图片的路径</span></span><br><span class="line">  <span class="comment">// ... 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述代码里有一个<code>${__static}</code>的变量。该变量是<code>electron-vue</code>为我们暴露出来的项目根目录下的<code>static</code>文件夹的路径。通过这个路径，在开发和生产阶段都能很好的定位你的静态资源所在的目录。是个很方便的变量。</p><p>当然<code>Tray</code>并不只是一个图标而无其他作用了。Tray支持很多有用的事件。其中最关键的两个是<code>click</code>和<code>right-click</code>。分别对应鼠标左键点击和鼠标右键点击事件。</p><h4 id="鼠标左键点击事件"><a href="#鼠标左键点击事件" class="headerlink" title="鼠标左键点击事件"></a>鼠标左键点击事件</h4><ul><li>在macOS系统下，鼠标左键点击Tray的icon可能会出现配置菜单，也有可能会出现应用窗口。</li><li>在windows下，鼠标左键点击Tray的icon通常会出现应用的窗口。</li></ul><h4 id="鼠标右键点击事件"><a href="#鼠标右键点击事件" class="headerlink" title="鼠标右键点击事件"></a>鼠标右键点击事件</h4><ul><li>在macOS系统下，鼠标右键点击Tray的icon通常会出现配置菜单。</li><li>在windows系统下，同上。</li></ul><p>所以需要我们去适配不同操作系统下用户的操作习惯。</p><p>对应于PicGo而言，在macOS系统下左键点击会出现一个menubar的小窗口，右键点击会出现配置菜单。而在windows下，左键点击会直接出现主窗口，（因为在windows下无小窗口的必要），右键点击会出现配置菜单。它们在PicGo里的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic)</span><br><span class="line">  <span class="keyword">const</span> contextMenu = <span class="comment">// ...菜单</span></span><br><span class="line">  tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击</span></span><br><span class="line">    <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">    tray.popUpContextMenu(contextMenu) <span class="comment">// 打开菜单</span></span><br><span class="line">  &#125;)</span><br><span class="line">  tray.on(<span class="string">'click'</span>, () =&gt; &#123; <span class="comment">// 左键点击</span></span><br><span class="line">    <span class="keyword">if</span> (process.platform === <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果是macOS</span></span><br><span class="line">      toggleWindow() <span class="comment">// 打开或关闭小窗口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是windows</span></span><br><span class="line">      <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">      <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123; <span class="comment">// 如果主窗口不存在就创建一个</span></span><br><span class="line">        createSettingWindow()</span><br><span class="line">        settingWindow.show()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果主窗口在，就显示并激活</span></span><br><span class="line">        settingWindow.show()</span><br><span class="line">        settingWindow.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于macOS而言，Tray还有一个很棒的特性——可以拖拽文件到Tray的icon上，会触发如下事件：</p><ul><li><code>drop</code> 当任何东西拖拽到icon上时</li><li><code>drop-files</code> 当文件被拖拽到icon上时</li><li><code>drop-text</code> 当文本被拖拽到icon上时</li><li><code>drop-enter</code> 当刚拖拽到icon上时</li><li><code>drop-leave</code> 当拖拽事件离开icon时</li><li><code>drop-end</code> 当拖拽事件结束时</li></ul><p>就像PicGo实现的拖拽图片到Tray的icon上时实现图片上传的功能，就是用到了上述的一些事件：</p><p><img src="https://user-images.githubusercontent.com/12621342/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" alt=""></p><p>尤其注意到在拖拽上的时候和拖拽结束后的时候icon是不一样的。在PicGo里是这样实现的，很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'drag-enter'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/upload.png`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tray.on(<span class="string">'drag-end'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Tray</code>另一个重要的作用就是开启菜单项。这个将结合下一节<code>Menu</code>一起说明。</p><h3 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h3><p>electron威力强大的Menu组件，既能够生成系统菜单项，也能实现绑定应用常用快捷键的功能。</p><p>先来看看什么是系统菜单项：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisjmm1f9j213m074wln" alt=""></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisory5p4j215c0pen3z" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnislgodz9j204k047mx8" alt=""></p><p>主要分两种。</p><ul><li>第一种是app的菜单。对于macOS来说就是顶部栏左侧区域的菜单项。对于windows而言就是一个窗口的标题栏下方的菜单区。</li><li>第二种是类似于右键菜单的菜单。</li></ul><p>第一种菜单可以通过<code>Menu.setApplicationMenu()</code>来实现。</p><p>第二种菜单可以通过两个步骤来展示：</p><p><strong>1.</strong> 创建菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([...])</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 展示菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击tray的时候</span></span><br><span class="line">  tray.popUpContextMenu(contextMenu) <span class="comment">// 弹出菜单</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们只介绍了<code>Menu</code>本身。其实组成<code>Menu</code>的是一个一个的<code>MenuItem</code>。它们有很多类型：</p><ol><li>normal</li><li>separator</li><li>submenu</li><li>checkbox</li><li>radio</li></ol><p>以及很多角色：</p><ol><li>quit</li><li>copy</li><li>redo</li><li>undo</li><li>minimize</li><li>close</li><li>reload</li><li>…</li></ol><p>通常来说，配置的菜单项基本从类型里来组合。比如PicGo的菜单项：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnivun40bij20fg082wgo" alt=""></p><p>这里面就有normal、submenu、checkbox和radio四种类型。其中默认是normal。</p><p>角色的话通常对应的是一些常见的行为。比如<code>quit</code>是退出app，比如<code>minimize</code>是最小化，比如<code>copy</code>是复制。不过需要注意的是，如果你没有在创建app菜单里指定这些操作的快捷键的话，那么一些常见的快捷操作就无法在你的app里使用了。比如<code>ctrl+c</code>或者<code>command+c</code>复制这个操作，如果你没有通过<code>Menu.setApplicationMenu()</code>来设定这个快捷键的话，那么在你的electron应用里就无法执行复制的操作了。PicGo在早期版本里也犯了这个<a href="">错误</a>。当时的问题是我在开发模式下是没有问题的，但是在生产模式下就无法进行复制粘贴操作。后来查了一下原因，发现原来在开发模式下，electron会置入默认的一些快捷操作菜单，如图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnjcaoo0btj20pg0fcah1" alt=""></p><p>所以在生产模式如果我没有置入这些快捷键的话，使用者就无法使用了。<strong>这个是大坑</strong>。</p><p>说了这么多，来看看生成app的菜单的代码长啥样：</p><blockquote><p>注意，如果在开发模式下直接只使用如下快捷键的话，一些调试快捷键比如<code>F12</code>或者<code>command+shift+i</code>打开控制台的操作就无法使用了。所以在开发模式下不需要创建这些快捷键菜单。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createMenu = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [&#123;</span><br><span class="line">      label: <span class="string">'Edit'</span>,</span><br><span class="line">      submenu: [</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Undo'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'undo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Redo'</span>, <span class="attr">accelerator</span>: <span class="string">'Shift+CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'redo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span>, <span class="attr">selector</span>: <span class="string">'cut:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Copy'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+C'</span>, <span class="attr">selector</span>: <span class="string">'copy:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Paste'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+V'</span>, <span class="attr">selector</span>: <span class="string">'paste:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Select All'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+A'</span>, <span class="attr">selector</span>: <span class="string">'selectAll:'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          label: <span class="string">'Quit'</span>,</span><br><span class="line">          accelerator: <span class="string">'CmdOrCtrl+Q'</span>,</span><br><span class="line">          click () &#123;</span><br><span class="line">            app.quit()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">    menu = Menu.buildFromTemplate(template)</span><br><span class="line">    Menu.setApplicationMenu(menu)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>accelerator</code>指定你想要的快捷键。诸如<code>Shift</code>、<code>Ctrl</code>、<code>Cmd</code>等键位缩写。如果是组合键，就加上<code>+</code>。尤其注意到，因为macOS和windows键位的差异，所以有一个很好用的键位缩写<code>CmdOrCtrl</code>，即如果是在macOS上就是<code>Cmd</code>，在windows上就是<code>Ctrl</code>。</p><p>然后再来看看Tray的“右键”菜单的生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'关于'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       dialog.showMessageBox(&#123;</span><br><span class="line">         title: <span class="string">'PicGo'</span>,</span><br><span class="line">         message: <span class="string">'PicGo'</span>,</span><br><span class="line">         detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开详细窗口'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123;</span><br><span class="line">         createSettingWindow()</span><br><span class="line">         settingWindow.show()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         settingWindow.show()</span><br><span class="line">         settingWindow.focus()</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'选择默认图床'</span>,</span><br><span class="line">     type: <span class="string">'submenu'</span>,</span><br><span class="line">     submenu: [</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'微博图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'weibo'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'weibo'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'七牛图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'qiniu'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'qiniu'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'腾讯云COS'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'tcyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'tcyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'又拍云图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'upyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'upyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开更新助手'</span>,</span><br><span class="line">     type: <span class="string">'checkbox'</span>,</span><br><span class="line">     checked: db.get(<span class="string">'picBed.showUpdateTip'</span>).value(),</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">const</span> value = db.read().get(<span class="string">'picBed.showUpdateTip'</span>).value()</span><br><span class="line">       db.read().set(<span class="string">'picBed.showUpdateTip'</span>, !value).write()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     role: <span class="string">'quit'</span>,</span><br><span class="line">     label: <span class="string">'退出'</span></span><br><span class="line">   &#125;</span><br><span class="line"> ])</span><br><span class="line"></span><br><span class="line"> tray.on(<span class="string">'right-click'</span>, () =&gt; &#123;</span><br><span class="line">   tray.popUpContextMenu(contextMenu)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>注意，菜单项的点击事件可以直接通过<code>click</code>属性来指定。上面我们是先通过了<code>Menu.buildFromTemplate()</code>这个方法创建了菜单，然后再在右键点击<code>Tray</code>图标的时候将其弹（PopUp)出来。</p><p>当然也有其他构建菜单的方法。可以通过Menu实例的<code>append</code>方法来加入<code>Menu Item</code>。如下例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> menu = <span class="keyword">new</span> Menu()</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span> &#125;))</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;)) <span class="comment">// 分割线</span></span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Helper'</span>, <span class="attr">type</span>: <span class="string">'checkbox'</span>, <span class="attr">checked</span>: <span class="literal">true</span> &#125;))</span><br></pre></td></tr></table></figure><p>基本上有了上述的几个基本模块，我们的一个应用的骨架是基本搭建好了，拥有窗口、任务栏应用图标和菜单项。其他的Main进程的模块，并不是必须的，当会用到的时候将在之后的文章里逐步提及。下一节我们将来看renderer进程的开发。</p><h2 id="Renderer进程开发"><a href="#Renderer进程开发" class="headerlink" title="Renderer进程开发"></a>Renderer进程开发</h2><p>对于<code>electron-vue</code>而言，renderer进程其实大部分就是在写我们平时常写的前端页面罢了。不过相对于平时在浏览器里写的页面，在electron里写页面的时候你还能用到不少非浏览器端的模块，比如<code>fs</code>，比如electron通过<code>remote</code>模块暴露给renderer进程的模块。接下去我们来看看renderer进程有哪些需要注意的地方。</p><h3 id="请使用Hash模式"><a href="#请使用Hash模式" class="headerlink" title="请使用Hash模式"></a>请使用Hash模式</h3><p>往常我们在写Vue的时候都比较喜欢开启路由的<code>history</code>模式，因为这样在浏览器的地址栏上看起来比较好看——没有hash的<code>#</code>号，就如同请求后端的url一般。然而需要注意的是，<code>history</code>模式需要后端服务器的支持。</p><p>可能很多朋友平时开发的时候没有感觉，那是因为vue-cli里在开发模式下启动的<code>webpack-dev-server</code>帮你实现了服务端的<code>history-fallback</code>的特性。所以在实际部署的时候，至少都需要在你的web服务器程序诸如<code>nginx</code>、<code>apache</code>等配置相关的规则，让前端路由返回给<code>vue-router</code>去处理。</p><p>而electron里也是如此。在开发模式下，由于使用的是<code>webpack-dev-server</code>开启的服务器，所以<code>BrowserWindow</code>加载的是来自于类似<code></code><a href="http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。" target="_blank" rel="noopener">http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。</a></p><p>因此，从上面的表述你也能明白了。假如我有一个子路由地址为<code>child</code>。如果不启用Hash模式，在开发模式下没啥问题，<code>http://localhost:9080/child</code>，但是在生产模式下，<code>file://${__dirname}/index.html/child</code>却是无法匹配的一条路径。因此在electron下，<code>vue-router</code>请不要使用<code>history</code>模式，而使用默认的<code>hash</code>模式。</p><p>那么上面的问题就迎刃而解，变为<code>file://${__dirname}/index.html#child</code>即可。</p><p>PicGo里加载的页面路由规则如下，从中你也能看出我使用的是<code>hash</code>模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"><span class="keyword">const</span> settingWinURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080/#setting/upload`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html#setting/upload`</span></span><br></pre></td></tr></table></figure><h3 id="实现自己的titlebar"><a href="#实现自己的titlebar" class="headerlink" title="实现自己的titlebar"></a>实现自己的titlebar</h3><p>在上面讲<code>BrowserWindow</code>的时候，我说到有时为了应用的美观，并不想让我们的应用窗口采用系统默认的<code>titlebar</code>，而想用自己写的来实现。这样的话就在创建你的<code>BrowserWindow</code>的配置里加上一句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titleBarStyle: <span class="string">'hidden'</span></span><br></pre></td></tr></table></figure><p>这样就行了。然后你就可以自行在renderer进程的页面里模拟一个顶部的<code>titlebar</code>了，比如上面提到的<code>PicGo</code>的<code>titlebar</code>的样子。实际上代码也很简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fake-title-bar"</span>&gt;</span></span><br><span class="line">  PicGo - &#123;&#123; version &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"handle-bar"</span> <span class="attr">v-if</span>=<span class="string">"os === 'win32'"</span>&gt;</span> <span class="comment">&lt;!-- 如果是windows系统 就加上模拟的操作按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-minus"</span> @<span class="attr">click</span>=<span class="string">"minimizeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-close"</span> @<span class="attr">click</span>=<span class="string">"closeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把这个titlebar的position置顶即可。</p><p>不过在平时的使用中，我们要注意，一般我们鼠标按住titlebar的时候是可以拖动窗口的。但是如果我们在不加可拖拽的属性之前，我们自己写的titlebar是不具备这样的特性的。要加上这个特性也很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fake-title-bar</span> &#123;</span><br><span class="line">  -webkit-app-region drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需一条CSS，即可让你的titlebar可以拖拽。</p><p>不过在windows下，操作区的按钮（缩小、放大、关闭）长按应该是不能拖拽的，所以还需要：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.handle-bar</span> &#123;</span><br><span class="line">  -webkit-app-region no-drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成<code>no-drag</code>，这样就实现了我们自己生成应用的titlebar了。</p><h3 id="drag-amp-drop的避免"><a href="#drag-amp-drop的避免" class="headerlink" title="drag&amp;drop的避免"></a>drag&amp;drop的避免</h3><p>通常我们用Chrome的时候，有个特性是比如你往Chrome里拖入一个pdf，它就会自动用内置的pdf阅读器打开。你往Chrome里拖入一张图片，它就会打开这张图片。由于我们的electron应用的<code>BrowserWindow</code>其实内部也是一个浏览器，所以这样的特性依然存在。而这也是很多人没有注意的地方。也就是当你开发完一个electron应用之后，往里拖入一张图片，一个pdf等等，如果不是一个可拖拽区域（比如PicGo的上传区），那么它就不应该打开这张图、这个pdf，而是将其排除在外。</p><p>所以我们将在全局监听<code>drag</code>和<code>drop</code>事件，当用户拖入一个文件但是又不是拖入可拖拽区域的时候，应该将其屏蔽掉。因为所有的页面都应该要有这样的特性，所以我写了一个vue的<code>mixin</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.disableDragEvent()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    disableDragEvent () &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    &#125;,</span><br><span class="line">    disableDrag (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> dropzone = <span class="built_in">document</span>.getElementById(<span class="string">'upload-area'</span>) <span class="comment">// 这个是可拖拽的上传区</span></span><br><span class="line">      <span class="keyword">if</span> (dropzone === <span class="literal">null</span> || !dropzone.contains(e.target)) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        e.dataTransfer.effectAllowed = <span class="string">'none'</span></span><br><span class="line">        e.dataTransfer.dropEffect = <span class="string">'none'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在全局引入这个mixin即可。</p><h3 id="remote模块的使用"><a href="#remote模块的使用" class="headerlink" title="remote模块的使用"></a>remote模块的使用</h3><p>remote模块是electron为了让一些原本在Main进程里运行的模块也能在renderer进程里运行而创建的。以下说几个我们会用到的。</p><p>在<code>electron-vue</code>里内置了<code>vue-electron</code>这个模块，可以在vue里很方便的使用诸如<code>this.$electron.remote.xxx</code>来使用remote的模块。</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p><code>shell</code>模块的官方说明是：<code>Manage files and URLs using their default applications.</code>也就是使用文件或者URL的默认应用。通常我们可以用其让默认图片应用打开一张图片、让默认浏览器打开一个url。</p><p>如果我们想在renderer进程里点击一个按钮然后在默认浏览器里打开一个url的话就可以这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"openURL"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      openURL () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$electron.remote.shell.openExternal(<span class="string">'https://github.com/Molunerfinn/PicGo'</span>)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是不是很方便？</p><p>更多详细的shell的用法可以参考<a href="https://electronjs.org/docs/api/shell" target="_blank" rel="noopener">文档</a>。</p><h4 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a>dialog</h4><p>有的时候我们会有打开原生的对话框的需求。比如<code>PicGo</code>的版本信息：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje5uvnlrj20nc08kq3d" alt=""></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje4njzafj20a60543yd" alt=""></p><p>这个时候就可以通过<code>dialog</code>这个模块来实现了。逻辑跟上面一样也是点击一个按钮打开一个dialog：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openDialog () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$electron.remote.dialog.showMessageBox(&#123;</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    message: <span class="string">'PicGo'</span>,</span><br><span class="line">    detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细的dialog的用法可以参考<a href="https://electronjs.org/docs/api/dialog" target="_blank" rel="noopener">文档</a>。</p><h4 id="Menu和BrowserWindow的应用"><a href="#Menu和BrowserWindow的应用" class="headerlink" title="Menu和BrowserWindow的应用"></a>Menu和BrowserWindow的应用</h4><p>使用<code>Menu</code>可能很多人能够理解。但是为什么要使用<code>BrowserWindow</code>呢？因为需要定位你打开<code>Menu</code>的窗口。</p><p>在PicGo里，有一个点击按钮打开Menu的操作，大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildMenu () &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [...]</span><br><span class="line">    <span class="keyword">this</span>.menu = Menu.buildFromTemplate(template)</span><br><span class="line">  &#125;,</span><br><span class="line">  openDialog () &#123;</span><br><span class="line">    <span class="keyword">this</span>.menu.popup(remote.getCurrentWindow) <span class="comment">// 获取当前打开Menu的窗口</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>menu.popup</code>就需要你指定一下打开这个menu的窗口。它将自动定位你点击的位置而弹出。</p><h3 id="main进程和renderer进程的通信"><a href="#main进程和renderer进程的通信" class="headerlink" title="main进程和renderer进程的通信"></a>main进程和renderer进程的通信</h3><p>在Vue里，如果是非父子组件通信，很常用的是通过<code>Bus Event</code>来实现的。而electron里的不同进程间的通信其实也很类似，是通过<code>ipcMain</code>和<code>ipcRenderer</code>来实现的。其中<code>ipcMain</code>是在<code>main</code>进程里使用的，而<code>ipcRenderer</code>是在<code>renderer</code>进程里使用的。</p><h4 id="ipcMain和ipcRenderer"><a href="#ipcMain和ipcRenderer" class="headerlink" title="ipcMain和ipcRenderer"></a>ipcMain和ipcRenderer</h4><p>官网的例子其实很简洁明了了，我放出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process.</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcMain&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line">ipcMain.on(<span class="string">'asynchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.sender.send(<span class="string">'asynchronous-reply'</span>, <span class="string">'pong'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">'synchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.returnValue = <span class="string">'pong'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process (web page).</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ipcRenderer.sendSync(<span class="string">'synchronous-message'</span>, <span class="string">'ping'</span>)) <span class="comment">// prints "pong"</span></span><br><span class="line"></span><br><span class="line">ipcRenderer.on(<span class="string">'asynchronous-reply'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// prints "pong"</span></span><br><span class="line">&#125;)</span><br><span class="line">ipcRenderer.send(<span class="string">'asynchronous-message'</span>, <span class="string">'ping'</span>)</span><br></pre></td></tr></table></figure><p>其中<code>ipcMain</code>只有监听来自<code>ipcRenderer</code>的某个事件后才能返回给<code>ipcRenderer</code>值。而<code>ipcRenderer</code>既可以收，也可以发。</p><p>那么问题就来了，如何让<code>ipcMain</code>主动发送消息呢？或者说让main进程主动发送消息给<code>ipcRenderer</code>。</p><p>首先要明确的是，<code>ipcMain</code>无法主动发消息给<code>ipcRenderer</code>。因为ipcMain只有<code>.on()</code>方法没有<code>.send()</code>的方法。所以只能用其他方法来实现。有办法么？有的，用<code>webContents</code>。</p><h4 id="webContents"><a href="#webContents" class="headerlink" title="webContents"></a>webContents</h4><p><code>webContents</code>其实是<code>BrowserWindow</code>实例的一个属性。也就是如果我们需要在<code>main</code>进程里给某个窗口某个页面发送消息，则必须通过<code>win.webContents.send()</code>方法来发送。</p><p>代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process</span></span><br><span class="line"><span class="keyword">let</span> win = <span class="keyword">new</span> BrowserWindow(&#123;...&#125;)</span><br><span class="line">win.webContents.send(<span class="string">'img-files'</span>, imgs)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process</span></span><br><span class="line">ipcRenderer.on(<span class="string">'img-files'</span>, (event, files) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以必须指定要发送的窗口，才能将信息准确送达。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地讲述了electron里<code>Main</code>进程和<code>Renderer</code>进程的基础知识和开发相关。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。内容相比第一篇多了不少，希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。希望本文能够给你带来帮助，这是我最开心的地方。如果喜欢，欢迎关注我的博客以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;引入基于Lodash的json database——lowdb&lt;/li&gt;&lt;li&gt;跨平台的一些兼容措施&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战0——Electron-vue入门</title>
    <link href="https://molunerfinn.com/electron-vue-1/"/>
    <id>https://molunerfinn.com/electron-vue-1/</id>
    <published>2018-01-11T17:30:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li>引入基于Lodash的json database——lowdb</li><li>跨平台的一些兼容措施</li><li>通过CI发布以及更新的方式</li><li>…（想到再写）</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><a id="more"></a><h2 id="Electron简要介绍"><a href="#Electron简要介绍" class="headerlink" title="Electron简要介绍"></a>Electron简要介绍</h2><p>一开始学习electron的时候，我被官网文档密密麻麻的概念所镇住了：</p><p><img src="https://ws1.sinaimg.cn/mw690/8700af19ly1fncsj44xlhj21xy3e8x1g" alt=""></p><p>概念太多，没有办法一下子接受。所以我自己学习完electron开发后，做了一张图。来看看图理解一下什么是<code>electron</code>，以及它包括了啥：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncq342rk8j20cs0d63zd" alt=""></p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>electron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。</p><p>它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用：</p><ol><li>Main进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。</li><li>Renderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。</li><li>Main进程和Renderer进程通过<code>ipcMain</code>和<code>ipcRenderer</code>来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。</li></ol><h3 id="进一步介绍"><a href="#进一步介绍" class="headerlink" title="进一步介绍"></a>进一步介绍</h3><p>说完了electron的组成和需要我们开发的部分，来说说它的优缺点。</p><p>优点：</p><ol><li>从上述介绍可以发现，除了不同平台Native APIs不同以外，Node.js和Chromium都是跨平台的工具，这也为electron生来就能做跨平台的应用开发打下基础。</li><li>开发图形界面前所未有的容易——比起C#\QT\MFC等传统图形界面开发技术，通过前端的图形化界面开发明显更加容易和方便。得益于Chromium，这种开发模式得以实现。</li><li>成熟的社区、活跃的核心团队，大部分electron相关的问题你可以在社区、github issues、Stack Overflow里得到答案。开发的障碍进一步降低。</li></ol><p>缺点：</p><ol><li>应用体积过大。由于内部包装了Chromium和Node.js，使得打包体积（使用<code>electron-builder</code>）在mac上至少是45M+起步，在windows上稍微好一点，不过也要35M+起步。不过相比早期打包体积100M+起步来说，已经好了不少。不过解压后安装依然是100M+起步。</li><li>受限于Node.js和Native APIs的一些支持度的问题，它依然有所局限。一些功能依然无法实现。比如无法获取在系统文件夹里选中的文件，而必须调用web的File或者node的fs接口才可以访问系统文件。</li><li>应用性能依旧是个问题。所以做轻量级应用没问题，重量级应用尤其是CPU密集型应用的话很是问题。</li></ol><h2 id="electron-vue的简要介绍"><a href="#electron-vue的简要介绍" class="headerlink" title="electron-vue的简要介绍"></a>electron-vue的简要介绍</h2><p>由于我自己是Vue的技术栈，所以就想在electron里使用vue。而vue只是在renderer进程里使用的框架，不涉及到main进程。如下图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncpxesazgj20dy08kwf1" alt=""></p><blockquote><p>因此react、angluar以及其他的前端开发框架同样适用。</p></blockquote><p>不过想要做到把vue和electron结合起来并不是一件特别容易的事。为了方便开发，我使用的是<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>，这个是开发者<a href="https://github.com/SimulatedGREG" target="_blank" rel="noopener">SimulatedGREG</a>参考vue-cli的webpack模板骨架搭建的electron和vue结合的开发脚手架。由于我对于<code>vue-cli</code>非常熟悉，所以上手<code>electron-vue</code>非常容易。相比很多其他的教程或者其他electron+前端开发框架的组装方案，<code>electron-vue</code>给我感觉最好的是如下：</p><ol><li>只有一个<code>package.json</code>。而大部分其他的项目结构依然在使用两个<code>package.json</code>来应对main进程和renderer进程的依赖库。</li><li>内建完整的vue全家桶，省去再次配置vue-router和vuex的一些初期操作。</li><li>内建完整的webpack开发、生产等配置，开发环境舒适。</li><li>内建完整的开发、构建等<code>npm scripts</code>，使用非常方便。</li><li>内建完整的Travis-ci、Appveyor配置脚本，只需少数修改就能做到利用CI自动构建的应用发布。</li><li>完善的文档，清晰的项目结构。</li></ol><p>大体的项目结构如下，根据选择的不同设置结构会有所不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">my-project</span><br><span class="line">├─ .electron-vue</span><br><span class="line">│  └─ &lt;build/development&gt;.js files</span><br><span class="line">├─ build</span><br><span class="line">│  └─ icons/</span><br><span class="line">├─ dist</span><br><span class="line">│  ├─ electron/</span><br><span class="line">│  └─ web/</span><br><span class="line">├─ node_modules/</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ main <span class="comment"># 主进程</span></span><br><span class="line">│  │  ├─ index.dev.js</span><br><span class="line">│  │  └─ index.js</span><br><span class="line">│  ├─ renderer <span class="comment"># 渲染进程</span></span><br><span class="line">│  │  ├─ components/</span><br><span class="line">│  │  ├─ router/</span><br><span class="line">│  │  ├─ store/</span><br><span class="line">│  │  ├─ App.vue</span><br><span class="line">│  │  └─ main.js</span><br><span class="line">│  └─ index.ejs</span><br><span class="line">├─ static/</span><br><span class="line">├─ <span class="built_in">test</span></span><br><span class="line">│  ├─ e2e</span><br><span class="line">│  │  ├─ specs/</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ utils.js</span><br><span class="line">│  ├─ unit</span><br><span class="line">│  │  ├─ specs/</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ karma.config.js</span><br><span class="line">│  └─ .eslintrc</span><br><span class="line">├─ .babelrc</span><br><span class="line">├─ .eslintignore</span><br><span class="line">├─ .eslintrc.js</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package.json</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure><p>可以看到我们主要关注的两个文件夹：<code>src/main</code>和<code>src/renderer</code>分别对应的是main进程和renderer进程。我们的开发大体上也是围绕这两个文件夹展开。</p><h2 id="electron-vue安装"><a href="#electron-vue安装" class="headerlink" title="electron-vue安装"></a>electron-vue安装</h2><p>参考<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>官方的文档给出的说明，搭建electron-vue的脚手架非常方便，使用vue-cli来安装它的模板即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你没有vue-cli的话需要全局安装</span></span><br><span class="line">npm install -g vue-cli</span><br><span class="line"><span class="comment"># 然后使用vue-cli来安装electron-vue的模板</span></span><br><span class="line">vue init simulatedgreg/electron-vue my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line">yarn <span class="comment"># or npm install</span></span><br><span class="line"><span class="comment"># 进入开发模式</span></span><br><span class="line">yarn run dev <span class="comment"># or npm run dev</span></span><br></pre></td></tr></table></figure><p>如果你是windows用户，在安装期间遇到了关于<code>node-gyp</code>、C++库等方面的问题的话，请参考官方文档给出的<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/en/getting_started.html#a-note-for-windows-users" target="_blank" rel="noopener">解决办法</a>。</p><p>如果上述都没有问题，那么你将会看到如下界面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncs5yv0qdj21jk0wi44h" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为开篇，内容不多。不过把东西说清楚是必须的。对于electron开发其实是有两种声音的：</p><ol><li>很简单，不过就是web开发换了个壳</li><li>很难，需要了解很多原生的概念，不知道要怎么入手</li></ol><p>其实从本文介绍完，你应该要有一个粗略的认识。electron的开发其实包括了两个部分，一个是main进程的相关开发，一个是renderer进程的相关开发。对于renderer进程的开发对于大多数前端开发人员来说不难。main进程的相关开发，如果你想要把electron的main进程的所以特性都学一遍、都用一遍，确实是需要不少时间的。不过如果是从需求出发，从工程本身的需要出发，那么只需要用到的时候再去学习即可。不过要对Node.js能做到的事有个概念——它并不是万能的。</p><p>下一篇文章将会正式开启electron的开发，如果你对此有兴趣不妨关注我的博客的进展。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;引入基于Lodash的json database——lowdb&lt;/li&gt;&lt;li&gt;跨平台的一些兼容措施&lt;/li&gt;&lt;li&gt;通过CI发布以及更新的方式&lt;/li&gt;&lt;li&gt;…（想到再写）&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>2017小结</title>
    <link href="https://molunerfinn.com/2017-summary/"/>
    <id>https://molunerfinn.com/2017-summary/</id>
    <published>2017-12-27T21:01:00.000Z</published>
    <updated>2018-11-19T15:29:00.610Z</updated>
    
    <content type="html"><![CDATA[<p>年末了，赶着刚考完两门考试，在最后4门考试来临之前抽空写一下今年的小结。</p><a id="more"></a><p>今年格外忙。忙完本科毕设，又马上投入了研究生实验室的搬砖生涯。跟去年一样，列个今年的学习成果清单：</p><h1 id="过去的一年"><a href="#过去的一年" class="headerlink" title="过去的一年"></a>过去的一年</h1><h2 id="技术成果"><a href="#技术成果" class="headerlink" title="技术成果"></a>技术成果</h2><p><strong>2017.03~2017.05.07</strong> 开坑学习Three.js，完成了一个简单的<a href="https://github.com/Molunerfinn/Gear-system" target="_blank" rel="noopener">机械装置展示平台</a>（我的本科毕设）【Three.js+dat.gui】</p><p><strong>2017.05.23~2017.07.15</strong> 基于vue2+koa2重构了<a href="https://fj.teamsz.xyz/" target="_blank" rel="noopener">福建北邮人服务系统</a>，这是我自己的项目。开始引入eslint（以前嫌麻烦233），以后的项目也一并引入。期间在手写一些常用Vue组件的时候学习了不少东西，写了一篇<a href="https://molunerfinn.com/vue-components/">Vue组件的三种调用方式</a>【Vue2+Koa2】</p><p><strong>2017.05.26</strong> 为了上面那个项目简单做了一个基于<code>stylus</code>的栅格系统css——<a href="https://github.com/Molunerfinn/Melody.css" target="_blank" rel="noopener">Melody.css</a>，用来快速做响应式开发。【stylus】</p><p><strong>2017.06.07</strong> 协助解决实验室Vue项目里webpack的Hot Reload速度太慢的问题，做了个webpack的开发模式的插件<a href="https://github.com/Molunerfinn/webpack-dev-compile-optimize" target="_blank" rel="noopener">webpack-dev-compile-optimize</a>提升热重载速度（只在自己内部项目测试过），同期总结了一篇基于<a href="https://molunerfinn.com/Webpack-Optimize/">vue-cli项目的webpack构建优化文章</a>。【webpack】</p><p><strong>2017.07.07</strong> 博客开启持久化构建，依赖于github-page，不过加上了https以及进入了HSTS列表。第一次接触了<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a>，发表了一篇<a href="https://molunerfinn.com/hexo-travisci-https/">经验文</a>。【Travis-CI】</p><p><strong>2017.08.09</strong> 开坑<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>，写一个送给妹子的hexo主题，效果见<a href="https://molunerfinn.com">我博客</a>即是。【hexo hexo-theme】</p><p><strong>2017.10.09</strong> 写每周电影推荐的时候因为嫌弃获取电影信息步骤繁杂，于是改造了一下早期写的node小爬虫<a href="https://github.com/Molunerfinn/dbmovie-spider" target="_blank" rel="noopener">dbmovie-spider</a>支持读取命令行信息了。【node】</p><p><strong>2017.10.28</strong> 开始<a href="https://github.com/Molunerfinn/FE-Learning" target="_blank" rel="noopener">练习算法</a>，并借机学习TypeScript和前端测试（采用了Jest）。 不过后来一直有其他事压着，没有持续，等考完试要继续。【TypeScript Jest】</p><p><strong>2017.11.02</strong> 开坑<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>项目的前端测试。同期写了一篇<a href="https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/">Jest 全栈测试的经验</a>博客。【Jest】</p><p><strong>2017.11.18</strong> 开坑<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，学习electron的基本开发流程，边写边学。最终完成了一个我现在写博客贴图片时很方便的工具。并于12月中发布正式版，还上了少数派首页推荐。【electron】</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmvr6uah8rj21z20vk7wh" alt=""></p><blockquote><p>PS，在掘金也发了一遍<a href="https://juejin.im/post/5a30e4755188256e7a06cc3e" target="_blank" rel="noopener">推荐</a>不过没有被推荐到首页T T</p></blockquote><p>之后应该会发几篇electron开发的文章。</p><p><strong>2017.11.30</strong> 抽空把vue-koa-demo的<a href="https://github.com/Molunerfinn/vue-koa-demo/tree/ssr" target="_blank" rel="noopener">ssr</a>版本做了一下。踩了一些ssr的坑。</p><p>对比去年给自己立的目标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**算法**</span><br><span class="line"></span><br><span class="line">**数据结构**</span><br><span class="line"></span><br><span class="line">**Three.js -&gt; 浏览器3D建模**</span><br><span class="line"></span><br><span class="line">**回归JS语言基础**</span><br><span class="line"></span><br><span class="line">**学会玩Webpack2**</span><br><span class="line"></span><br><span class="line">**持续的项目开源**</span><br><span class="line"></span><br><span class="line">**Python简单入门**</span><br></pre></td></tr></table></figure><p>感觉除了Python没怎么学之外(尴尬)，其他的目标大致都有所建树，算是完成地还不错吧！</p><h2 id="期望、目标"><a href="#期望、目标" class="headerlink" title="期望、目标"></a>期望、目标</h2><p>依然要写下2018年需要学习的东西：</p><ul><li>算法、数据结构</li><li>Parcel</li><li>TypeScript</li><li>Puppeteer自动化测试</li><li>PWA</li><li>给开源库提PR</li><li>github robot</li><li>如果可以，学习一下react</li></ul><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>这一年来的前端的学习之路，收获还是不少的。比起去年来说，我自己觉得收获最大的就是在开源社区跟开发者、使用者的交流更多了。因为自己也有开源项目，所以很多时候一些情况也是第一次见：比如第一次遇到PR（开心不已），第一次给开源库提issue，第一次跟开发者讨论项目细节等等。今年还没有给开源库提过PR，所以明年的目标是来一个吧~</p><p>今年也是前端框架、库井喷的一年。各种新的技术涌现、较新的技术逐渐走向成熟、成熟的项目走向稳定。这种感觉似乎从我两年半前学习前端的时候就有了，不过今年真的特别强烈。也因此才有那篇流传甚广的《2017年学JavaScript是怎样的一种体验》。前端要学的东西太多了啊。不过我觉得虽然看似多，作为前端工程师，还是要有自己的大体学习路线。</p><p>我认为如今前端工程师应当分成两类，</p><ol><li>结合Node的偏向全栈的前端，他们更注重网站的访问优化、性能提升、毫秒级别的用户体验。</li><li>结合CSS\JS的偏向用户端特效的“纯”前端工程师。这部分的前端工程师通常来说必须要有自己的设计认知。</li></ol><p>很多优秀的前端工程师都是设计师出身。比如TJ，比如尤雨溪。但是却不是很常听说优秀的设计师是前端工程师出身。这就是因为现在很多学前端的人还是在认为自己能够写个页面、套个模板，厉害点的还原个页面就行了。殊不知，你要学习的不仅仅是前端配套的HTML\CSS\JS，你还需要知道结合了Nodejs后带来的一系列现代开发工具和工程化的流程。不再是只会用个bootstrap+jquery做个页面就完事的年代了。刀耕火种的年代已经过去，可是还是有人在抓着旧石器不放。</p><p>不过还是需要强调一下，基础真的很重要。我身边遇到太多半路“出家”，自愿也好，被迫也罢来学前端的同学，他们很多都是草草几天看完HTML\CSS\JS基础，然后就直接用上Vue、React来写项目了。连npm都不知道是什么东西的他们，很多时候写起前端来非常痛苦。前端不再是以前那样认为的是一门可以速成的技术了啊，现在而言，至少入门门槛高了不少。</p><p>前端圈还是太浮躁了点。还是沉下心来，好好钻研自己喜欢的技术吧。</p><p>另外，由于最近出现的诸如PWA、Electron、RN、微信小程序等由前端主导的新技术，很多人就说了“啊iOS开发要完啦”、“啊安卓开发要完啦”、“要转行前端啦”等，我觉得其实还没有必要恐慌到那个程度。诚然如今前端能做的事不少，但是局限性还是很强。PWA由于依赖高版本Chrome在一般安卓机器上体验依然不怎么样，想做出像原生一样的效果还是受限于机能，iOS就更别说了，虽然safari开始支持service worker，但支持PWA还有待时日；Electron虽然能开发跨端应用，不过还有很多的局限，比如应用体积实在大，比如无法获取外部当前鼠标选中的文件等等。所以对于新技术应该理性看待，自己亲手实践一下，而不应盲目从众。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>今年的技术栈成长：</strong></p><ul><li>更加深入Vue的开发</li><li>开始学习Three.js</li><li>开始用上ESLint</li><li>开始学习TypeScript</li><li>开始使用前端测试（Jest）</li><li>开始学习Electron</li><li>开始练习算法</li><li>对前端工程化+自动化有更多的实践和体会</li><li>持续维护三个开源项目：<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>、<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>、<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></li><li>学习持续集成</li></ul><p>希望我的2018年能够继续有所收获！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年末了，赶着刚考完两门考试，在最后4门考试来临之前抽空写一下今年的小结。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="随笔" scheme="https://molunerfinn.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>一周一部好电影IV【WEEK186 一级恐惧】</title>
    <link href="https://molunerfinn.com/PerfectMoviePerWeek4/"/>
    <id>https://molunerfinn.com/PerfectMoviePerWeek4/</id>
    <published>2017-12-19T23:50:00.000Z</published>
    <updated>2018-11-19T15:29:00.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017-12-17-WEEK186-一级恐惧"><a href="#2017-12-17-WEEK186-一级恐惧" class="headerlink" title="2017-12-17 WEEK186 一级恐惧"></a>2017-12-17 WEEK186 一级恐惧</h3><p>一级恐惧——————————————Primal Fear<br><img src="https://img.piegg.cn/week186.jpg?imageslim" alt="一级恐惧" title="一级恐惧"></p><a id="more"></a><ul><li>导演：格里高利·霍布里特</li><li>主演：理查·基尔/劳拉·琳妮/约翰·马奥尼/阿尔法·伍达德/弗兰西斯·麦克多蒙德/爱德华·诺顿/特瑞·欧奎恩/安德鲁·布劳尔/斯蒂文·鲍尔/乔·斯帕诺/托尼·普拉纳/斯坦利·安德森/毛拉·蒂尔内/乔恩·塞达/瑞格·罗杰斯</li><li>片长：129 分钟</li><li>影 片类型：剧情/悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.4/10(from88,522users)</li><li>IMDB评分：7.7/10(from146,891users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是一部96年的悬疑惊悚电影。你如果看过《搏击俱乐部》，一定不会忘记爱德华·诺顿饰演的杰克。而作为他的荧幕处女座，本片他虽然作为一个配角却已经技惊四座。当然主角的演技也不容忽视。可以说本片的一大亮点在于演员的精湛功力。</p><p>歌颂完演技，来说说这部片子的实质。本片讨论的核心就在于正义。何为正义？通常我们觉得某个案子里，A是好人，B是坏人。那么B就应该受到惩罚，A就是应该伸张正义。然而很多时候，好人坏人的界定却很模糊。在某些情况下，A可能是好人，但是在某些情况下A就有可能是坏人。所以世间万事并不能简单的来下定义。正义正是如此。本片探讨的正义，在不同的情形下有不同的理解。而本片最让人觉得恐惧，并且赞叹的地方莫过于结局。那是来自内心的恐惧，那是Primal Fear。非常有意思的一部电影，值得一看。</p><hr><h3 id="2017-12-12-WEEK185-不可饶恕"><a href="#2017-12-12-WEEK185-不可饶恕" class="headerlink" title="2017-12-12 WEEK185 不可饶恕"></a>2017-12-12 WEEK185 不可饶恕</h3><p>不可饶恕——————————————용서는 없다<br><img src="https://img.piegg.cn/week185.jpg?imageslim" alt="不可饶恕" title="不可饶恕"></p><!--more--><ul><li>导演：金亨俊</li><li>主演：薛耿求/韩惠珍/柳昇范</li><li>片长：125分钟</li><li>影 片类型：惊悚</li><li>豆 瓣评分：7.7/10(from28,231users)</li><li>IMDB评分：7.4/10(from3,799users)</li></ul><p>Hi，各位好久不见！今天（12月13日）是南京大屠杀80周年纪念日，国家公祭日，让我们先为当年遇难的同胞默哀。勿忘国耻！</p><p>本周给大家推荐的电影是来自韩国的《不可饶恕》。秉承了韩国惊悚、悬疑电影的一贯风格，这部电影从一开始就是比较吸引眼球的。不过与其他的悬疑电影不同的是，它的凶手很早就暴露在观众面前了。失去了这一重大悬念的话，电影还有可看的空间吗？有。它从一开始就铺下了“天罗地网”就等你掉进去。</p><p>老戏骨薛耿求的演技自然不必说。不过我觉得这部电影还是胜在了编剧和情节。尤其是结尾的逆天结局，对于大多数观众来说就是一记全垒打了。不过这部电影的硬伤也很严重。对于结局的不同理解都会暴露出不同的硬伤，这也是它比较遗憾的地方——不过能够有如此大胆构思的编剧也是绝了，毕竟它只是一部电影，不能完全用现实世界的条件去约束它。而片中透露出的复仇的火焰，比我当初看《老男孩》的时候有过之而无不及。好电影，值得一看！</p><hr><h3 id="2017-12-05-WEEK184-天才枪手"><a href="#2017-12-05-WEEK184-天才枪手" class="headerlink" title="2017-12-05 WEEK184 天才枪手"></a>2017-12-05 WEEK184 天才枪手</h3><p>天才枪手——————————————ฉลาดเกมส์โกง<br><img src="https://img.piegg.cn/week184.jpg?imageslim" alt="天才枪手" title="天才枪手"></p><!--more--><ul><li>导演：纳塔吾·彭皮里亚</li><li>主演：茱蒂蒙·琼查容苏因/查侬·散顶腾古/依莎亚·贺苏汪/披纳若·苏潘平佑/塔内·瓦拉库努娄/莎琳雷特·托马斯/伊戈·米基塔斯/帕辛·宽萨塔彭/萨哈贾克·波斯安吉特/坎嘉娜·维耐潘尼/育塔彭·瓦拉努科洛楚/诺帕瓦特·里基特王</li><li>片长：130分钟</li><li>影 片类型：剧情/悬疑/犯罪</li><li>豆 瓣评分：8.2/10(from192,362users)</li><li>IMDB评分：8.0/10(from4,424users)</li></ul><p>Hi，各位，好久不见！本期给大家推荐的是一部前段时间比较热门的一部泰国电影《天才枪手》。之前一直没时间看看它。本周拿出时间看完后，不禁赞叹，能把一部题材并不复杂的电影拍得如此吸引人真的超出了我的想象。</p><p>不管你看没看过这部电影，从中文翻译过来的片名里你也大概能知道本片在说的是什么。这是一部根据真实事件改编的电影（有趣的是，真实事件里的主人公是中国人，然而却被泰国导演拿去拍电影了），讲的就是我们从小到大或多或少都会接触的一个东西——考试作弊。我觉得从小到大，大大小小的考试、测验里，说自己没有做过弊的同学应该不多。所以在这部电影里，主角作弊的时候，不管是导演的拍摄手段还是气氛渲染，我觉得观众在看这部电影的过程中会不自主的把自己和主角联系在一起，所以那种紧迫感就油然而生了。</p><p>当然如果只是讲作弊的故事自然不够过瘾。本片里对于泰国的一些社会现象和人性的变化都做了自己理解的阐述。主角们的性格也各自有着鲜明的对比，几个演员的演技也比起国内同期的新生代演员来得更加成熟和有力。而影片里的插曲配乐也是难得的加分项。可能结局会让人有所失望，不过我觉得这个结局毕竟还是比较符合叙事和电影想要表达的思想——命运在自己手里，一切取决于我。好电影，值得一看。</p><hr><h3 id="2017-11-26-WEEK183-嘉年华"><a href="#2017-11-26-WEEK183-嘉年华" class="headerlink" title="2017-11-26 WEEK183 嘉年华"></a>2017-11-26 WEEK183 嘉年华</h3><p>嘉年华——————————————Angels Wear White<br><img src="https://img.piegg.cn/week183.jpg?imageslim" alt="嘉年华" title="嘉年华"></p><!--more--><ul><li>导演：文晏</li><li>主演：文淇/周美君/史可/耿乐/刘威葳/彭静/王栎鑫/李梦男</li><li>片长：107分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：8.6/10(from27,228users)</li><li>IMDB评分：7.2/10(from195users)</li></ul><p>Hi，各位好久不见。最近的一个月来，社会上发生了很多事，很多不是很好的事。不过这部电影能够过审，能够上映，却真的是一件最难得的事了。</p><p>相信很多人都看过《熔炉》这部韩国电影，这部取材自真实事件，优秀的剧本+实力派的演员演绎的电影，自是获得无数赞誉，并且对韩国社会产生了意义深远的影响。而很多人把《嘉年华》这部电影比作中国版的《熔炉》，但我觉得这是不对的。不是说《熔炉》不好，《熔炉》这部好电影也是我以前推荐过的。我觉得更难得的是，我们拍出了《熔炉》这个级别的电影，而不是中国版的它——是难得的，是进步，伟大的一步。</p><p>从剧情角度上来说，它可能不如《熔炉》“好看”。但我认为这部电影不是以“好看”“不好看”来鉴别的。它更多的是把这个社会对于幼童被性侵之后的种种态度，克制而坚决地表达了出来。它虽然是一部虚构的电影，但是它却时时刻刻能发生在我们的国家，我们的身边。</p><p>片名的中文是《嘉年华》。但是英文名却很有意思的是《Angels Wear White》（天使穿着白衣）。与熔炉绝望的结局不同的是，《嘉年华》给出的结局，是开放的。有可能变得更好，也有可能一直糟糕下去，不过它带给我们的思考却是延续的，至少希望还是有的。我们在指责影片中那些令人发指的人物的行径的同时，可曾想过，如果事情发生在我们的身边，我们是否依然只是操起键盘一阵轰炸，茶余饭后一阵笑谈，三日之后相忘于江湖呢？我一直说，从电影中反观社会。《熔炉》之后改变了韩国，而《嘉年华》之后呢？看着那寥寥无几的排片，少得可怜的宣传，我曾想过的一些波澜，看来还是无法在我们的社会中惊起一些水花。</p><p>我感动的是在观影中大家的安静，凝重和沉思。豆瓣上的一句话我看完，印象非常深刻但也非常痛心：“我们拍出了熔炉一样的电影，却没有熔炉一样的观众”。我希望这部电影应该是当下所有国人都应该观看的一部电影，因为，它真的是一部好电影。</p><hr><h3 id="2017-11-12-WEEK182-非常嫌疑犯"><a href="#2017-11-12-WEEK182-非常嫌疑犯" class="headerlink" title="2017-11-12 WEEK182 非常嫌疑犯"></a>2017-11-12 WEEK182 非常嫌疑犯</h3><p>非常嫌疑犯——————————————The Usual Suspects<br><img src="https://img.piegg.cn/week182.jpg?imageslim" alt="非常嫌疑犯" title="非常嫌疑犯"></p><!--more--><ul><li>导演：布莱恩·辛格</li><li>主演：史蒂芬·鲍德温/加布里埃尔·伯恩/本尼西奥·德尔·托罗/凯文·波拉克/凯文·史派西/查兹·帕尔明特瑞/皮特·波斯尔思韦特/苏茜·爱米斯/吉安卡罗·埃斯波西托/丹·哈达亚/保罗·巴特尔/卡尔·布瑞斯勒/菲力浦·西蒙/杰克·希勒/克里斯汀·艾斯布鲁克</li><li>片长：106分钟</li><li>影 片类型：剧情/悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.6/10(from113,108users)</li><li>IMDB评分：8.6/10(from820,898users)</li></ul><p>Hi，各位好久不见~本周给大家带来的是一部比较早期的电影——1995年的《非常嫌疑犯》。作为一部悬疑片，我觉得他的前几分钟的铺垫做的真的特别好。好的悬疑电影自然是在给观众想尽办法地留坑，然后再给你来一记重拳。不过明显的地方就是，你能感觉到留坑了，或者可能留坑了。</p><p>这部电影则不一样，因为你是从一开始就被牵着鼻子走。而且得知真相的你还没来得及喘气之时，非常嫌疑犯已经扬长而去。不得不说凯文·史派西的演技在那个时候有已经是非常棒了。想感受一下被致命一击的恍然大悟，然后再由衷发出惊叹的话，这部电影不能错过。</p><hr><h3 id="2017-11-09-WEEK181-暧暧内含光"><a href="#2017-11-09-WEEK181-暧暧内含光" class="headerlink" title="2017-11-09 WEEK181 暧暧内含光"></a>2017-11-09 WEEK181 暧暧内含光</h3><p>暧暧内含光——————————————Eternal Sunshine of the Spotless Mind<br><img src="https://img.piegg.cn/week181.jpg?imageslim" alt="暧暧内含光" title="暧暧内含光"></p><!--more--><ul><li>导演：米歇尔·贡德里</li><li>主演：金·凯瑞/凯特·温丝莱特/伊利亚·伍德/克斯汀·邓斯特/汤姆斯·杰·瑞恩/马克·鲁弗洛/简·亚当斯/大卫·克罗斯/汤姆·威尔金森/Amir Ali Said/Brian Price/Paulie Litt</li><li>片长：108分钟</li><li>影 片类型：剧情/爱情/奇幻</li><li>豆 瓣评分：8.4/10(from140,391users)</li><li>IMDB评分：8.3/10(from741,540users)</li></ul><p>Hi，各位好久不见~本周给大家推荐的是来自美国的一部很有意思的电影。关于记忆和爱情，它给出了别样的思考。</p><p>这部电影可能一开始节奏有点慢有点怪。不过从一个时刻开始，这部电影就真的开始走向令人惊讶的地步了。情节猎奇，但是却一点也不狗血，相反很有内涵。我记得以前，曾听过一个我觉得很有感觉的说法。你可以抹去一个人的记忆，但是你却没有办法抹去对这个人的感觉。我觉得这句话用在这部电影里真的很合适。虽然是一部奇幻电影，但是带给我们的启迪却远超一部现实主义的电影。很多时候面对问题的时候我们很喜欢回避、逃避。但是很多时候直面问题反而能得到更好的效果。我们可以选择忘却一些东西，但是无法忘却曾经为此付出的时间和感情。</p><p>也许你需要的不过是鼓起勇气说一声“对不起”，不过是一句“我错了”，不过是一句“我爱你”。但是选择了忘记，选择了逃避，你就选择了失去。好电影，值得一看。</p><hr><h3 id="2017-11-01-WEEK180-沉静如海"><a href="#2017-11-01-WEEK180-沉静如海" class="headerlink" title="2017-11-01 WEEK180 沉静如海"></a>2017-11-01 WEEK180 沉静如海</h3><p>沉静如海——————————————Le silence de la mer<br><img src="https://img.piegg.cn/week180.jpg?imageslim" alt="沉静如海" title="沉静如海"></p><!--more--><ul><li>导演：皮埃尔·布特龙</li><li>主演：朱莉·德拉姆/米歇尔·加拉布吕/托马斯·儒阿特/玛丽·布奈尔/Timothée Ferrand/Jean-Baptiste Puech/Jorg Schnass/Jorn Cambreleng</li><li>片长：93分钟</li><li>影 片类型：剧情/爱情/战争</li><li>豆 瓣评分：9.0/10(from27,068users)</li><li>IMDB评分：8.0/10(from593users)</li></ul><p>Hi，各位好久不见~本周给大家推荐的又是一部冷门佳作，来自法国和比利时的《沉静如海》。这部电影对于追求大场面、曲折的剧情的朋友们来说不太合适。相反，很适合那种一个人在安静的环境下静静的观看的电影。</p><p>背景在德国占领法国之后。德国开始傀儡法国的政府。很多德国士兵、军官并没有固定的居所。在此背景下，有一个德国军官被安排到一个只有女孩和她爷爷相依为命的大房子，作为暂住。由于刚刚战败，所以很多法国人对于德国人并无好感。片中女孩和爷爷对于这个德国军官也是如此。沉默以对，冷眼相看。就在这种情况下，绅士风范的军官和沉默不语的爷孙俩形成了强烈的对比。</p><p>爱国之心让她无法和他谈话。然而脱去戎装的他，本质并不坏，甚至还很有风度。矛盾贯穿着全剧，不断地虐着观众的心。女孩对军官说的唯一一句话也竟然是最后一句话，被战争吞噬的情感，被海洋沉默的话语。伴随着终了流泪的钢琴声，好电影值得一看。</p><hr><h3 id="2017-10-22-WEEK179-北壁"><a href="#2017-10-22-WEEK179-北壁" class="headerlink" title="2017-10-22 WEEK179 北壁"></a>2017-10-22 WEEK179 北壁</h3><p>北壁——————————————Nordwand<br><img src="https://img.piegg.cn/week179.jpg?imageslim" alt="北壁" title="北壁"></p><!--more--><ul><li>导演：菲利普·施特尔茨尔</li><li>主演：本诺·菲尔曼/弗洛里安·卢卡斯/约翰娜·沃卡莱克/格奥尔格·弗里德里希/乌尔里希·图库尔/埃尔温·施泰因豪尔/布兰科·萨马罗夫斯基/汉斯彼得·米勒</li><li>片长：126分钟</li><li>影 片类型：剧情/历史/冒险/运动</li><li>豆 瓣评分：8.5/10(from7,142users)</li><li>IMDB评分：7.4/10(from12,501users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是一部来自德国的佳作《北壁》。讲述的是1936年奥运会前夕，德国发起的挑战阿尔卑斯山艾格峰北壁的活动。两个德国年轻人向着第一个征服艾格峰北壁的人的光辉荣誉就去了。当年在没有准确的气象预报、没有良好的攀爬装备、没有前人的经验下，向艾格峰北壁（死亡之壁）发起挑战是需要多大的勇气。</p><p>本片根据真实事件改编，见证了艾格峰登山史上最惨烈的一次攀登。影片将当年的恶劣气候、登山者的勇气和决心，毅力和绝望、救援队的无能和无力、观众的冷漠和人性淋漓尽致地展现在你的面前。情节一步一步走向高潮，而且越来越紧凑，让人有种完全沉浸的感觉。</p><p>“此刻我不是为了拍照”。当女主将此话撂下，惊得编辑无话可说之际，真的对于人性的黑暗有无比强烈的谴责。“我不行了。”话音落下，悬挂在半空之中的托尼，是那么的悲壮而伟大。好电影，值得一看。</p><hr><h3 id="2017-10-09-WEEK178-危楼愚夫"><a href="#2017-10-09-WEEK178-危楼愚夫" class="headerlink" title="2017-10-09 WEEK178 危楼愚夫"></a>2017-10-09 WEEK178 危楼愚夫</h3><p>危楼愚夫——————————————Дурак<br><img src="https://img.piegg.cn/week178.jpg?imageslim" alt="危楼愚夫" title="危楼愚夫"></p><!--more--><ul><li>导演：尤里·贝科夫</li><li>主演：阿尔焦姆·贝斯特罗夫/娜塔莉亚·苏尔科娃/尤里·楚里洛/鲍里斯·涅夫佐罗夫/基里尔·波卢欣/亚历山大·科尔舒诺夫/奥尔嘉·萨莫希纳/达里娅·莫罗兹/谢尔盖·阿尔齐巴舍夫/叶莲娜·维克托罗夫娜·帕诺娃/德米特里·库利奇科夫/伊利亚·伊萨耶夫/马克西姆·平斯克尔/柳博夫·鲁坚科/伊丽娜·尼齐纳/戈尔戴·科勃泽夫/彼得·巴兰切耶夫</li><li>片长：116分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：8.4/10(from20,095users)</li><li>IMDB评分：8.0/10(from5,844users)</li></ul><p>Hi，各位好久不见。由于国庆节给自己放了个假，所以推荐就姗姗来迟。本期给大家推荐的是一部来自俄罗斯的冷门佳片——《危楼愚夫》。</p><p>一座危楼，一群愚夫，一堆渣滓，一个“愚夫”。全片暗黑的色调预示着这并不是一部轻松欢快的电影。它是俄罗斯的一部反映社会现实题材的电影——从正常的角度来说，它是虚构的。但是从某个角度来说，它却是真真实实地在发生。</p><p>众人皆醉我独醒。有着一腔热血和正义感的季马，既无法撼动在执政的政府人士，也无法撼动生活在社会底层已久的愚夫。讽刺的意味处处充满了电影，人物的描写也是入木三分。正如电影里说的一句话：“我们一起像猪一样地活着，也会像猪一样得死，就是因为我们彼此什么都不是。”看完电影，心情真的十分沉重。这部电影真的看完特别难受，因为在很多情况下我们甚至也像电影里的愚夫一般。好电影，值得一看。</p><hr><h3 id="2017-10-01-WEEK177-出租车司机"><a href="#2017-10-01-WEEK177-出租车司机" class="headerlink" title="2017-10-01 WEEK177 出租车司机"></a>2017-10-01 WEEK177 出租车司机</h3><p>出租车司机——————————————택시 운전사<br><img src="https://img.piegg.cn/week177.jpg?imageslim" alt="出租车司机" title="出租车司机"></p><!--more--><ul><li>导演：张勋</li><li>主演：宋康昊/托马斯·克莱舒曼/柳海真/柳俊烈/朴赫权/崔奎华/李静恩/郑镇荣/严泰久/朴珉熙/李容怡/高昌锡/全慧珍/柳恩美/丹尼尔·乔伊·奥尔布赖特/柳泰浩/金正洙/郑锡勇/任赫順/高成焕/李率求/韩成勇/申淡秀/白仁权/徐贤宇/车顺裴/许政度/柳淳哲/洪万彪/韩根燮/柳善英/..</li><li>片长：137分钟</li><li>影 片类型：剧情/历史</li><li>豆 瓣评分：9.1/10(from25,777users)</li><li>IMDB评分：7.9/10(from818users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是来自今年韩国大热的《出租车司机》。这个片名真的是太太太普通不过了，以至于我相信很多人都没有观看的欲望。不过这部改编自真实故事，主演是宋叔的电影，还是没有让我失望。我之前推荐过不少韩国的好电影，其中宋叔的《辩护人》、《杀人回忆》也是一等一的佳作。本片的历史背景是1980年光州事件，（《辩护人》的历史背景是1981年的釜林事件）。当初在看辩护人的时候就对光州事件有所提及。而也是那个时候我才对韩国的历史、政治、以及相关的电影所要传递的信息有所了解。</p><p>宋叔在辩护人里催人泪下的辩护，到《出租车司机》里，摇身一变成了让人又爱又心疼的出租车司机。他真的把一个生活在局外、社会底层的人的性格、神态、言语演活了。光州事件在韩国虽然早已解密，但是世人并不完全会了解、会体会。这部电影从一个小角度拍摄，让整件事件能够更让人印象深刻、让人更难以忘怀。韩国的很多好电影，都会对政府的一些作为做出自己的一番论述。本片也不例外，相信很多看完这部电影的人，就真的会觉得当今的社会真的是前人撒血挥泪而铸就的。</p><p>当然，我也一直在说，从韩国电影看中国社会。从他们的电影中我们能够窥探到很多我们社会里类似的东西。而韩国的电影敢于说真话，敢于拍真事。我也希望我们的祖国能够发展能够进步到哪一天，对于一些事情能够转变看法，能够开诚布公。我也不希望“他们有改变国家的电影，我们有改变电影的国家”这句话，一直存在。好电影，值得一看。</p><hr><h3 id="2017-09-24-WEEK176-赛德克·巴莱"><a href="#2017-09-24-WEEK176-赛德克·巴莱" class="headerlink" title="2017-09-24 WEEK176 赛德克·巴莱"></a>2017-09-24 WEEK176 赛德克·巴莱</h3><p>赛德克·巴莱——————————————賽德克·巴萊<br><img src="https://img.piegg.cn/week176.jpg?imageslim" alt="赛德克·巴莱" title="赛德克·巴莱"></p><!--more--><ul><li>导演：魏德圣</li><li>主演：林庆台/马志翔/安藤政信/河原萨布/徐诣帆/温岚/罗美玲/徐若瑄/游大庆/林源杰/..</li><li>片长：153分钟(中国大陆/国际版)</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：8.7/10(from93,115users)</li><li>IMDB评分：7.5/10(from5,773users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是一部来自台湾的电影——《赛德克·巴莱》。看这个名字就总觉得很像外国的名字。而实际上这个是台湾原住民的族名。这部电影讲述的历史应该是大多数人（包括我）并不知道的一段历史——马关条约签订后，在1930年10月，台湾的原住民对日本侵略者发起的反抗事件——雾社事件。</p><p>由于那段时间，台湾处于日本的统治之下，所以这段历史国人了解甚少。所以我也是看完电影之后特地去找了相关背景知识得以恶补。这部电影真的只能用两个字来形容——伟大。不光是历史本身伟大，也是因为导演拍的伟大。</p><p>这部电影有很多个版本，大陆公映的是删减过后的152分钟，而台湾上映的是上下两集《太阳旗》和《彩虹桥》，有4个多小时的内容。后面的这个版本讲述的故事更加完整而震撼。这部电影把整个雾社事件的来龙去脉讲述地非常清楚，对于原住民的生活、捕猎、习性等等的描述也是前所未有的。主演是赛德克族的后裔，此前并不是演员，但是却演绎了一个让人印象极其深刻的莫那鲁道。</p><p>原住民的反抗，其实并没有国家的概念，而是更纯粹的为了生存为了尊严为了祖灵。日本带去的“文明”，奴役不了自由的心。野蛮的骄傲，也许只是以卵击石，但是却足够分量，足够有力。这是一部史诗，这是一部很棒的电影，推荐一看。</p><hr><h3 id="2017-09-17-WEEK175-大卫·戈尔的一生"><a href="#2017-09-17-WEEK175-大卫·戈尔的一生" class="headerlink" title="2017-09-17 WEEK175 大卫·戈尔的一生"></a>2017-09-17 WEEK175 大卫·戈尔的一生</h3><p>大卫·戈尔的一生——————————————The Life of David Gale<br><img src="https://img.piegg.cn/week175.jpg?imageslim" alt="大卫·戈尔的一生" title="大卫·戈尔的一生"></p><!--more--><ul><li>导演：艾伦·帕克</li><li>主演：凯文·史派西/凯特·温丝莱特/劳拉·琳妮/加布里埃尔·曼/梅丽莎·麦卡西/罗娜·迈特拉/</li><li>片长：130 分钟</li><li>影 片类型：剧情/悬疑/犯罪</li><li>豆 瓣评分：8.7/10(from85,052users)</li><li>IMDB评分：7.6/10(from94,416users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是一部2003年的电影，来自美国的《大卫·戈尔的一生》。这是一部很震撼的电影。从一开始强烈的节奏就把观众带入了整个剧情中。片名说的是大卫的一生，而实际上并没有把大卫从小到大的一生都叙述了一遍，而是把他人生中最重要的部分摘取出来进行的叙述。</p><p>大卫一生致力于废除德州的死刑，并与一群志同道合的人为之奋斗。但是政府却并不领情。整部电影从大卫的叙述以及女记者态度的转变中，以及牛仔的全程贯穿，让我们得以一步步走入这个迷雾重重的事件。作为一部剧情片，它的表现也许不够好，三天的回忆不足以把一件大事说清楚。而作为一部悬疑、犯罪片，它的闪光点就不能忽视。以至于直到影片的最后，你觉得你可能猜出了结局，但是你肯定猜不到最后的最后。</p><p>很伟大。人为理想而奋斗，人因理想而伟大。好电影，值得一看。</p><hr><h3 id="2017-09-03-WEEK174-敦刻尔克"><a href="#2017-09-03-WEEK174-敦刻尔克" class="headerlink" title="2017-09-03 WEEK174 敦刻尔克"></a>2017-09-03 WEEK174 敦刻尔克</h3><p>敦刻尔克——————————————Dunkirk<br><img src="https://img.piegg.cn/week174.jpg?imageslim" alt="敦刻尔克" title="敦刻尔克"></p><!--more--><ul><li>导演：克里斯托弗·诺兰</li><li>主演：菲恩·怀特海德/汤姆·格林-卡尼/杰克·劳登/哈里·斯泰尔斯/阿纽林·巴纳德/汤姆·哈迪/马克·里朗斯/巴里·基奥干/基里安·墨菲/詹姆斯·达西/肯尼思·布拉纳/李·阿姆斯特朗/詹姆斯·布鲁尔/达米安·勃纳尔/布莱恩·威纳尔/哈利·理查森/艾略特·提特恩索/凯文·格思里/巴比·洛克伍德/米歇尔·贝尔/比利·豪尔/迈克尔·凯恩/约翰·诺兰/米兰达·诺兰/..</li><li>片长：107分钟</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：8.6/10(from180,232users)</li><li>IMDB评分：8.4/10(from204,636users)</li></ul><p>Hi，各位好久不见。这连续三周都是推荐当下上映最热的电影，让我有点愧疚。不过这几周的电影真的都相当不错。</p><p>以前也说过，我喜欢上看电影是从看战争电影开始的，启蒙电影是《拯救大兵瑞恩》。也是从那个时候开始对战争史感兴趣。诺兰拍《敦刻尔克》这部电影是为了填补空白——不过在观众大多都知道历史的情况下，是拍成一部电影还是拍成一部纪录片就很考验诺兰的功力了。很显然诺兰选择了前者。敦刻尔克大撤退的发生，很重要的一点是得归功于希特勒著名的禁止装甲部队再前进的命令。这个命令让龟缩在敦刻尔克的英法联军能够有喘息之机，跨过英吉利海峡撤回英国。</p><p>而诺兰并没有遵循一条时间线的叙事方式，甚至没有交待太多敦刻尔克大撤退发生前的故事。切入点直接就是敦刻尔克的海滩，成批的等待救援的部队，以及德国空军的空袭。海陆空三线，三个空间；一周、一天、一小时，三个时间线；诺兰将这3个时空有机地结合在了一起。零碎的故事最好看的就是交汇的部分。而诺兰在交汇的部分设置的情节、音乐与气氛可以说让人窒息。不从战争局外人的角度来描写敦刻尔克，而是从普通人的视角去看待这次撤退。这种视角也是非常独特的。没有了解过历史的或者只是知道皮毛的话也许会对这部电影产生一些偏见。但是真正了解了历史再去看待这部电影的话，那么将是一部上等的佳作。</p><hr><h3 id="2017-08-27-WEEK173-遇见你之前"><a href="#2017-08-27-WEEK173-遇见你之前" class="headerlink" title="2017-08-27 WEEK173 遇见你之前"></a>2017-08-27 WEEK173 遇见你之前</h3><p>遇见你之前——————————————Me Before You<br><img src="https://img.piegg.cn/week173.jpg?imageslim" alt="遇见你之前" title="遇见你之前"></p><!--more--><ul><li>导演：西娅·夏罗克</li><li>主演：艾米莉亚·克拉克/山姆·克拉弗林/珍妮·麦克蒂尔/查尔斯·丹斯/布兰登·柯伊尔/珍娜·科尔曼/马修·刘易斯/本·劳埃德-休斯/凡妮莎·柯比/斯蒂芬·皮科克/马修·约翰·摩尔利/汉娜·弗林/</li><li>片长：110分钟</li><li>影 片类型：剧情/爱情</li><li>豆 瓣评分：7.5/10(from90,085users)</li><li>IMDB评分：7.4/10(from124,258users)</li></ul><p>Hi，各位好久不见~借着本周一是七夕的“东风”，给大家推荐一部爱情电影——《遇见你之前》。龙妈在这部电影里的面部表情堪称一绝。而男主也是从头帅到尾。但是与一般的爱情电影不同的地方是，它不只是依靠主演的高颜值和一些夸张的情节来博得观众的眼球——相反，它依靠的两个主演的演技，以及循序渐进的情节+并没有落入俗套的结局征服了观众。</p><p>影片里塑造的男主其实是十分难能可贵的一种人。正因为他这种性格，才会让人对他肃然起敬。在遇见女主之前，他的生活是多么的枯燥无味。而遇见了女主之后，他开始渐渐能够感受到生活的美好而去享受这种生活——不过这也从另外一个方面刺激了他脆弱的神经。</p><p>我们当然想着活下去是最好的结局，毕竟活着就有机会，活着就有希望。但是在某些情况下，这种绝对的理念也许并不适用于全部人。理解与尊重，互相扶持与关爱，则已是大爱。好的电影，值得一看。</p><hr><h3 id="2017-08-20-WEEK172-二十二"><a href="#2017-08-20-WEEK172-二十二" class="headerlink" title="2017-08-20 WEEK172 二十二"></a>2017-08-20 WEEK172 二十二</h3><p>二十二——————————————二十二<br><img src="https://img.piegg.cn/week172.jpg?imageslim" alt="二十二" title="二十二"></p><!--more--><ul><li>导演：郭柯</li><li>片长：99分钟(公映版)</li><li>影 片类型：纪录片</li><li>豆 瓣评分：8.9/10(from61,759users)</li><li>IMDB评分：8.5/10(from74users)</li></ul><p>Hi各位，好久不见。本周给大家推荐的，是当下口碑最高、呼声最大的一部纪录片《二十二》。不为别的，就为着这片名的数字如今只剩下八，而且将会逐渐更少。日本侵华期间对二十万中国妇女的蹂躏，兽行是不可抹去的历史。随着时间越来越长，当年受害的老人们也在逐渐老去。有人说，这部片揭露老人的伤疤，十恶不赦。然而，看完整部电影，你才能感受到导演的拍摄，很克制，但是很有感染力。</p><p>要在90多分钟内，诉说22个老人的故事，真的太难。但是从影片中我们真的能够感受到，这些老奶奶的生活态度普遍是乐观而开朗的。在不去回想那段历史的时候，也能看到她们嘴上最淳朴的笑容。</p><p>影片里还有很多其他帮助过、照顾过这些老人的社会人士，他们基本上都是发自内心的去做这些事——看了也是相当感动。</p><p>如果按照一部常规电影的视角来看这部纪录片，它没有什么情节，它没有什么高潮，它甚至“支离破碎”。但是，这部电影用最克制的力度，最朴实的角度，最尊敬的态度去给世人们呈现当前这些被称为慰安妇的受害者老人们的境况。这也是我第一部，全场安静的出奇，看到影片结尾，看完众筹名单，直到最后电影完全谢幕，观众才缓缓离场的电影。好电影，一定要去看。</p><hr><h3 id="2017-08-13-WEEK171-战狼2"><a href="#2017-08-13-WEEK171-战狼2" class="headerlink" title="2017-08-13 WEEK171 战狼2"></a>2017-08-13 WEEK171 战狼2</h3><p>战狼2——————————————战狼2<br><img src="https://img.piegg.cn/week171.jpg?imageslim" alt="战狼2" title="战狼2"></p><!--more--><ul><li>导演：吴京</li><li>主演：吴京/弗兰克·格里罗/吴刚/张翰/卢靖姗/丁海峰/淳于珊珊/余男/于谦/石兆琪/海蒂·玛尼梅可/奥列格·亚历山大罗维奇/阿隆·汤尼/泰勒·哈里斯/勃小龙/</li><li>片长：123分钟</li><li>影 片类型：动作/</li><li>豆 瓣评分：7.5/10(from300,880users)</li><li>IMDB评分：7.0/10(from1,262users)</li></ul><p>Hello各位，好久不见！这段时间事情比较多，所以暂时是两周一更。不过从下周开始就会恢复正常啦。</p><p>《战狼2》刚上映没多久我就去看啦。相信很多朋友也已经被这部国民热捧的现象级电影所吸引，去电影院看过啦。其实这篇推荐本应该两周前推出的，那个时候恰逢《战狼2》刚上映。</p><p>不过不管怎么说，不管你们看过没有我都还是要推荐一下这部电影——毕竟中国电影人好久没有像吴京这样拼的了。主旋律电影，去年上映的《湄公河行动》也收获了很多的赞誉——相比之下，相同点有很多：场景大、特效足、演员演技实力派、故事情节紧凑吸引人。战狼2也是一样，只不过它并不像湄公河行动一样是有事实依据，而是摘取一部分现实（中国11年撤侨事件）+自己改编合成的。中国的编剧在大部分情况下始终是比较薄弱的一环，战狼2其实也有一些薄弱的环节——但是它最成功的地方，在于塑造了一个中国式的孤胆英雄——这个在欧美大片中很容易看到的类似角色。吴京将这个中国式的孤单英雄演活了，演深刻了。从而让我们也知道了，原来国人的电影里也可以拥有这样酷、这样帅的英雄。</p><p>吴京更吸粉的地方在于他对于用人、用经费的诠释，让更多的观众路转粉，从而水涨船高地推动了这部电影高到惊人的票房。这部电影真的值得进电影院看，足够热血，足够好。</p><hr><h3 id="2017-07-16-WEEK170-月球"><a href="#2017-07-16-WEEK170-月球" class="headerlink" title="2017-07-16 WEEK170 月球"></a>2017-07-16 WEEK170 月球</h3><p>月球——————————————Moon<br><img src="https://img.piegg.cn/week170.jpg?imageslim" alt="月球" title="月球"></p><!--more--><ul><li>导演：邓肯·琼斯</li><li>主演：山姆·洛克威尔/凯文·史派西/多米妮克·麦克艾丽戈特/卡雅·斯考达里奥/本尼迪克特·王/马特·贝里/马尔科姆·斯图尔特/罗宾·查克/</li><li>片长：97 分钟</li><li>影 片类型：剧情/科幻/悬疑</li><li>豆 瓣评分：8.5/10(from133,219users)</li><li>IMDB评分：7.9/10(from279,893users)</li></ul><p>Hi，各位，好久不见，这段时间都是两周一更很抱歉，估计还要持续一次。下个月的时候就正常啦。<br>本周是一周一部好电影推荐的第170周。给大家推荐的事来自英国的《Moon》。名字真的非常简单。不过作为一部科幻电影，真的非常不简单。</p><p>世界观设定成，地球的清洁资源70%来自于月球上开采的清洁能源氦-3。不过令人诧异的是，在月球上负责开采、运送这种清洁能源的只有一个人，他的合同是3年。3年到期就可以回地球了。我们在影片中能看到月球生活的孤独与苦中作乐。</p><p>不过作为一部科幻片，前半段的平白无故毕竟让人有所乏味。于是这个时候本片把科幻的元素发扬了光大，让人不禁拍案叫绝。同时随着故事的推进，一桩丑陋的交易浮现在观众眼前。一点点让人对片中的男主感到揪心。而男主在剧中一人分饰两角的演技也真的是超棒。</p><p>美中不足的地方在于一些情节的转换过于戏剧化，而且有所欠妥。但是作为一部科幻电影，在结尾抛出的字眼，拷问着我们——为了自身利益是否就应该抛弃人性和良心呢？好电影，值得一看。</p><hr><h3 id="2017-07-09-WEEK169-夏日大作战"><a href="#2017-07-09-WEEK169-夏日大作战" class="headerlink" title="2017-07-09 WEEK169 夏日大作战"></a>2017-07-09 WEEK169 夏日大作战</h3><p>夏日大作战——————————————サマーウォーズ<br><img src="https://img.piegg.cn/week169.jpg?imageslim" alt="夏日大作战" title="夏日大作战"></p><!--more--><ul><li>导演：细田守</li><li>主演：神木隆之介/谷村美月/樱庭奈奈美/斋藤步/横川贵大/信泽三惠子/玉川纱己子/永井一郎/小林隆/清水优/田中要次/入山法子/板仓光隆/仲里依纱/富司纯子</li><li>片长：114分钟</li><li>影 片类型：喜剧/科幻/动画/冒险</li><li>豆 瓣评分：8.6/10(from100,022users)</li><li>IMDB评分：7.6/10(from19,018users)</li></ul><p>Hi，各位，好久不见，这段时间都是两周一更很抱歉，估计还要持续一次。下个月的时候就正常啦。<br>本周给大家推荐的一部轻松愉快的动画电影——《夏日大作战》。听起来就很欢快。</p><p>这是一个终有可能发生在我们身上的故事——随着计算机、网络、深度学习等等技术的不断发展，最终我们将会有一个独立于现实社会的虚拟社会。而在虚拟社会里发生的事却也最终会影响到现实社会。</p><p>其实这个故事在09年电影上映的时候，已经初见苗头。不过如今很多凤毛麟角已经出现了。虚拟货币的支付正在逐渐成为主流支付方式。越来越多的人在虚拟的游戏、社交中找到了在现实社会中找不到的成就感。细田守把一个可以拍成一部很好的真人电影搬到了动画世界中，但是依然处理的很好。亲情、友情、爱情的交汇；老一辈、年轻一辈处事的不同；虚拟世界的魅力与现实世界的美丽。一部动画电影的最后能够留下的是感动和温馨，其实已经是很大的成功。</p><p>茶余饭后不如抽个空看看，好电影，值得一看。</p><hr><h3 id="2017-07-02-WEEK168-黄海"><a href="#2017-07-02-WEEK168-黄海" class="headerlink" title="2017-07-02 WEEK168 黄海"></a>2017-07-02 WEEK168 黄海</h3><p>黄海——————————————황해<br><img src="https://img.piegg.cn/week168.jpg?imageslim" alt="黄海" title="黄海"></p><!--more--><ul><li>导演：罗泓轸</li><li>主演：河正宇/金允石/郑满植/李哲民 /李艾</li><li>片长：157分钟(韩国)</li><li>影 片类型：剧情/动作/犯罪</li><li>豆 瓣评分：8.4/10(from74,665users)</li><li>IMDB评分：7.4/10(from13,372users)</li></ul><p>Hi，各位，好久不见，由于这两周涉及毕业和搬迁事宜拖更了这么久实在抱歉。<br>本周给大家推荐的是一部来自韩国的电影《黄海》。这部电影里的中国元素不少，主要一个原因是主角河正宇是饰演一个中国朝鲜族的人。这部电影里，汉字、汉语在电影里也是随处可见。</p><p>明明打麻将经常输还是想靠打麻将赚点钱，明明可以好好工作赚点钱养家糊口却偏偏铤而走险。这部电影讲述了一个走投无路，除了执念什么都已经可以输得起的人，被逼入绝境从而铤而走险的故事。血腥、转折、诡计、绝望。河正宇在这部电影里炸裂的演技真的让人感到一丝凉意。</p><p>这部电影很多场景能够触动你的泪腺。我印象最深的就是久南扯下袜子绝望地包扎被流弹打中的手臂那令人心碎的哭泣和面容。但愿所有付出自己血汗的人们都能被世界宽容以待，但愿他们能够拥有自己的路，尊严地走下去。结尾有彩蛋，好的电影，值得一看。</p><hr><h3 id="2017-06-25-WEEK167-为你取名的那一天"><a href="#2017-06-25-WEEK167-为你取名的那一天" class="headerlink" title="2017-06-25 WEEK167 为你取名的那一天"></a>2017-06-25 WEEK167 为你取名的那一天</h3><p>为你取名的那一天——————————————犬に名前をつける日<br><img src="https://img.piegg.cn/week167.jpg?imageslim" alt="为你取名的那一天" title="为你取名的那一天"></p><!--more--><ul><li>导演：山田茜</li><li>主演：小林聪美/上川隆也/青山美乡</li><li>片长：107分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：8.4/10(from2,643users)</li><li>IMDB评分：7.0/10(from21users)</li></ul><p>Hi，各位，好久不见，由于这两周涉及毕业和搬迁事宜拖更了这么久实在抱歉。<br>本周给大家推荐的是一部来自日本的半纪录片式的电影《为你取名的那一天》。这部电影说实话，纪录片的感觉更重一些。它的魅力在于真实而感动。</p><p>这是一部讲述人和狗之间的故事的电影。它的制作跨了好多年，从311大地震到15年上映。导演是个爱狗的人士，在爱犬死去之后决定学习与狗有关的知识，并拍摄一部和狗有关的电影。日本的法律规定流浪狗要被收入专门的机构，一旦在一定期限内没有人认养，那么就处以安乐死。</p><p>电影里真实地记录了为了这些流浪狗的生存而奋斗的一群人，他们有的甚至为了它们放弃了很多东西，把救助、照顾它们视为一生的事业。还有很多鲜为人知的故事，也只有通过电影本身，你才能够感受到，很多时候我们养宠物，并不是做好了陪伴它们一生的决定。而这样是否对它们的生命来说是一种不负责任呢？既然责任这么重大，那么在认养宠物之前还是要好好考虑周到。这部电影的节奏比较慢，但是真实而感人，推荐一看。</p><hr><h3 id="2017-06-17-WEEK166-布达佩斯大饭店"><a href="#2017-06-17-WEEK166-布达佩斯大饭店" class="headerlink" title="2017-06-17 WEEK166 布达佩斯大饭店"></a>2017-06-17 WEEK166 布达佩斯大饭店</h3><p>布达佩斯大饭店——————————————The Grand Budapest Hotel<br><img src="https://img.piegg.cn/week166.jpg?imageslim" alt="布达佩斯大饭店" title="布达佩斯大饭店"></p><!--more--><ul><li>导演：韦斯·安德森</li><li>主演：拉尔夫·费因斯/托尼·雷沃罗利/艾德里安·布洛迪/威廉·达福/裘德·洛/爱德华·诺顿/西尔莎·罗南/蒂尔达·斯文顿/比尔·默瑞/蕾雅·赛杜/欧文·威尔逊/詹森·舒瓦兹曼/马修·阿马立克/F·默里·亚伯拉罕/汤姆·威尔金森/杰夫·高布伦/哈威·凯特尔</li><li>片长：100分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.7/10(from286,815users)</li><li>IMDB评分：8.1/10(from534,539users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是一部喜剧《布达佩斯大饭店》。喜剧给大家推荐的比较少，但是这部喜剧真的是吸引我从头看到尾完全无尿点。</p><p>这部电影第一个很显著的风格就是画面大小，只要是回顾的片段都是4:3的比例，而回忆的片段则是16:9（看完电影就知道这里的回顾和回忆的区别了）。看这部电影仿佛在看卡通片，色彩鲜艳、人物生动、剧情幽默而紧凑，动作夸张而搞笑。仿佛在看一部老电影，但是却别有一番韵味。全片以布达佩斯大饭店的前世今生作为主线，写了两代饭店经理的有趣的经历。一个饭店的兴衰，反映的是时代的更迭，历史的交替。影片的一些情节，偷窃、追杀、逃跑、越狱、通关等情节真的让人忍俊不禁，又感慨万分。</p><p>从古斯塔夫先生的身上你能看到一个真正的绅士，从Zero身上你能看到一个真正的忠实的门徒。而从整个布达佩斯大饭店，你可以看到旧时代的欧洲和新时代欧洲的变化。导演倾注的黑色幽默、思考都是值得你去观看的理由。好的电影，值得一看。</p><hr><h3 id="2017-06-11-WEEK165-一次别离"><a href="#2017-06-11-WEEK165-一次别离" class="headerlink" title="2017-06-11 WEEK165 一次别离"></a>2017-06-11 WEEK165 一次别离</h3><p>一次别离——————————————جدایی نادر از سیمین<br><img src="https://img.piegg.cn/week165.jpg?imageslim" alt="一次别离" title="一次别离"></p><!--more--><ul><li>导演：阿斯哈·法哈蒂</li><li>主演：佩曼·莫阿迪/蕾拉·哈塔米/萨瑞·巴亚特/沙哈布·侯赛尼/萨日娜·法哈蒂/梅里拉·扎雷伊/阿里-阿萨哈·萨哈巴齐/巴巴克·卡里米/吉米娅·侯赛伊妮/希尔·亚齐丹巴克什/萨哈巴努·佐哈多</li><li>片长：123分钟</li><li>影 片类型：剧情/家庭</li><li>豆 瓣评分：8.7/10(from123,108users)</li><li>IMDB评分：8.4/10(from166,080users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是来自伊朗的《一次别离》。这部电影从侧面反映了伊朗的社会矛盾，而情节的生活化、戏剧化以及转折、结尾的点睛之笔都是这部电影的闪光之处。</p><p>从一部电影折射国家，通常这种话我会在一些韩国的电影里说。不过对于这部电影，这种话我也想说。两条线的交错，信仰和道德的冲突，诚实与爱的谎言的相悖，资产阶级和普通老百姓的相对。两边都有自己的苦衷，两边都有自己的坚持。出于爱，出于自己的信仰，坚持不肯放松，这样才让矛盾放大。其实我们没有办法去批判任何一方的行为，不管是护工和雇主的矛盾，还是父亲、女儿和母亲的矛盾，站在任何一方的角度，都是事出有因，都是有合理的考虑。</p><p>但是这样的矛盾才是最让人叹惋和揪心的。女儿为了父亲的撒谎，为了撒谎而流的泪；母亲为了女儿的奔走，争吵，为了父亲抵押房产，协调；父亲为了爷爷操碎了心；护工为了能养家糊口带着女儿远赴雇主家里护工，做着有可能违背信仰的工作；护工的丈夫为了争取公道不惜把自己逼到了底线；这一切，非常真实，而且动人。</p><p>伊朗的电影，比如之前推荐过的《推销员》也是相当不错。虽然不及印度的电影来得些许欢快，但是哪怕是一部手持拍摄的电影，也是别有一番韵味。好电影，值得一看。</p><hr><h3 id="2017-06-04-WEEK164-假如猫从世界上消失了"><a href="#2017-06-04-WEEK164-假如猫从世界上消失了" class="headerlink" title="2017-06-04 WEEK164 假如猫从世界上消失了"></a>2017-06-04 WEEK164 假如猫从世界上消失了</h3><p>假如猫从世界上消失了——————————————世界から猫が消えたなら<br><img src="https://img.piegg.cn/week164.jpg?imageslim" alt="假如猫从世界上消失了" title="假如猫从世界上消失了"></p><!--more--><ul><li>导演：永井聪</li><li>主演：佐藤健/宫崎葵/滨田岳/奥野瑛太/石井杏奈/奥田瑛二/原田美枝子</li><li>片长：103分钟</li><li>影 片类型：剧情/奇幻</li><li>豆 瓣评分：7.2/10(from14,430users)</li><li>IMDB评分：7.1/10(from1,031users)</li></ul><p>Hi，各位，好久不见，这周生病了没来得及更新，十分抱歉！</p><p>本周给大家推荐的是一部来自日本的《加入猫从世界上消失了》。这部标榜着“奇幻”和“剧情”，看似一部“狗血”的电影，实际上却把奇幻讲得很贴心，把剧情讲得很动人。这是一部讲述生命的意义，讲述爱情、友情、亲情的电影。如果一定要你选择某个东西消失于世界，从未诞生，从未有过，你会选择什么？这个世界到底会怎么样。</p><p>还有什么比生命更重要的东西么？如果活着的每天，你没有了友情，没有了爱情，没有了亲情，没有了周遭熟悉的一切，恐怕活着也是一种受罪吧？这部电影在描述的时候，不断抛出的一个观点便是，珍惜当下，珍惜你爱以及爱你的人吧。也许我们都有着或多或少的坎坷，不过还是有很多值得去体会去感受的美好，生活依然可以愉快的继续。直到面对死亡的时候，我们能够无悔地说我们来过这世上。假如猫从世界上消失了，有多少人会记得；假如你从世界上消失了，又有多少人会记得？风格清新的一部电影，值得一看。</p><hr><h3 id="2017-05-27-WEEK163-沃伦"><a href="#2017-05-27-WEEK163-沃伦" class="headerlink" title="2017-05-27 WEEK163 沃伦"></a>2017-05-27 WEEK163 沃伦</h3><p>沃伦——————————————Wołyń<br><img src="https://img.piegg.cn/week163.jpg?imageslim" alt="沃伦" title="沃伦"></p><!--more--><ul><li>导演：沃吉西奇·斯玛佐斯基</li><li>主演：米卡丽娜·拉巴克斯/阿尔卡迪乌什·雅库比克/沃西尔·沃西尔利克/阿德里安·扎仁巴/伊莎贝拉·库纳/杰克·布雷西亚克/玛丽亚·索博辛斯卡/奥列桑德·兹巴拉斯基/佛罗德米尔·普罗塔西尤克/奥列桑德·彻西洛夫/莱赫·德布里克/罗曼·斯勾勒斯基/扎卡尔杰斯斯·马斯齐因斯基/米哈尔·加多姆斯基/加布里埃拉·马斯卡拉/托马斯兹·萨普里克</li><li>片长：150分钟</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：8.3/10(from3,341users)</li></ul><p>Hi，各位，好久不见，最近逢着放假一下子没抽出时间写推荐，真是抱歉~本期给大家推荐的是一部来自乌克兰、波兰的电影《沃伦》。又是一段鲜为人知的历史。</p><p>沃伦地区在二战前是波兰和乌克兰交界地带，隶属波兰管辖。但是波兰政府压迫这个地区的乌克兰人——乌克兰人和波兰人积怨已久，虽然可能大家生活在一起，是邻居是“朋友”。一切都在二战的到来之后改变了。</p><p>片头的一段话很震撼人心，“这里被屠杀了两次”。这里被屠杀了两次，是侵略者所为么？不是的，下手的，正是这片土地上的两个民族。其实还有一个民族——犹太人，不过他们就是被屠杀的那族。纳粹指示下犹太人被屠杀了一次；乌克兰起义军UPA屠杀了一遍波兰人。谁也想不到平日里生活在一起的邻居，下一秒就是拿起屠刀的凶手。</p><p>影片把那段历史演绎的太真实以致于你会觉得自己在看一部恐怖片——是的，有的时候恐惧是来自于真实的。主人公的遭遇，真的在很多时候你会感觉绝望，你会无助到流泪。动人以情，隐忍深思。好电影，值得一看。</p><hr><h3 id="2017-05-20-WEEK162-摔跤吧爸爸"><a href="#2017-05-20-WEEK162-摔跤吧爸爸" class="headerlink" title="2017-05-20 WEEK162 摔跤吧爸爸"></a>2017-05-20 WEEK162 摔跤吧爸爸</h3><p>摔跤吧爸爸——————————————Dangal<br><img src="https://img.piegg.cn/week162.jpg?imageslim" alt="摔跤吧爸爸" title="摔跤吧爸爸"></p><!--more--><ul><li>导演：涅提·蒂瓦里</li><li>主演：阿米尔·汗/法缇玛·萨那·纱卡/桑亚·玛荷塔/阿帕尔夏克提·库拉那/沙克希·坦沃/泽伊拉·沃西姆/苏哈妮·巴特纳格尔/里特维克·萨霍里/吉里什·库卡尼</li><li>片长：161分钟(印度)</li><li>影 片类型：剧情/传记/运动/</li><li>豆 瓣评分：9.2/10(from197,877users)</li><li>IMDB评分：8.8/10(from48,159users)</li></ul><p>Hi，各位，好久不见。本期给大家推荐的电影相必大家早已有所耳闻。不过作为豆瓣9.2、IMDB8.8的高分电影，我觉得还是有必要推荐给没有看过这部电影的朋友们。</p><p>这部电影最大的看点莫过于主演阿米尔·汗演绎的从年轻人-&gt;老年人的父亲形象。而且，为了配合影片拍摄，他先增肥增重，再花4个月减肥瘦下去；影片里出演摔跤比赛仅一分钟的成年二姐的演员，也为此接受了9个月的专业训练——不得不说，为了这部电影的拍摄，演员们，都是付出和牺牲了很多。这种敬业的精神也由衷让人敬佩。</p><p>影片的剧情相对于印度来说肯定是爱国主旋律电影——为国争光嘛。不过这部电影改编自印度的真实故事，却也让人为之惊叹。结合上印度的男权社会的大背景，这部电影的诞生以及评分如此之高也不足为虑了。我最欣赏影片里的一个场景就是，妈妈问爸爸，“她们这样以后有谁敢娶她们”。而爸爸的答曰：“她们以后会非常优秀，到时候就是她们来选择自己的另一半了。”这种思想在印度包办女儿婚姻的大背景下，是多么难能可贵。</p><p>总之，这部电影结合了亲情、爱国、热血等元素，某些场景也完全能够打动你的泪腺。这样一部好的电影，值得一看。</p><hr><h3 id="2017-05-15-WEEK161-龙虾"><a href="#2017-05-15-WEEK161-龙虾" class="headerlink" title="2017-05-15 WEEK161 龙虾"></a>2017-05-15 WEEK161 龙虾</h3><p>龙虾img——————————————The Lobster<br><img src="https://img.piegg.cn/week161.jpg?imageslim" alt="龙虾" title="龙虾"></p><!--more--><ul><li>导演：欧格斯·兰斯莫斯</li><li>主演：科林·法瑞尔/蕾切尔·薇兹/约翰·C·赖利/蕾雅·赛杜/奥利维娅·科尔曼/本·卫肖/亚里安妮·拉贝德/罗杰·阿什顿-格里菲斯/迈克尔·史麦利/杰西卡·巴登/阿戈利基·帕朴利亚</li><li>片长：118分钟</li><li>影 片类型：剧情/喜剧/爱情/科幻</li><li>豆 瓣评分：7.5/10(from55,064users)</li><li>IMDB评分：7.1/10(from120,758users)</li></ul><p>Hi，各位好久不见。抱歉这次的更新拖了几天。本周给大家推荐的是一部来自欧洲多国制片的电影《龙虾》。说实话，这部电影的分类是爱情、科幻的时候我觉得特别有意思。主要是这段时间也确实想推一部科幻的电影，结果正好遇到了这部电影。</p><p>但是与《星际穿越》的硬科幻不同的是，本片的科幻元素并不是所谓的硬科幻，相对的可以算是软科幻吧。不过在本片，这个元素虽然明地里出现地不多，但是实际上暗地里把整个故事背景都固定了。这个世界是个婚恋严格受到控制的世界——真正的单身者有罪的世界。看到这里肯定很多单身的朋友表示不服！哈哈。本片这种神奇的设定，还伴随着如果在酒店里的45天内没有脱单将会变成一种动物。而片名龙虾，便是男主如果没有在45天内脱单想要变成的动物。</p><p>全片充满着压抑的黑色幽默。极力催促脱单的酒店和视单身者为“天堂”的野外聚集地，其实都是两个极端。真正的爱情或者婚姻都不是通过这种方式来获得的。在一个人人都抱着脱单的念头的环境里也不一定能找到伴侣，而在一个每个人都自觉是单身者的地方却也可能产生爱情。矛盾与冲突，戏剧与暗讽。好电影，值得一看。</p><hr><h3 id="2017-05-07-WEEK160-卑劣的街头"><a href="#2017-05-07-WEEK160-卑劣的街头" class="headerlink" title="2017-05-07 WEEK160 卑劣的街头"></a>2017-05-07 WEEK160 卑劣的街头</h3><p>卑劣的街头——————————————비열한 거리<br><img src="https://img.piegg.cn/week160.jpg?imageslim" alt="卑劣的街头" title="卑劣的街头"></p><!--more--><ul><li>导演：庾河</li><li>主演：赵寅成/李宝英/千虎珍/南宫珉</li><li>片长：141 分钟(韩国)</li><li>影 片类型：动作/惊悚/犯罪</li><li>豆 瓣评分：7.8/10(from35,384users)</li><li>IMDB评分：7.4/10(from5,987users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是来自韩国的《卑劣的街头》。这是一部讲述韩国黑帮的电影。但是又和纯粹的黑帮斗争，打打杀杀不同的是，它更加精致。</p><p>以主人公炳斗的视角，去感受他所认为的黑帮。“我这一辈子都不后悔加入黑帮。”他如是说。但是在重新遇见了喜欢了多年的女孩后，他的内心开始发生转变。“如果你愿意，我可以退出黑帮。”他的存在，并不是真正意义上的黑帮人。他讲求“一家人”，他讲求“要有黑帮精神，不然就是流氓”。他对于自己的朋友还是有一些怜悯，对于自己亲人更是刀子嘴豆腐心。</p><p>但是黑帮却不允许存在这种人。背叛与被背叛，爱与被爱，杀与被杀。所有的这一切，其实不过都是利益驱使。炳斗最终没能实现他的梦想，其实是他不是纯粹的黑帮，他的黑帮精神也不纯粹。但是他却更像一个人，一个有血有肉的人。本片的叙事结构也很奇特，在电影中拍电影，也给这部电影锦上添花了不少。好的电影，值得一看。</p><hr><h3 id="2017-05-01-WEEK159-K歌情人"><a href="#2017-05-01-WEEK159-K歌情人" class="headerlink" title="2017-05-01 WEEK159 K歌情人"></a>2017-05-01 WEEK159 K歌情人</h3><p>K歌情人——————————————Music and Lyrics<br><img src="https://img.piegg.cn/week159.jpg?imageslim" alt="K歌情人" title="K歌情人"></p><!--more--><ul><li>导演：马克·劳伦斯</li><li>主演：休·格兰特/德鲁·巴里摩尔/斯科特·波特/布拉德·加内特/海莉·贝内特</li><li>片长：96 分钟(美国)</li><li>影 片类型：喜剧/爱情/音乐</li><li>豆 瓣评分：7.5/10(from62,988users)</li><li>IMDB评分：6.5/10(from84,821users)</li></ul><p>Hi，各位，好久不见~五一假期不知各位去哪玩了呢？本周给大家推荐的是一部小清新的电影《K歌情人》，然而我更喜欢的译名是《词曲传情》233。以前我也推荐过主演休·格兰特的另一部跟爱情有关的电影《诺丁山》，同样也是简简单单的爱情，但是都有别样的味道。</p><p>这部电影由音乐起头，由音乐结束。短短1个半小时，浓缩了爱情的相识、爱恋、冲突、和好等一切能在爱情里找到的元素。你可能会说，哇这个好俗啊，大家不都是这个套路么。过气歌手+外行兼职作家，组合的词+曲却是本片中最大的亮点。可能辞藻不是多丰富、曲调不是多动人，但是1+1&gt;2的时候，却使得整首歌恰到好处地动人。爱情也是如此，两个外人看来并不是那么完美的人，但是结合在一起就是完美的爱情。一首歌有抑扬顿挫，爱情也会有甜蜜与挫折。关键是最后如何完美收尾，如何让余音更好地缭绕接下去的路。</p><p>本片的插曲《Way Back Into Love》好听！好电影+好音乐，值得一看~</p><hr><h3 id="2017-04-24-WEEK158-杰出公民"><a href="#2017-04-24-WEEK158-杰出公民" class="headerlink" title="2017-04-24 WEEK158 杰出公民"></a>2017-04-24 WEEK158 杰出公民</h3><p>杰出公民——————————————El Ciudadano Ilustre<br><img src="https://img.piegg.cn/week158.jpg?imageslim" alt="杰出公民" title="杰出公民"></p><!--more--><ul><li>导演：加斯顿·杜帕拉特马里亚诺·寇恩</li><li>主演：奥斯卡·马丁内兹/达迪·布列瓦/安德丽娅·弗里杰里奥/诺拉·纳瓦斯/曼努埃尔·维森特/马塞洛·丹德烈亚/贝伦·沙瓦纳/古斯塔沃·加尔松/朱利安·拉基尔·泰拉里尼/艾玛·里维拉/尼古拉斯·德·特蕾西/丹尼尔·卡尔吉曼/亚历克西斯·洛佩兹·科斯塔/莱昂纳多·穆里亚/佩德罗·罗斯</li><li>片长：118分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.6/10(from5,818users)</li><li>IMDB评分：7.5/10(from1,932users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的是一部来自阿根廷和西班牙的电影，《杰出公民》。这是一部很具有现实意义的讽刺电影。</p><p>影片很有意思，采用章节来推进剧情。每一个章节承前启后，无缝衔接。也许没有它们，对整部电影也没有影响。但是有了它们之后，你可以看到电影的阶段以及这部电影最核心的部分——虚实结合。到底有多少情节是真实而有多少情节是虚构，这些都只能交给观众去咀嚼。</p><p>没有对比就没有伤害。村民的愚昧与作家的自大；村民的“不自由”和作家的“自由”；年轻时伙伴的“幸福的”一家和作家孤身一人至今等等的对比。当我们把村民和作家作为本片的两大部分区别对待的时候，你会发现这个小镇和作家结下的渊源真是数不清道不尽。</p><p>作家说的一句话我特别喜欢：“真相并不存在，只有解构和诠释。”这部电影也是一样，带着思辨去看它，你能看出很多东西。好电影值得一看。</p><hr><h3 id="2017-04-17-WEEK157-百万美元宝贝"><a href="#2017-04-17-WEEK157-百万美元宝贝" class="headerlink" title="2017-04-17 WEEK157 百万美元宝贝"></a>2017-04-17 WEEK157 百万美元宝贝</h3><p>百万美元宝贝——————————————Million Dollar Baby<br><img src="https://img.piegg.cn/week157.jpg?imageslim" alt="百万美元宝贝" title="百万美元宝贝"></p><!--more--><ul><li>导演：克林特·伊斯特伍德</li><li>主演：克林特·伊斯特伍德/希拉里·斯万克/摩根·弗里曼/杰伊·巴鲁切尔/麦克·柯尔特/露西娅 瑞科尔/布莱恩·F·奥博恩/安东尼·麦凯/玛格·马丁戴尔/瑞琪·琳德赫姆/迈克尔·佩纳/本尼托·马丁内斯/Bruce MacVittie/David Powledge/乔·达安格里奥</li><li>片长：132 分钟</li><li>影 片类型：剧情/运动</li><li>豆 瓣评分：8.5/10(from91,541users)</li><li>IMDB评分：8.1/10(from512,384users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的电影来自关注公众号的小伙伴的推荐。感谢推荐~这部电影真的很特别也真的很感动。</p><p>其实一开始看到这个名字的时候我还以为是部喜剧电影。但是直到简单看了简介，并且安静看完整部电影之后我才发现跟喜剧一点边的不沾。有人说这部是一部没有讲好的鸡汤电影——因为它的结局并不是很鸡汤。但是整天沉浸在鸡汤文里的人们，整天被各种励志各种成功文笼罩的我们（包括我），也许看过这部电影才会被拍醒吧。它讲的不是怎么去赢，它告诉了我们如何失败。影片的三个主要人物都是老戏骨，演绎的角色真是入木三分。没有华丽的剪辑，没有什么伏笔，一切就是按照时间一点点往前推进，但是一点点敲击你内心的软弱之处。</p><p>看到豆瓣的一些影评，深深引起了我的共鸣。也许你并不喜欢拳击这项运动，但是你无法阻止喜欢这项运动的人们。其实借这个有点暴力有点血腥的运动，也在向我们展示着，哪怕你胜利了也是会带着伤痛。其实生命从诞生开始就注定要走向死亡。但是这无法阻止你成为一个英雄。豆瓣影评里有一句话写得特别好：“如果她没输，这部电影就是一部普通的好莱坞美国梦。她输了，电影就赢了。”好电影，值得一看。</p><hr><h3 id="2017-04-09-WEEK156-悲惨世界"><a href="#2017-04-09-WEEK156-悲惨世界" class="headerlink" title="2017-04-09 WEEK156 悲惨世界"></a>2017-04-09 WEEK156 悲惨世界</h3><p>悲惨世界——————————————Les Misérables<br><img src="https://img.piegg.cn/week156.jpg?imageslim" alt="悲惨世界" title="悲惨世界"></p><!--more--><ul><li>导演：汤姆·霍珀</li><li>主演：休·杰克曼/罗素·克劳/安妮·海瑟薇/阿曼达·塞弗里德/埃迪·雷德梅恩/海伦娜·伯翰·卡特/萨莎·拜伦·科恩/萨曼莎·巴克斯/艾伦·特维特/康姆·威尔金森/伊莎贝尔·艾伦/丹尼尔·赫特斯通</li><li>片长：157分钟</li><li>影 片类型：剧情/爱情/音乐</li><li>豆 瓣评分：8.5/10(from201,904users)</li><li>IMDB评分：7.6/10(from255,650users)</li></ul><p>Hi，各位，好久不见~本周给大家推荐的电影是一部改编自雨果经典名著的《悲惨世界》。这部电影之前也有着非常出色的同名音乐剧。而改变成电影后，最大的亮点就是，几乎所有的台词都是唱出来的——动听也动人。看这部电影如同看一部多镜头音乐剧。</p><p>故事本身就是一个感人至深的故事。如果看过原著自不必说。没看过原著的，看完这部电影，也能领略到雨果这部巨著的震撼。不同的人物不同的遭遇不同的命运，奸邪、正义、争议之事、之人能让你感慨万分。本片的演员基本都是老戏骨，所以很多唱出来的台词，真的特别感人，有些场景甚至可以打动你的泪腺。剧情时间跨度之大、内容丰富之多、演员表演功力之足，音乐旋律动人之深都是你应该看看它的原因。好电影，值得一看。</p><hr><h3 id="2017-04-02-WEEK155-斯隆女士"><a href="#2017-04-02-WEEK155-斯隆女士" class="headerlink" title="2017-04-02 WEEK155 斯隆女士"></a>2017-04-02 WEEK155 斯隆女士</h3><p>斯隆女士——————————————Miss Sloane<br><img src="https://img.piegg.cn/week155.jpg?imageslim" alt="斯隆女士" title="斯隆女士"></p><!--more--><ul><li>导演：约翰·麦登</li><li>主演：杰西卡·查斯坦/古古·姆巴塔-劳/约翰·利特高/艾丽森·皮尔/迈克尔·斯图巴/马克·斯特朗/杰克·莱西/道格拉斯·史密斯/萨姆·沃特森/迪伦·贝克/恩尼斯·埃斯莫/梅格翰·法伊/亚历桑德拉·卡斯蒂略/凯尔·麦克/杰克·默里</li><li>片长：132分钟</li><li>影 片类型：剧情/惊悚/</li><li>豆 瓣评分：8.6/10(from7,763users)</li><li>IMDB评分：7.2/10(from11,696users)</li></ul><p>Hi，各位，又到了一周推荐一部好电影的时候啦。本周给大家推荐的是去年一部特别精致的“政治惊悚”电影《斯隆女士》。老实说这部电影一开始并没有吸引我的地方，不管是片名还是简介。不过惊讶于它的口碑，看完之后真心觉得是一部对得起评分的好电影。</p><p>本片的亮点有三：</p><ol><li><p>斯隆女士的表演够有力。从开始到结束，一个人串起了整部电影。铿锵有力的措辞，干净利落的动作，敏锐的洞察力以及近乎变态的求胜欲，让她当之无愧是本片的唯一核心。</p></li><li><p>剧本亮。本片的剧情一环接着一环，此起彼伏。双方阵营你来我往尽显尔虞我诈。见招拆招，剧情紧凑得让你缓不过来，直呼过瘾。</p></li><li><p>反转。这是本片争议最多的地方。说好的人说反转地漂亮，说不好的人说反转地太戏剧。我看来是真的反转地很棒。其实这样宣扬主旋律的反转既出乎意料又合情合理，我觉得很棒。</p></li></ol><p>PS：本片在很多关键地方的配乐也很赞。好电影，值得一看。</p><hr><h3 id="2017-03-25-WEEK154-看不见的客人"><a href="#2017-03-25-WEEK154-看不见的客人" class="headerlink" title="2017-03-25 WEEK154 看不见的客人"></a>2017-03-25 WEEK154 看不见的客人</h3><p>看不见的客人——————————————Contratiempo<br><img src="https://img.piegg.cn/week154.jpg?imageslim" alt="看不见的客人" title="看不见的客人"></p><!--more--><ul><li>导演：奥里奥尔·保罗</li><li>主演：马里奥·卡萨斯/阿娜·瓦格纳/何塞·科罗纳/芭芭拉·蓝妮/法兰西斯克·欧瑞拉/帕科·图斯/大卫·塞尔瓦斯/伊尼戈·加斯特西/珊·叶拉姆斯/马内尔·杜尔索/布兰卡·马丁内斯/佩雷·布拉索/乔迪·布鲁内特/鲍毕·冈塞莱斯/玛蒂娜·乌尔塔多</li><li>片长：106分钟</li><li>影 片类型：悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.6/10(from7,419users)</li><li>IMDB评分：7.6/10(from1,559users)</li></ul><p>Hi，各位，好久不见~本期给大家推荐的是一部来自西班牙的悬疑电影《看不见的客人》。西班牙的一些悬疑电影一直以精致独特著称，本片也不例外。而且是少有的那种从片头到片尾一直能吸引你看下去的悬疑电影。</p><p>悬疑电影最好看的地方莫过于留下很多种在观众心中的坑然后再以精妙的手法把这些坑再给填上，让你心服口服。一开始的重重迷雾，一点点拨开；然后换一个角度开始反转；乃至最后峰回路转水落石出，一气呵成，特别给力！在一点点拨开迷雾的时候，人性的丑恶也在一点点地暴露出来。这种转变，顺带着推进剧情的发展、结局的改变，让你不禁拍手叫好，心悦诚服。</p><p>这部电影真的是看完会让你赞不绝口，好电影，值得一看。</p><hr><h3 id="2017-03-19-WEEK153-撞车"><a href="#2017-03-19-WEEK153-撞车" class="headerlink" title="2017-03-19 WEEK153 撞车"></a>2017-03-19 WEEK153 撞车</h3><p>撞车——————————————Crash<br><img src="https://img.piegg.cn/week153.jpg?imageslim" alt="撞车" title="撞车"></p><!--more--><ul><li>导演：保罗·哈吉斯</li><li>主演：桑德拉·布洛克/唐·钱德尔/马特·狄龙/布兰登·费舍/泰伦斯·霍华德/坦迪·牛顿/卢达克里斯/迈克尔·佩纳/珍妮弗·艾斯波西多/瑞恩·菲利普</li><li>片长：112分钟</li><li>影 片类型：剧情/犯罪</li><li>豆 瓣评分：8.6/10(from160,771users)</li><li>IMDB评分：7.8/10(from371,906users)</li></ul><p>Hi，各位好久不见~本期给大家推荐的是2004年的奥斯卡最佳电影《撞车》。这部电影的一个核心的主题是种族歧视，但是又不是纯粹的种族歧视——导演挖掘了这点，种族歧视归根结底，还是来自于人心。</p><p>除了影片的的核心主题比较容易触动人心之外，影片的编剧也是十分赞。多线叙事+“打乱”时空的布局，让你一点点走进影片描述的这么多人里。错综复杂的关系交织在一起，每个人都有着自己的难题，自己的信仰，自己的人生。没有绝对的是与非，没有绝对的善与恶。Crash，撞击的一瞬间，所有人的人生仿佛都经历了一次改变。有那么些人你认为罪不可赦，却做出让你能歌颂人间大爱的举动；有些人你认为一身正气，却做出让你无法理解的冲动之举。我们说种族歧视是美国社会里一个存在已久的问题，而导演将其赤裸裸得摆上荧幕了之后，又给其加上了一层遮羞布——遮住的不是影片里的人，遮住的是那些叫嚣着种族主义的带有种族歧视的那堆人。</p><p>大牌影星实力过硬，也给这部电影增色不少。好电影，值得一看。</p><hr><h3 id="2017-03-11-WEEK152-比海更深"><a href="#2017-03-11-WEEK152-比海更深" class="headerlink" title="2017-03-11 WEEK152 比海更深"></a>2017-03-11 WEEK152 比海更深</h3><p>比海更深——————————————海よりもまだ深く<br><img src="https://img.piegg.cn/week152.jpg?imageslim" alt="比海更深" title="比海更深"></p><!--more--><ul><li>导演：是枝裕和</li><li>主演：阿部宽/真木阳子/小林聪美/中川雅也/池松壮亮/桥爪功/树木希林/中村友理/高桥和也/小泽征悦/峰村理惠/古馆宽治/叶山奖之/吉泽太阳</li><li>片长：117分钟</li><li>影 片类型：剧情/家庭</li><li>豆 瓣评分：8.6/10(from29,854users)</li><li>IMDB评分：7.6/10(from1,941users)</li></ul><p>Hi，各位好久不见~本期给大家推荐的电影是来自日本的《比海更深》。比海更深的是什么，是情感。有人说本片很治愈，有人说本片很“毒”鸡汤，我觉得，本片很伤感。围绕着情感，本片讲述的故事很“无力”。每个角色都有自己的无奈，每个角色都有自己的迫不得已。</p><p>这部电影可以说没有什么高潮，平铺直叙着一家人的喜怒哀乐。这种淡淡的描述，日常的镜头切换，让我想到了另外一部名字里也有“海”字的《海街日记》。这种“日常番”的电影，看似平淡无奇，但是越看越有味道。金句频出，也是让我非常喜欢它的一个原因。“我的人生到底从哪开始不正常了”“我没有成为你想的那个人，真的很抱歉”。面对现实，我们总有一些无力感，却又不得不为之奋斗——可能不是为了自己，但是得为了别人。男主良多，就是一个只有自己独处的时候才会展示出孤独脆弱的一面的人，失魂落魄，没有什么积蓄。但是为了儿子却“出手大方”，毫不吝啬。跟前妻离婚却又一直关心着她的一举一动。年老的奶奶，住了40年的房子，“不争气”的儿子，屈服现实的前妻，油嘴滑舌的姐姐。。简单的镜头，三言两语，却勾勒的明明白白。让人看了感慨良多。</p><p>前路还长，还有多少坎坷没有遇到，还有多少失意没有感触。好在阳光正好，天空还蓝，大海还深。好电影，值得一看。</p><hr><h3 id="2017-03-05-WEEK151-推销员"><a href="#2017-03-05-WEEK151-推销员" class="headerlink" title="2017-03-05 WEEK151 推销员"></a>2017-03-05 WEEK151 推销员</h3><p>推销员——————————————فروشنده<br><img src="https://img.piegg.cn/week151.jpg?imageslim" alt="推销员" title="推销员"></p><!--more--><ul><li>导演：阿斯哈·法哈蒂</li><li>主演：沙哈布·侯赛尼/塔兰涅·阿里多斯蒂/巴巴克·卡里米/法里德·萨贾蒂·侯赛尼/米娜·沙达蒂</li><li>片长：125分钟</li><li>影 片类型：剧情/</li><li>豆 瓣评分：7.7/10(from4,394users)</li><li>IMDB评分：8.2/10(from13,585users)</li></ul><p>Hi，各位好久不见~本次给大家推荐的是一部来自伊朗的《推销员》。有可能大家有听过、看过《推销员之死》，而本片也借着《推销员之死》的名义，讲述了一个让人叹惋的故事。</p><p>本片关键词是——宽容。是的，听到这里你也能知道，这是一部讲述人性的电影。因为宽容让这个社会更加和谐有爱，因为宽容让人与人之间拥有更多对话的机会。男主角的愤怒，让这个悲伤的事件走向了不可挽回的地步，让他的婚姻步入了坟墓。压死骆驼的最后一根稻草往往是一根一意孤行的野草。受害者更多的是需要理解和陪伴。但是通常，我们周边的人却只能被愤怒所支配。这就是悲哀。所以哪怕受害者已经恢复已经原谅，我们还有可能悬崖勒不住马。</p><p>影片中穿插的几段《推销员之死》的话剧场景，都各有深意。人物关系逐渐清晰，人物性格逐渐完善。两位主演表演功力深厚，加之导演对全剧镜头、剧情力度把握得当，也难怪这部电影能够拿到奥斯卡最佳外语片。好电影，值得一看。</p><hr><h3 id="2017-02-19-WEEK150-血战钢锯岭"><a href="#2017-02-19-WEEK150-血战钢锯岭" class="headerlink" title="2017-02-19 WEEK150 血战钢锯岭"></a>2017-02-19 WEEK150 血战钢锯岭</h3><p>血战钢锯岭——————————————Der kommer en dag<br><img src="https://img.piegg.cn/WEEK150.jpg?imageslim" alt="血战钢锯岭" title="血战钢锯岭"></p><!--more--><ul><li>导演：梅尔·吉布森</li><li>主演：安德鲁·加菲尔德/萨姆·沃辛顿/文斯·沃恩/雨果·维文/卢克·布雷西/泰莉莎·帕尔墨/瑞切尔·格里菲斯/纳撒尼尔·布佐尼克/理查德·劳斯伯格/马特·纳夫莱/费拉斯·迪拉尼/瑞安·柯尔/卢克·佩格勒</li><li>片长：139分钟(中国大陆)</li><li>影 片类型：剧情/动作/传记/历史/战争</li><li>豆 瓣评分：8.7/10(from219,545users)</li><li>IMDB评分：8.3/10(from133,710users)</li></ul><p>Hi，各位好久不见~十分抱歉拖更到现在。这个月事情多，不过已经算是忙完一滩事了。</p><p>本周给大家推荐的电影，相信很多人都有听说甚至有去电影院看过。我是从看战争片开始喜欢上看电影的。我的第一部印象最深刻的战争片是《拯救大兵瑞恩》。由此走上了观影的道路。</p><p>这部电影最牛逼的地方有两个：1. 男主的经历简直牛逼。 2. 这居然是根据真实故事拍的，而且真实故事貌似更牛逼一点。 导演梅尔吉布森依旧宝刀未老，这场电影的特效、特写镜头是如此的逼真乃至让人深刻感到战争的恐怖。有人说，如果这部电影用3D放映，估计会看吐一堆人吧。</p><p>一部电影里最重要的是要有矛盾，有矛盾才有剧情，有剧情才能发展。这部电影的矛盾，小的来说是个人的信仰和一支枪的矛盾。大的来说是信仰与战争的矛盾。我特别喜欢豆瓣里有位影评人的一句话：“他的信仰无法改变战争，而战争却拿他看似最普通的信仰也无可奈何。”震撼，感动。好电影，值得推荐~</p><hr><h3 id="2017-02-11-WEEK149-海边的曼彻斯特"><a href="#2017-02-11-WEEK149-海边的曼彻斯特" class="headerlink" title="2017-02-11 WEEK149 海边的曼彻斯特"></a>2017-02-11 WEEK149 海边的曼彻斯特</h3><p>海边的曼彻斯特——————————————Der kommer en dag<br><img src="https://img.piegg.cn/week149.jpg?imageslim" alt="海边的曼彻斯特" title="海边的曼彻斯特"></p><!--more--><ul><li>导演：肯尼斯·罗纳根</li><li>主演：卡西·阿弗莱克/米歇尔·威廉姆斯/卢卡斯·赫奇斯/凯尔·钱德勒/卡拉·海沃德/泰特·多诺万/埃里卡·麦克德莫特/格瑞辰·摩尔/希瑟·伯恩斯/蜜西·雅格/斯蒂芬·亨德森/约什·汉密尔顿/卡洛琳·皮克曼/肖恩·菲茨吉本/肯尼斯·罗纳根/利亚姆·麦克尼尔/马修·布罗德里克/</li><li>片长：137分钟</li><li>影 片类型：剧情/</li><li>豆 瓣评分：8.6/10(from24,867users)</li><li>IMDB评分：8.2/10(from47,014users)</li></ul><p>Hi，各位，好久不见~新年事情多，中间拖更了一周实在抱歉~<br>本部电影是去年一部好评如潮的电影——这是一部几乎跟生活贴近到平行的电影。每天我们都能看到各种鸡汤、各种励志故事在四处传播。但是更多的时候，去读鸡汤的你往往过得并不“励志”。这部电影也是如此，没有鸡汤，甚至反鸡汤——打破我们所认知的屏幕“常规”，但是仔细想想，却是我们生活中无时无刻不在上演的故事。<br>你问我悲伤能有多悲伤，痛苦能有多痛苦。你问我有些人为什么会想着轻生，有些人为什么不能“走出来”？我觉得豆瓣短评里的一句话说的特别好：「那些劝我们向前看的朋友，不是所有人都可以和过去和解」。是的，有些事情就是无法通过时间，通过经历，通过环境而改变，有些伤疤就是无法随着岁月而抹平。主角卡西把那个失去了“灵魂”的男主演的惟妙惟肖，而现实中确实是有很多时候，心碎得无法愈合。没有鸡汤，不是一个美好的结局，但是确确实实是生活中的你我或者他。好电影，值得一看。</p><hr><h3 id="2017-01-29-WEEK148-总有一天"><a href="#2017-01-29-WEEK148-总有一天" class="headerlink" title="2017-01-29 WEEK148 总有一天"></a>2017-01-29 WEEK148 总有一天</h3><p>总有一天——————————————Der kommer en dag<br><img src="https://img.piegg.cn/week148.jpg?imageslim" alt="总有一天" title="总有一天"></p><!--more--><ul><li>导演：杰斯珀·W·尼尔森</li><li>主演：拉斯·米克尔森/苏菲·格拉宝/哈拉尔德·凯泽·赫尔曼/艾伯特·鲁德贝克·林哈特/劳里斯·斯科夫高·安德森/拉斯·兰特/索伦·希特-拉森/大卫·丹席克/松佳·里奇特/索比亚格·侯菲尔德/雅各布·B·恩格曼/</li><li>片长：110分钟</li><li>影 片类型：剧情/</li><li>豆 瓣评分：8.7/10(from8,721users)</li><li>IMDB评分：7.7/10(from688users)</li></ul><p>Hi，各位，好久不见。首先祝大家2017年，新年快乐！</p><p>作为2017年农历新年推荐的第一部电影，必然是质量上乘的。这部来自丹麦的电影，改编自真实故事，发人深省而又感人肺腑。</p><p>看这部电影的同时，可以联想国内类似的杨永信“电疗戒网瘾”的例子。只不过，杨永信是当代的例子，而本片里的情况出现在上世纪60年代的丹麦。无助，绝望，乃至内心扭曲。在故事发生的学校里，你可以看到一群“行尸走肉”般，被“驯服”的孩子。有苦说不出，反抗无力，孤立无助。在这种环境下，还要遭受禽兽老师的摧残，校长、助理的掌掴。而唯一带有良知的老师却也只是看不下去而辞职。一切似乎没有办法逆转，一切似乎都显得那么黑暗。</p><p>而两个小主人公却是从头至尾给本片注入了灵魂。注入了追求自由，敢于反抗，友善热心的灵魂。我最感动的一个画面是哥哥拿一个“私藏”的巧克力给弟弟吃的时候，弟弟只吃了一口就分给眼馋的同伴们——哪怕这些同伴前一秒还在奚落他。融入集体是不容易的，融入一个这样“黑暗”的集体更是不容易。不过是兄弟俩给这群孩子带去了希望，带去了光明。</p><p>总有一天，这到底是哪一天呢？不知道，但是虽然孩子们遭受了种种令人愤慨的折磨，总归是有正义降临的那天。这一天的风景是多么美，这一天的阳光是多么灿烂。也许此时此刻还有无数类似的孤儿院、学校有类似的情况，但是你不知道。没有亲身经历，你永远不知道，哪怕总有一天，你也不知道是哪一天。好电影，值得一看。</p><hr><h3 id="2017-01-19-WEEK147-攻壳机动队"><a href="#2017-01-19-WEEK147-攻壳机动队" class="headerlink" title="2017-01-19 WEEK147 攻壳机动队"></a>2017-01-19 WEEK147 攻壳机动队</h3><p>攻壳机动队——————————————攻殻機動隊<br><img src="https://img.piegg.cn/week147.jpg" alt="攻壳机动队" title="攻壳机动队"></p><!--more--><ul><li>导演：押井守</li><li>主演：田中敦子/大塚明夫/山寺宏一/大木民夫/家弓家正/仲野裕/</li><li>片长：83分钟</li><li>影 片类型：动作/科幻/动画/悬疑/</li><li>豆 瓣评分：8.9/10(from43,836users)</li><li>IMDB评分：8.0/10(from85,436users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是一部很早以前的动画电影——《攻壳机动队》。相信不少人已经看过或者听过这部作品的名字。直到我自己22年后看到这部电影，真的觉得依然思想很伟大。</p><p>作为一部科幻动画电影，它将思考放在了现在都未达到的公元2029年。人类文明没有达到非常逆天的程度却也诞生了机器与灵魂结合的“人”，而在此之上，极具思辨的观点，灵魂和躯体之间到底有没有具体关系，灵魂能不能超脱躯体？自我意识的存在依赖于什么。。等等。</p><p>这部电影披着一层动画的壳，但是思考问题深度却远远超过壳本身。据说《黑客帝国》也深深收到它的影响，可想而知这部电影的伟大之处。而它的英文名也发人深省《Ghost in Shell》，躯壳下的灵魂。如果你是个喜爱烧脑的，喜欢思考这类高深哲学的人，那么它绝对是不容错过的。</p><hr><h3 id="2017-01-09-WEEK146-白日梦想家"><a href="#2017-01-09-WEEK146-白日梦想家" class="headerlink" title="2017-01-09 WEEK146 白日梦想家"></a>2017-01-09 WEEK146 白日梦想家</h3><p>白日梦想家——————————————The Secret Life of Walter Mitty<br><img src="https://img.piegg.cn/week146.jpg" alt="白日梦想家" title="白日梦想家"></p><!--more--><ul><li>导演：本·斯蒂勒</li><li>主演：本·斯蒂勒/克里斯汀·韦格/亚当·斯科特/雪莉·麦克雷恩/西恩·潘/凯瑟琳·哈恩/泰伦斯·伯尼·海恩斯 /保罗·菲兹杰拉德/格蕾丝·雷克斯/乔恩·戴利/乔伊·斯洛特尼克</li><li>片长：114分钟</li><li>影 片类型：剧情/喜剧/冒险</li><li>豆 瓣评分：8.3/10(from124,623users)</li><li>IMDB评分：7.3/10(from243,738users)</li></ul><p>Hi，各位，好久不见。本周给大家推荐的是一部轻松诙谐的喜剧电影《白日梦想家》。但是本片的中文翻译其实并不是特别能很好的描述本片的主题。如果叫做《白日冒险家》可能更好一点？</p><p>我很喜欢本片的宣传语：<code>Stop Dreaming,Start Living</code>（不要做白日梦了，拥抱生活吧）。主人公是个爱做白日梦的公司职员，说是整天沉浸在自己的意淫的世界里也不为过。不过因为一起突发事件他却不得不<code>To see the world</code>，于是开始了正片。喜欢本片的人大概跟我一样吧，影片的风景确实拍的相当漂亮，而且故事一串接着一串，虽然有些夸张有些巧合，但是不可否认观影体验相当棒！我最喜欢的片段是主人公溜着滑板沿着公路俯冲而下的片段，那个片段看着真的感觉，这才是生活啊，这才是<code>Start Living</code>啊。</p><p>不出意料的Happy Ending，也给本片观众灌了一碗大鸡汤。Anyway，如果是想茶余饭后放松心情，喝喝鸡汤，看看风景，享受生活，那么本片绝对是不二之选。</p><hr><h3 id="2017-01-02-WEEK145-45周年"><a href="#2017-01-02-WEEK145-45周年" class="headerlink" title="2017-01-02 WEEK145 45周年"></a>2017-01-02 WEEK145 45周年</h3><p>45周年——————————————45 Years<br><img src="https://img.piegg.cn/week145.jpg" alt="45周年" title="45周年"><br><!--more--></p><ul><li>导演：安德鲁·海格</li><li>主演：夏洛特·兰普林/多莉·韦尔斯/汤姆·康特奈/杰拉丁妮·詹姆斯/山姆·亚历山大/麦克斯·路德/大卫·西布利/汉娜·查尔莫斯/理查德·坎宁汉姆/米歇尔·芬奇/保罗·戈德史密斯</li><li>片长：95分钟</li><li>影 片类型：剧情/爱情</li><li>豆 瓣评分：7.7/10(from19,384users)</li><li>IMDB评分：7.1/10(from21,005users)</li></ul><p>Hi，各位，好久不见。最近推电影的时间总是乱糟糟的，这段时间比较忙，之后会逐步走回正规的，十分抱歉！</p><p>新年给大家推荐的第一部电影，是来自英国的《45周年》。这部电影讲述了两位老人的爱情故事——或者说是爱情悲剧故事？影片从即将迎来结婚45周年之前的6天开始说起，一起突发的事件，打破了45年来的“平静”。按理说能够相扶相伴了45年的老夫老妻，感情应该是十分深厚了。然而在本片的故事设定下，却让一切都打碎。如果说《消失的爱人》这部电影让你后怕不以但是仔细想想生活中发生类似的事情的情况毕竟还是少数，那么这部电影就会给所有的情侣一个警钟——毕竟它太有可能了，并且真的时常就在我们的周围发生类似的事。</p><p>虽然是50年被冰封的记忆，却始终无法消融。用一生的真情换来一生的替代，想必换作是谁都无法接受吧。影片的最后，伴随着极富隐喻的音乐的落幕，女主迅速的抽手，让一切的“美好”彻底破碎，为之动容。本片的两位主演不愧是老戏骨，张弛有度而且让你感慨万分。好电影，值得一看。</p><hr><h3 id="2016-12-26-WEEK144-窃听风暴"><a href="#2016-12-26-WEEK144-窃听风暴" class="headerlink" title="2016-12-26 WEEK144 窃听风暴"></a>2016-12-26 WEEK144 窃听风暴</h3><p>窃听风暴——————————————Das Leben der Anderen<br><img src="https://img.piegg.cn/week144.jpg" alt="窃听风暴" title="窃听风暴"></p><!--more--><ul><li>导演：弗洛里安·亨克尔·冯·多纳斯马</li><li>主演：乌尔里希·穆埃/马蒂娜·戈黛特/塞巴斯蒂安·科赫/乌尔里奇·图克尔/托马斯·席尔梅</li><li>片长：137分钟</li><li>影 片类型：剧情/悬疑</li><li>豆 瓣评分：9.1/10(from195,431users)</li><li>IMDB评分：8.5/10(from268,134users)</li></ul><p>Hi，各位，好久不见。本期给大家带来的又是一部来自德国的电影《窃听风暴》这部电影从一个很“刁钻”的角度切入，向我们还原了当时的东德残酷的社会现实。</p><p>在那个年代，东德有很多秘密警察，负责监视、监听人民的一举一动。有可能一句玩笑话，一个不经意的举动就让他们遭到牢狱之灾。而本片正是通过一个监听特工的视角，去描绘了当时的社会是多么灰暗，高层是多么腐朽。而在这监听的过程中的人性的转变亦是本片最精华最感人的部分——</p><p>主演乌尔里希·穆埃生动地演绎了一个国家机器下的特工从坚定不移地遵守指令到“良心”发现-》感受到了什么是黑暗，什么才是真正的自由和民主的转变。</p><p>去翻阅本片的背景故事的时候有两则小故事让我非常震惊：</p><p>1.东诺士马克的电影用了很多当初东德的机关大楼实地拍摄， 但是监狱博物馆的馆长却拒绝了他拍摄的请求。原因？馆长说，因为东诺士马克的剧本不符合史实:整个东德历史，像魏斯乐那样“良心发现”的秘密警察，对不起，一个都没有。<br>2.主演乌尔里希·穆埃的前妻，曾经也是秘密警察的线民，长期监控自己的丈夫，而这些记录是在两德统一之后，主演去翻看自己的档案的时候才发现的。</p><p>这是一部献给好人的奏鸣曲，好电影，值得观看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2017-12-17-WEEK186-一级恐惧&quot;&gt;&lt;a href=&quot;#2017-12-17-WEEK186-一级恐惧&quot; class=&quot;headerlink&quot; title=&quot;2017-12-17 WEEK186 一级恐惧&quot;&gt;&lt;/a&gt;2017-12-17 WEEK186 一级恐惧&lt;/h3&gt;&lt;p&gt;一级恐惧——————————————Primal Fear&lt;br&gt;&lt;img src=&quot;https://img.piegg.cn/week186.jpg?imageslim&quot; alt=&quot;一级恐惧&quot; title=&quot;一级恐惧&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
      <category term="周电" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/%E5%91%A8%E7%94%B5/"/>
    
    
      <category term="电影" scheme="https://molunerfinn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>PicGo——一个基于Electron的图片上传+简单管理的工具</title>
    <link href="https://molunerfinn.com/make-a-picgo/"/>
    <id>https://molunerfinn.com/make-a-picgo/</id>
    <published>2017-12-13T11:11:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmd6ou9eynj2046046glj" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个比较常用markdown写文章、博客的人，在markdown里插入图片对我而言一直一个比较繁琐的活。以前每周写电影推荐的时候，我要在markdown里插入一张电影海报，我需要如下的操作：</p><ol><li>打开豆瓣的网站，选一张满意的海报，下载</li><li>打开七牛的网站，登录，点点点，找到上传，上传</li><li>关闭上传窗口，找到地址，复制地址，再关闭七牛</li><li>粘贴到markdown里</li></ol><p>每次都需要繁琐的打开网页进行一些必要而枯燥的操作。这样很麻烦。在用过mac上一款很不错的小工具应用iPic后我非常喜欢它的简洁操作。不过它免费版本并不支持七牛图床。所以我就想着，能不能自己写一个类似的工具呢？结合自己的使用习惯再顺便加点功能。</p><p>于是我就开始自己的图片上传工具的开发了。它叫做<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>。</p><a id="more"></a><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>最早最早我想着用swift来写一个原生的应用，主要想着能做出体积友良、性能优秀的应用。不过鉴于swift迭代的太快，很多教程都已经不适合了。并且swift网上的教程对我这个小前端来说着实要学的东西不少。我只是想做个方便自己的工具而已，一切以方便自己作为大前提。作为一个前端工程师，我决定采用<a href="https://electronjs.org/" target="_blank" rel="noopener">electron</a>来开发。同时因为我是Vue的粉丝，一并就使用了<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>作为我的electron开发脚手架。不得不说，<code>electron-vue</code>提供的脚手架做的真的很用心，而且我自己要做修改加配置什么的也很方便。日后做跨平台支持的话也比较容易。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>由于用过iPic，很多它的一些操作模式我觉得特别值得借鉴。比如我想要个简单的拖拽就能实现上传，我想要能够上传我剪贴板的图片，我想要是实现上传成功后自动复制链接到剪贴板，这样我就可以直接编辑了。</p><p>那么这样一来，我编辑文章只需要如下操作：</p><ul><li>找到要上传的图片，使用这个工具直接上传</li><li>上传成功后自动复制地址到剪贴板，在markdown里直接粘贴</li></ul><p>一下子省去了很多原本繁琐的操作！</p><h2 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h2><blockquote><p>前前后后，用每天的闲暇时间从0开始学习electron框架，到Travis-ci构建出第一个可用的版本，大概花了一个月的时间。基本实现了我自己当初的目标，极大提升了我自己的文章写作体验。</p></blockquote><h3 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h3><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmf5fzq27lg218e0p0kjo" alt=""></p><h3 id="精致设计"><a href="#精致设计" class="headerlink" title="精致设计"></a>精致设计</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876294-14f7cf5a-df60-11e7-9c59-a8d4565c61d4.png" alt=""></p><p>macOS系统下，支持拖拽至menubar图标实现上传。menubar app 窗口显示最新上传的5张图片以及剪贴板里的图片。点击图片自动将上传的链接复制到剪贴板。</p><h3 id="便捷管理"><a href="#便捷管理" class="headerlink" title="便捷管理"></a>便捷管理</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876349-3ee314a0-df60-11e7-8c9f-9904264d6ddb.png" alt=""></p><p>查看你的上传记录，重复使用更方便。支持点击图片大图查看。支持删除图片（仅本地记录），让界面更加干净。</p><h3 id="可选图床"><a href="#可选图床" class="headerlink" title="可选图床"></a>可选图床</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876259-f7620af0-df5f-11e7-807e-0dc84a5cee50.png" alt=""></p><p>目前支持微博图床和七牛图床。未来将支持更多。方便不同图床的上传需求。</p><h3 id="多样链接"><a href="#多样链接" class="headerlink" title="多样链接"></a>多样链接</h3><p><img src="https://user-images.githubusercontent.com/12621342/33876419-70107f68-df60-11e7-8858-9c062bdb4e6e.png" alt=""></p><p>支持4种剪贴板链接格式，让你的文本编辑游刃有余。</p><h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>目前PicGo还是一个很年轻的项目，bug肯定是不少的，功能方面也有所欠缺。所以还需要不断地完善。我希望大家在使用的过程中有什么意见或者建议都可以在项目仓库里的<a href="https://github.com/Molunerfinn/PicGo/issues" target="_blank" rel="noopener">issues</a>里提出来~</p><ul><li>目前暂不支持Windows和linux，未来将会逐步支持。</li><li>未来将支持更多的图床。如果可能，可以支持自定义的图床（只要设定好协议）</li><li>将集成系统服务，提供一键上传的全局快捷键</li><li>提升用户体验，修bug</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望这是一个能够提升你文章编辑体验的工具。如果你想学习electron开发，我也会在不久之后写几篇文章用于记录我是如何开发<code>PicGo</code>这个electron应用的。如果你喜欢它，欢迎给这个<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">项目</a>点个Star。另外，它是开源免费的，如果你觉得它对你有所帮助，也可以考虑给我打赏一杯喝咖啡的钱~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/8700af19ly1fmd6ou9eynj2046046glj&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一个比较常用markdown写文章、博客的人，在markdown里插入图片对我而言一直一个比较繁琐的活。以前每周写电影推荐的时候，我要在markdown里插入一张电影海报，我需要如下的操作：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;打开豆瓣的网站，选一张满意的海报，下载&lt;/li&gt;&lt;li&gt;打开七牛的网站，登录，点点点，找到上传，上传&lt;/li&gt;&lt;li&gt;关闭上传窗口，找到地址，复制地址，再关闭七牛&lt;/li&gt;&lt;li&gt;粘贴到markdown里&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;每次都需要繁琐的打开网页进行一些必要而枯燥的操作。这样很麻烦。在用过mac上一款很不错的小工具应用iPic后我非常喜欢它的简洁操作。不过它免费版本并不支持七牛图床。所以我就想着，能不能自己写一个类似的工具呢？结合自己的使用习惯再顺便加点功能。&lt;/p&gt;&lt;p&gt;于是我就开始自己的图片上传工具的开发了。它叫做&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="electron" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/electron/"/>
    
    
      <category term="web" scheme="https://molunerfinn.com/tags/web/"/>
    
      <category term="vue" scheme="https://molunerfinn.com/tags/vue/"/>
    
      <category term="electron" scheme="https://molunerfinn.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>全栈测试实战：用Jest测试Vue+Koa全栈应用</title>
    <link href="https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/"/>
    <id>https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/</id>
    <published>2017-11-15T21:34:00.000Z</published>
    <updated>2018-11-19T15:29:00.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年一月份的时候我写了一个<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">Vue+Koa的全栈应用</a>，以及相应的<a href="https://molunerfinn.com/Vue+Koa/">配套教程</a>，得到了很多的好评。同时我也在和读者交流的过程中不断认识到不足和缺点，于是也对此进行了不断的更新和完善。本次带来的完善是加入和完整的前后端测试。相信对于很多学习前端的朋友来说，<code>测试</code>这个东西似乎是个熟悉的陌生人。你听过，但是你未必做过。如果你对前端（以及nodejs端）测试很熟悉，那么本文的帮助可能不大，不过我很希望能得到你们提出的宝贵意见！</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>和上一篇<a href="https://molunerfinn.com/Vue+Koa/">全栈开发实战：用Vue2+Koa1开发完整的前后端项目</a>一样，本文从测试新手的角度出发（默认了解Koa并付诸实践，了解Vue并付诸实践，但是并无测试经历），在已有的项目上从0开始构建我们的全栈测试系统。可以了解到测试的意义，<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>测试框架的搭建，前后端测试的异同点，如何写测试用例，如何查看测试结果并提升我们的测试覆盖率，100%测试覆盖率是否是必须，以及在搭建测试环境、以及测试本身过程中遇到的各种疑难杂症。希望可以作为入门前端以及Node端测试的文章吧。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>有了之前的项目结构作为骨架，加入Jest测试框架就很简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── .env  // 环境变量配置文件</span><br><span class="line">├── app.js  // Koa入口文件</span><br><span class="line">├── build // vue-cli 生成，用于webpack监听、构建</span><br><span class="line">│   ├── build.js</span><br><span class="line">│   ├── check-versions.js</span><br><span class="line">│   ├── dev-client.js</span><br><span class="line">│   ├── dev-server.js</span><br><span class="line">│   ├── utils.js</span><br><span class="line">│   ├── webpack.base.conf.js</span><br><span class="line">│   ├── webpack.dev.conf.js</span><br><span class="line">│   └── webpack.prod.conf.js</span><br><span class="line">├── config // vue-cli 生成&amp;自己加的一些配置文件</span><br><span class="line">│   ├── default.conf</span><br><span class="line">│   ├── dev.env.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── prod.env.js</span><br><span class="line">├── dist // Vue build 后的文件夹</span><br><span class="line">│   ├── index.html // 入口文件</span><br><span class="line">│   └── static // 静态资源</span><br><span class="line">├── env.js // 环境变量切换相关 &lt;-- 新</span><br><span class="line">├── .env // 开发、上线时的环境变量 &lt;-- 新</span><br><span class="line">├── .env.test // 测试时的环境变量 &lt;-- 新</span><br><span class="line">├── index.html // vue-cli生成，用于容纳Vue组件的主html文件。单页应用就只有一个html</span><br><span class="line">├── package.json // npm的依赖、项目信息文件、Jest的配置项 &lt;-- 新</span><br><span class="line">├── server // Koa后端，用于提供Api</span><br><span class="line">│   ├── config // 配置文件夹</span><br><span class="line">│   ├── controllers // controller-控制器</span><br><span class="line">│   ├── models // model-模型</span><br><span class="line">│   ├── routes // route-路由</span><br><span class="line">│   └── schema // schema-数据库表结构</span><br><span class="line">├── src // vue-cli 生成&amp;自己添加的utils工具类</span><br><span class="line">│   ├── App.vue // 主文件</span><br><span class="line">│   ├── assets // 相关静态资源存放</span><br><span class="line">│   ├── components // 单文件组件</span><br><span class="line">│   ├── main.js // 引入Vue等资源、挂载Vue的入口js</span><br><span class="line">│   └── utils // 工具文件夹-封装的可复用的方法、功能</span><br><span class="line">├── test</span><br><span class="line">│   ├── sever // 服务端测试 &lt;-- 新</span><br><span class="line">│   └── client // 客户端（前端）测试 &lt;-- 新</span><br><span class="line">└── yarn.lock // 用yarn自动生成的lock文件</span><br></pre></td></tr></table></figure><p>可以看到新增的或者说更新的东西只有几个：</p><ol><li>最主要的test文件夹，包含了客户端（前端）和服务端的测试文件</li><li>env.js以及配套的<code>.env</code>、<code>.env.test</code>，是跟测试相关的环境变量</li><li>package.json，更新了一些依赖以及Jest的配置项</li></ol><blockquote><p>主要环境：Vue2，Koa2，Nodejs v8.9.0</p></blockquote><h2 id="测试用到的一些关键依赖"><a href="#测试用到的一些关键依赖" class="headerlink" title="测试用到的一些关键依赖"></a>测试用到的一些关键依赖</h2><p>以下依赖的版本都是本文所写的时候的版本，或者更旧一些</p><ol><li>jest: ^21.2.1</li><li>babel-jest: ^21.2.0</li><li>supertest: ^3.0.0</li><li>dotenv: ^4.0.0</li></ol><p>剩下依赖可以项目<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">demo仓库</a>。</p><h2 id="搭建Jest测试环境"><a href="#搭建Jest测试环境" class="headerlink" title="搭建Jest测试环境"></a>搭建Jest测试环境</h2><p>对于测试来说，我也是个新手。至于为什么选择了<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>，而不是其他框架（例如mocha+chai、jasmine等），我觉得有如下我自己的观点（当然你也可以不采用它）：</p><ol><li>由Facebook开发，保证了更新速度以及框架质量</li><li>它有很多集成的功能（比如断言库、比如测试覆盖率）</li><li>文档完善，配置简单</li><li>支持typescript，我在学习typescript的时候也用了Jest来写测试</li><li>Vue官方的单元测试框架<a href="https://github.com/vuejs/vue-test-utils" target="_blank" rel="noopener">vue-test-utils</a>专门有配合Jest的测试说明</li><li>支持快照功能，对前端单元测试是一大利好</li><li>如果你是React技术栈，Jest天生就适配React</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add jest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install jest --save-dev</span><br></pre></td></tr></table></figure><p>很简单对吧。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>由于我项目的Koa后端用的是ES modules的写法而不是Nodejs的Commonjs的写法，所以是需要babel的插件来进行转译的。否则你运行测试用例的时候，将会出现如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● Test suite failed to run</span><br><span class="line"></span><br><span class="line">   /Users/molunerfinn/Desktop/work/web/vue-koa-demo/test/sever/todolist.test.js:1</span><br><span class="line">   (&#123;&quot;Object.&lt;anonymous&gt;&quot;:function(module,exports,require,__dirname,__filename,global,jest)&#123;import _regeneratorRuntime from &apos;babel-runtime/regenerator&apos;;import _asyncToGenerator from &apos;babel-runtime/helpers/asyncToGenerator&apos;;var _this = this;import server from &apos;../../app.js&apos;;</span><br><span class="line">                                                                                            ^^^^^^</span><br><span class="line"></span><br><span class="line">   SyntaxError: Unexpected token import</span><br><span class="line"></span><br><span class="line">     at ScriptTransformer._transformAndBuildScript (node_modules/jest-runtime/build/script_transformer.js:305:17)</span><br><span class="line">         at Generator.next (&lt;anonymous&gt;)</span><br><span class="line">         at new Promise (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure><p>看了官方github的<a href="https://github.com/facebook/jest#using-babel" target="_blank" rel="noopener">README</a>发现应该是<code>babel-jest</code>没装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-jest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install babel-jest --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>但是奇怪的是，文档里说：Note: babel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. 也就是babel-jest在jest安装的时候便会自动安装了。这点需要求证。</p></blockquote><p>然而发现运行测试用例的时候还是出了上述问题，查阅了相关<a href="https://github.com/facebook/jest/issues/2081" target="_blank" rel="noopener">issue</a>之后，我给出两种解决办法：</p><p>都是修改项目目录下的<code>.babelrc</code>配置文件，增加<code>env</code>属性，配置<code>test</code>环境如下：</p><p><strong>1.</strong> 增加<code>presets</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"env": &#123;</span><br><span class="line">  "test": &#123;</span><br><span class="line">    "presets": ["env", "stage-2"] // 采用babel-presents-env来转译</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 或者增加<code>plugins</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"env": &#123;</span><br><span class="line">  "test": &#123;</span><br><span class="line">    "plugins": ["transform-es2015-modules-commonjs"] // 采用plugins来讲ES modules转译成Commonjs modules</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，编译通过。</p><blockquote><p>通常我们将测试文件（*.test.js或*.spec.js）放置在项目的test目录下。Jest将会自动运行这些测试用例。值得一提的是，通常我们将基于<code>TDD</code>的测试文件命名为<code>*.test.js</code>，把基于<code>BDD</code>的测试文件命名为<code>*.spec.js</code>。这二者的区别可以看这篇<a href="http://www.cnblogs.com/ustbwuyi/archive/2012/10/26/2741223.html" target="_blank" rel="noopener">文章</a></p></blockquote><p>我们可以在<code>package.json</code>的<code>scripts</code>字段里加入<code>test</code>的命令（如果原本存在则换一个名字，不要冲突）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样我们就可以在终端直接运行<code>npm test</code>来执行测试了。下面我们先来从后端的Api测试开始写起。</p><h2 id="Koa后端Api测试"><a href="#Koa后端Api测试" class="headerlink" title="Koa后端Api测试"></a>Koa后端Api测试</h2><p>重现一下之前的应用的操作流程，可以发现应用分为登录前和登录后两种状态。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fl97i5zzb0g20z30ixk77.gif" alt=""></p><p>可以根据操作流程或者后端api的结构来写测试。如果根据操作流程来写测试就可以分为登录前和登录后。如果根据后端api的结构的话，就可以根据routes或者controllers的结构、功能来写测试。</p><p>由于本例登录前和登录后的api基本上是分开的，所以我主要根据上述后者（routes或controllers）来写测试。</p><p>到此需要解释一下一般来说（写）测试的步骤：</p><ol><li>写测试说明，针对你的每条测试说明测试了什么功能，预期结果是什么。</li><li>写测试主体，通常是 输入 -&gt; 输出。</li><li>判断测试结果，拿输出和预期做对比。如果输出和预期相符，则测试通过。反之，不通过。</li></ol><p>在<code>test</code>文件夹下新建一个<code>server</code>文件夹。然后创建一个<code>user.spec.js</code>文件。</p><p>我们可以通过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br></pre></td></tr></table></figure><p>的方式将我们的Koa应用的主入口文件引入。但是此时遇到了一个问题。我们如何对这个server发起http请求，并对其的返回结果做出判断呢？</p><p>在阅读了<a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">Async testing Koa with Jest</a>以及<a href="https://www.valentinog.com/blog/testing-api-koa-jest/" target="_blank" rel="noopener">A clear and concise introduction to testing Koa with Jest and Supertest</a>这两篇文章之后，我决定使用<a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">supertest</a>这个工具了。它是专门用来测试nodejs端HTTP server的测试工具。它内封了<a href="https://github.com/visionmedia/superagent" target="_blank" rel="noopener">superagent</a>这个著名的Ajax请求库。并且支持Promise，意味着我们对于异步请求的结果也能通过<code>async await</code>的方式很好的控制了。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add supertest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install supertest --save-dev</span><br></pre></td></tr></table></figure><p>现在开始着手写我们第一个测试用例。先写一个针对登录功能的吧。当我们输入了错误的用户名或者密码的时候将无法登录，后端返回的参数里，success会是false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/server/user.spec.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close() <span class="comment">// 当所有测试都跑完了之后，关闭server</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果输入用户名为Molunerfinn，密码为1234则无法登录。正确应为molunerfinn和123。</span></span><br><span class="line">test(<span class="string">'Failed to login if typing Molunerfinn &amp; 1234'</span>, <span class="keyword">async</span> () =&gt; &#123; <span class="comment">// 注意用了async</span></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server) <span class="comment">// 注意这里用了await</span></span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>) <span class="comment">// post方法向'/auth/user'发送下面的数据</span></span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>) <span class="comment">// 期望回传的body的success值是false（代表登录失败）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>上述例子中，test()方法能接受3个参数，第一个是对测试的描述(string)，第二个是回调函数(fn)，第三个是延时参数(number)。本例不需要延时。然后expect()函数里放输出，再用各种<a href="https://facebook.github.io/jest/docs/en/expect.html" target="_blank" rel="noopener">match</a>方法来将预期和输出做对比。</p></blockquote><p>在终端执行<code>npm test</code>，紧张地希望能跑通也许是人生的第一个测试用例。结果我得到如下关键的报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">● Post todolist failed if not give the params</span><br><span class="line"></span><br><span class="line">   TypeError: app.address is not a function</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">● Post todolist failed if not give the params</span><br><span class="line"></span><br><span class="line">   TypeError: _app2.default.close is not a function</span><br></pre></td></tr></table></figure><p>这是怎么回事？说明我们import进来的server看来并没有close、address等方法。原因在于我们在<code>app.js</code>里最后一句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app</span><br></pre></td></tr></table></figure><p>此处export出来的是一个对象。但我们实际上需要一个function。</p><p>在谷歌的过程中，找到两种解决办法：</p><blockquote><p>参考<a href="https://segmentfault.com/q/1010000006906863" target="_blank" rel="noopener">解决办法1</a>和<a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">解决办法2</a></p></blockquote><p><strong>1.</strong> 修改<code>app.js</code></p><p>将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.listen(<span class="number">8889</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in 8889`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app.listen(<span class="number">8889</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in 8889`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>即可。</p><p><strong>2.</strong> 修改你的test文件：</p><p>在里要用到<code>server</code>的地方都改为<code>server.callback()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> request(server.callback())</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br></pre></td></tr></table></figure><p>我采用的是第一种做法。</p><p>改完之后，顺利通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PASS  test/sever/user.test.js</span><br><span class="line"> ✓ Failed to login if typing Molunerfinn &amp; 1234 (248ms)</span><br></pre></td></tr></table></figure><p>然而此时发现一个问题，为何测试结束了，jest还占用着终端进程呢？我想要的是测试完jest就自动退出了。查了一下文档，发现它的cli有个参数<code>--forceExit</code>能解决这个问题，于是就把<code>package.json</code>里的<code>test</code>命令修改一下（后续我们还将修改几次）加上这个参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest --forceExit"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再测试一遍，发现没问题。这样一来我们就可以继续依葫芦画瓢，把<code>auth/*</code>这个路由的功能都测试一遍：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/routes/auth.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> auth <span class="keyword">from</span> <span class="string">'../controllers/user.js'</span></span><br><span class="line"><span class="keyword">import</span> koaRouter <span class="keyword">from</span> <span class="string">'koa-router'</span></span><br><span class="line"><span class="keyword">const</span> router = koaRouter()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>, auth.getUserInfo) <span class="comment">// 定义url的参数是id</span></span><br><span class="line">router.post(<span class="string">'/user'</span>, auth.postUserAuth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>测试用例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Failed to login if typing Molunerfinn &amp; 1234'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Successed to login if typing Molunerfinn &amp; 123'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'123'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Failed to login if typing MARK &amp; 123'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'MARK'</span>,</span><br><span class="line">                      password: <span class="string">'123'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.info).toBe(<span class="string">'用户不存在！'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting the user info is null if the url is /auth/user/10'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/auth/user/10'</span>)</span><br><span class="line">  expect(response.body).toEqual(&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting user info successfully if the url is /auth/user/2'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/auth/user/2'</span>)</span><br><span class="line">  expect(response.body.user_name).toBe(<span class="string">'molunerfinn'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>都很简洁易懂，看描述+预期你就能知道在测试什么了。不过需要注意一点的是，我们用到了<code>toBe()</code>和<code>toEqual()</code>两个方法。乍一看好像没有区别。实际上有大区别。</p><p>简单来说，<code>toBe()</code>适合<code>===</code>这个判断条件。比如<code>1 === 1</code>，<code>&#39;hello&#39; === &#39;hello&#39;</code>。但是<code>[1] === [1]</code>是错的。具体原因不多说，js的基础。所以要判断比如数组或者对象相等的话需要用<code>toEqual()</code>这个方法。</p><p>OK，接下去我们开始测试<code>api/*</code>这个路由。</p><p>在<code>test</code>目录下创建一个叫做<code>todolits.spec.js</code>的文件：</p><p>有了上一个测试的经验，测试这个其实也不会有多大的问题。首先我们来测试一下当我们没有携带上JSON WEB TOKEN的header的话，服务端是不是返回401错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting todolist should return 401 if not set the JWT'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">  expect(response.status).toBe(<span class="number">401</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一切看似没问题，但是运行的时候却报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.error node_modules/jest-jasmine2/build/jasmine/Env.js:194</span><br><span class="line">    Unhandled error</span><br><span class="line"></span><br><span class="line">console.error node_modules/jest-jasmine2/build/jasmine/Env.js:195</span><br><span class="line">  Error: listen EADDRINUSE :::8888</span><br><span class="line">      at Object._errnoException (util.js:1024:11)</span><br><span class="line">      at _exceptionWithHostPort (util.js:1046:20)</span><br><span class="line">      at Server.setupListenHandle [as _listen2] (net.js:1351:14)</span><br><span class="line">      at listenInCluster (net.js:1392:12)</span><br><span class="line">      at Server.listen (net.js:1476:7)</span><br><span class="line">      at Application.listen (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/koa/lib/application.js:64:26)</span><br><span class="line">      at Object.&lt;anonymous&gt; (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/app.js:60:5)</span><br><span class="line">      at Runtime._execModule (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:520:13)</span><br><span class="line">      at Runtime.requireModule (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:332:14)</span><br><span class="line">      at Runtime.requireModuleOrMock (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:408:19)</span><br></pre></td></tr></table></figure><p>看来是因为同时运行了两个Koa实例导致了监听端口的冲突。所以我们需要让Jest按顺序执行。查阅官方文档，发现了<a href="http://facebook.github.io/jest/docs/en/cli.html#runinband" target="_blank" rel="noopener">runInBand</a>这个参数正是我们想要的。</p><p>所以修改<code>package.json</code>里的<code>test</code>命令如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest --forceExit --runInBand"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再次运行，成功通过！</p><p>接下来遇到一个问题。我们的JWT的token原本是登录成功后生成并派发给前端的。如今我们测试api的时候并没有经过登录那一步。所以要测试的时候要用的token的话，我觉得有两种办法：</p><ol><li>增加测试的时候的api接口，不需要经过<code>koa-jwt</code>的验证。但是这种方法对项目有入侵性的影响，如果有的时候我们需要从token获取信息的话就有问题了。</li><li>后端预先生成一个合法的token，然后测试的时候用上这个测试的token即可。不过这种办法的话就需要保证token不能泄露。</li></ol><p>我采用第二种办法。为了读者使用方便我是预先生成一个token然后用一个变量存起来的。（真正的开发环境下应对将测试的token放置在项目环境变量.env中）</p><p>接下来我们测试一下数据库的四大操作：增删改查。不过我们为了一次性将这四个接口都测试一遍可以按照这个顺序：增查改删。其实就是先增加一个todo，然后查找的时候将id记录下来。随后可以用这个id进行更新和删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> token = <span class="string">'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoibW9sdW5lcmZpbm4iLCJpZCI6MiwiaWF0IjoxNTA5ODAwNTg2fQ.JHHqSDNUgg9YAFGWtD0m3mYc9-XR3Gpw9gkZQXPSavM'</span> <span class="comment">// 预先生成的token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todoId = <span class="literal">null</span> <span class="comment">// 用来存放测试生成的todo的id</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting todolist should return 401 if not set the JWT'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">  expect(response.status).toBe(<span class="number">401</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">test(<span class="string">'Created todolist successfully if set the JWT &amp; correct user'</span>, <span class="keyword">async</span> () =&gt; &#123; </span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/api/todolist'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      status: <span class="literal">false</span>,</span><br><span class="line">                      content: <span class="string">'来自测试'</span>,</span><br><span class="line">                      id: <span class="number">2</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token) <span class="comment">// header处加入token验证</span></span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">test(<span class="string">'Getting todolist successfully if set the JWT &amp; correct user'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  response.body.result.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.content === <span class="string">'来自测试'</span>) todoId = item.id <span class="comment">// 获取id</span></span><br><span class="line">  &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">test(<span class="string">'Updated todolist successfully if set the JWT &amp; correct todoId'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .put(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>/0`</span>) <span class="comment">// 拿id去更新</span></span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">test(<span class="string">'Removed todolist successfully if set the JWT &amp; correct todoId'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .delete(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>`</span>)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对照着api的4大接口，我们已经将它们都测试了一遍。那是不是我们对于服务端的测试已经结束了呢？其实不是的。要想保证后端api的健壮性，我们得将很多情况都考虑到。但是人为的去排查每个条件、语句什么的必然过于繁琐和机械。于是我们需要一个指标来帮我们确保测试的全面性。这就是测试覆盖率了。</p><h3 id="后端api测试覆盖率"><a href="#后端api测试覆盖率" class="headerlink" title="后端api测试覆盖率"></a>后端api测试覆盖率</h3><p>上面说过，Jest是自带了测试覆盖率功能的（其实就是基于<a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a>这个工具来生成测试覆盖率的）。要如何开启呢？这里我还走了不少坑。</p><p>通过阅读官方的<a href="http://facebook.github.io/jest/docs/en/configuration.html" target="_blank" rel="noopener">配置文档</a>，我确定了几个需要开启的参数：</p><ol><li>coverageDirectory，指定输出测试覆盖率报告的目录</li><li>coverageReporters，指定输出的测试覆盖率报告的形式，具体可以参考istanbul的<a href="https://istanbul.js.org/docs/advanced/alternative-reporters/" target="_blank" rel="noopener">说明</a></li><li>collectCoverage，是否要收集覆盖率信息，当然是。</li><li>mapCoverage，由于我们的代码经过babel-jest转译，所以需要开启sourcemap来让Jest能够把测试结果定位到源代码上而不是编译的代码上。</li><li>verbose，用于显示每个测试用例的通过与否。</li></ol><p>于是我们需要在<code>package.json</code>里配置一个Jest字段（不是在scripts字段里配置，而是和scripts在同一级的字段），来配置Jest。</p><p>配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov", // 会生成lcov测试结果以及HTML格式的漂亮的测试覆盖率报告</span><br><span class="line">    "text" // 会在命令行界面输出简单的测试报告</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再进行一遍测试，可以看到在终端里已经输出了简易的测试报告总结：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flc95bhjwmj20y80lijus.jpg" alt=""></p><p>从中我们能看到一些字段是100%，而一些不是100%。最后一列<code>Uncovered Lines</code>就是告诉我们，测试里没有覆盖到的代码行。为了更直观地看到测试的结果报告，可以到项目的根目录下找到一个<code>coverage</code>的目录，在<code>lcov-report</code>目录里有个<code>index.html</code>就是输出的html报告。打开来看看：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld7tv6c91j21z20h0n0f.jpg" alt=""></p><p>首页是个概览，跟命令行里输出的内容差不多。不过我们可以往深了看，可以点击左侧的File提供的目录：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8bgzj3gj21z20hotc4.jpg" alt=""></p><p>然后我们可以看到没有被覆盖到代码行数（50）以及有一个函数没有被测试到：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8erd8g6j215w05a757.jpg" alt=""></p><p>通常我们没有测试到的函数也伴随着代码行数没有被测试到。我们可以看到在本例里，app的<code>error</code>事件没有被触发过。想想也是的，我们的测试都是建立在合法的api请求的基础上的。所以自然不会触发<code>error</code>事件。因此我们需要写一个测试用例来测试这个<code>.on(&#39;error&#39;)</code>的函数。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8fyapefj21z20fy0yc.jpg" alt=""></p><p>通常这样的测试用例并不是特别好写。不过好在我们可以尝试去触发server端的错误，对于本例来说，如果向服务端创建一个todo的时候，没有附上相应的信息（id、status、content），就无法创建相应的todo，会触发错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/models/todolist.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createTodolist = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> Todolist.create(&#123;</span><br><span class="line">    user_id: data.id,</span><br><span class="line">    content: data.content,</span><br><span class="line">    status: data.status</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是server端创建todo的相关函数，下面是针对它的错误进行的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/server/todolist.spec.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">test(<span class="string">'Failed to create a todo if not give the params'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">            .post(<span class="string">'/api/todolist'</span>)</span><br><span class="line">            .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token) <span class="comment">// 不发送创建的参数</span></span><br><span class="line">  expect(response.status).toBe(<span class="number">500</span>) <span class="comment">// 服务端报500错误</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再进行测试，发现之前对于app.js的相关测试都已经是100%了。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8s0m0g5j20xy0lq41t.jpg" alt=""></p><p>不过<code>controllers/todolist.js</code>里还是有未测试到的行数34，以及我们可以看到<code>% Branch</code>这列的数字显示的是50而不是100。<code>Branch</code>的意思就是分支测试。什么是分支测试呢？简单来说就是你的条件语句测试。比如一个<code>if...else</code>语句，如果测试用例只跑过<code>if</code>的条件，而没有跑过<code>else</code>的条件，那么<code>Branch</code>的测试就不完整。让我们来看看是什么条件没有测试到？</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8yzgta5j214w0b6di6.jpg" alt=""></p><p>可以看到是个三元表达式并没有测试完整。（三元表达式也算分支）我们测试了0的情况，但是没有测试非零的情况，所以再写一个非零的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Failed to update todolist  if not update the status of todolist'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .put(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>/1`</span>) <span class="comment">// &lt;- 这里最后一个参数改成了1</span></span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再次跑测试：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld977icalj20x40lmdj2.jpg" alt=""></p><p>哈，成功做到了100%测试覆盖率！</p><h3 id="端口占用和环境变量的引入"><a href="#端口占用和环境变量的引入" class="headerlink" title="端口占用和环境变量的引入"></a>端口占用和环境变量的引入</h3><p>虽然做到了100%测试覆盖率，但是有一个问题却是不容忽视的。那就是我们现在测试环境和开发环境下的服务端监听的端口是一致的。意味着你不能在开发环境下测试你的代码。比如你写完一个api之后马上要写一个测试用例的时候，如果测试环境和开发环境的服务端监听的端口一致的话，测试的时候就会因为端口被占用而无法被监听到。</p><p>所以我们需要指定一下测试环境下的端口，让它和开发乃至生产环境的端口不一样。我一开始想法很简单，指定一下<code>NODE_ENV=test</code>的时候用8888端口，开发环境下用8889端口。在<code>app.js</code>里就是这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> port = process.env.NODE_ENV === <span class="string">'test'</span> ? <span class="number">8888</span> : <span class="number">8889</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app.listen(port, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in <span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下去就遇到了两个问题：</p><ol><li>需要解决跨平台env设置</li><li>这样设置的话一旦在测试环境下，对于port这句话，<code>Branch</code>测试是无法完全通过的——因为始终是在test环境下，无法运行到<code>port = 8889</code>那个条件</li></ol><h4 id="跨平台env设置"><a href="#跨平台env设置" class="headerlink" title="跨平台env设置"></a>跨平台env设置</h4><p>跨平台env主要涉及到windows、linux和macOS。要在三个平台在测试的时候都跑着<code>NODE_ENV=test</code>的话，我们需要借助<a href="https://github.com/kentcdodds/cross-env" target="_blank" rel="noopener">cross-env</a>来帮助我们。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add cross-env -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure><p>然后在<code>package.json</code>里修改<code>test</code>的命令如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "cross-env NODE_ENV=test jest --forceExit --runInBand"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样就能在后端代码里，通过<code>process.env.NODE_ENV</code>这个变量访问到<code>test</code>这个值。这样就解决了第一个问题。</p><h4 id="端口分离并保证测试覆盖率"><a href="#端口分离并保证测试覆盖率" class="headerlink" title="端口分离并保证测试覆盖率"></a>端口分离并保证测试覆盖率</h4><p>目前为止，我们已经能够解决测试环境和开发环境的监听端口一致的问题了。不过却带来了测试覆盖率不全的问题。</p><p>为此我找到两种解决办法：</p><ol><li>通过istanbul特殊的<a href="https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md" target="_blank" rel="noopener"><code>ignore</code>注释</a>来忽略测试环境下的一些测试分支条件</li><li>通过配置环境变量文件，不同环境下采用不同的环境变量文件</li></ol><p>第一种方法很简单，在需要忽略的地方，输入<code>/* istanbul ignore next */</code>或<code>/* istanbul ignore &lt;word&gt;[non-word] [optional-docs] */</code>等语法忽略代码。不过考虑到这是涉及到测试环境和开发环境下的环境变量问题，如果不仅仅是端口问题的话，那么就不如采用第二种方法来得更加优雅。（比如开发环境和测试环境的数据库用户和密码都不一样的话，还是需要写在对应的环境变量的）</p><p>此时我们需要另外一个很常用的库<a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotenv</a>，它能默认读取<code>.env</code>文件里的值，让我们的项目可以通过不同的<code>.env</code>文件来应对不同的环境要求。</p><p>步骤如下：</p><h5 id="1-安装dotenv"><a href="#1-安装dotenv" class="headerlink" title="1. 安装dotenv"></a>1. 安装dotenv</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add dotenv</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install dotenv --save</span><br></pre></td></tr></table></figure><h5 id="2-在项目根目录下创建-env和-env-test两个文件，分别应用于开发环境和测试环境"><a href="#2-在项目根目录下创建-env和-env-test两个文件，分别应用于开发环境和测试环境" class="headerlink" title="2. 在项目根目录下创建.env和.env.test两个文件，分别应用于开发环境和测试环境"></a>2. 在项目根目录下创建<code>.env</code>和<code>.env.test</code>两个文件，分别应用于开发环境和测试环境</h5><p>// .env</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DB_USER=xxxx <span class="comment"># 数据库用户</span></span><br><span class="line">DB_PASSWORD=yyyy <span class="comment"># 数据库密码</span></span><br><span class="line">PORT=8889 <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure><p>// .env.test</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DB_USER=xxxx <span class="comment"># 数据库用户</span></span><br><span class="line">DB_PASSWORD=yyyy <span class="comment"># 数据库密码</span></span><br><span class="line">PORT=8888 <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure><h5 id="3-创建一个env-js文件，用于不同环境下采用不同的环境变量。代码如下："><a href="#3-创建一个env-js文件，用于不同环境下采用不同的环境变量。代码如下：" class="headerlink" title="3. 创建一个env.js文件，用于不同环境下采用不同的环境变量。代码如下："></a>3. 创建一个<code>env.js</code>文件，用于不同环境下采用不同的环境变量。代码如下：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dotenv <span class="keyword">from</span> <span class="string">'dotenv'</span></span><br><span class="line"><span class="keyword">let</span> path = process.env.NODE_ENV === <span class="string">'test'</span> ? <span class="string">'.env.test'</span> : <span class="string">'.env'</span></span><br><span class="line">dotenv.config(&#123;path, <span class="attr">silent</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="4-在app-js开头引入env"><a href="#4-在app-js开头引入env" class="headerlink" title="4. 在app.js开头引入env"></a>4. 在app.js开头引入env</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./env'</span></span><br></pre></td></tr></table></figure><p>然后把原本那句port的话改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> port = process.env.PORT</span><br></pre></td></tr></table></figure><p>再把数据库连接的用户密码也用环境变量来代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/config/db.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../../env'</span></span><br><span class="line"><span class="keyword">import</span> Sequelize <span class="keyword">from</span> <span class="string">'sequelize'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todolist = <span class="keyword">new</span> Sequelize(<span class="string">`mysql://<span class="subst">$&#123;process.env.DB_USER&#125;</span>:<span class="subst">$&#123;process.env.DB_PASSWORD&#125;</span>@localhost/todolist`</span>, &#123;</span><br><span class="line">  define: &#123;</span><br><span class="line">    timestamps: <span class="literal">false</span> <span class="comment">// 取消Sequelzie自动给数据表加入时间戳（createdAt以及updatedAt）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>不过需要注意的是，.env和.env.js文件都不应该纳入git版本库，因为都是比较重要的内容。</strong></p><p>这样就能实现不同环境下用不同的变量了。慢着！这样不是还没有解决问题吗？<code>env.js</code>里的条件还是无法被测试覆盖啊——你肯定有这样的疑问。不用紧张，现在给出解决办法——给Jest指定收集测试覆盖率的范围：</p><p>修改<code>package.json</code>里<code>jest</code>字段如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov",</span><br><span class="line">    <span class="string">"text"</span></span><br><span class="line">  ],</span><br><span class="line">  "collectCoverageFrom": [ // 指定Jest收集测试覆盖率的范围</span><br><span class="line">    "!env.js", // 排除env.js</span><br><span class="line">    "server/**/*.js",</span><br><span class="line">    <span class="string">"app.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这些工作之后，再跑一次测试，一次通过：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld977icalj20x40lmdj2.jpg" alt=""></p><p>这样我们就完成了后端的api测试。完成了100%测试覆盖率。下面我们可以开始测试Vue的前端项目了。</p><h2 id="Vue前端测试"><a href="#Vue前端测试" class="headerlink" title="Vue前端测试"></a>Vue前端测试</h2><p>Vue的前端测试我就要推荐来自官方的<a href="https://github.com/vuejs/vue-test-utils" target="_blank" rel="noopener">vue-test-utils</a>了。当然前端测试大致分成了单元测试（Unit test)和端对端测试(e2e test)，由于端对端的测试对于测试环境的要求比较严苛，而且测试起来比较繁琐，而且官方给出的测试框架是单元测试框架，因此本文对于Vue的前端测试也仅介绍配合官方工具的单元测试。</p><p>在Vue的前端测试中我们能够了解到jest的mock、snapshot等特性和用法和vue-test-utils提供的mount、shallow、setData等一系列操作。</p><h3 id="安装vue-test-utils"><a href="#安装vue-test-utils" class="headerlink" title="安装vue-test-utils"></a>安装vue-test-utils</h3><p>根据官网的<a href="https://vue-test-utils.vuejs.org/en/guides/testing-SFCs-with-jest.html" target="_blank" rel="noopener">介绍</a>我们需要安装如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-test-utils vue-jest jest-serializer-vue -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install vue-test-utils vue-jest jest-serializer-vue --save-dev</span><br></pre></td></tr></table></figure><p>其中，<code>vue-test-utils</code>是最关键的测试框架。提供了一系列对于Vue组件的测试操作。（下面会提到）。<code>vue-jest</code>用于处理<code>*.vue</code>的文件，<code>jest-serializer-vue</code>用于快照测试提供快照序列化。</p><h3 id="配置vue-test-utils以及jest"><a href="#配置vue-test-utils以及jest" class="headerlink" title="配置vue-test-utils以及jest"></a>配置vue-test-utils以及jest</h3><p><strong>1.</strong> 修改<code>.babelrc</code></p><p>在<code>test</code>的<code>env</code>里增加或修改<code>presets</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;],</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-runtime"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"comments"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: &#123;</span><br><span class="line">      <span class="attr">"plugins"</span>: [<span class="string">"transform-es2015-modules-commonjs"</span>],</span><br><span class="line">      <span class="attr">"presets"</span>: [</span><br><span class="line">        [<span class="string">"env"</span>, &#123; <span class="attr">"targets"</span>: &#123; <span class="attr">"node"</span>: <span class="string">"current"</span> &#125;&#125;] // 增加或修改</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 修改<code>package.json</code>里的jest配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "moduleFileExtensions": [</span><br><span class="line">    <span class="string">"js"</span></span><br><span class="line">  ],</span><br><span class="line">  "transform": &#123; // 增加transform转换</span><br><span class="line">    ".*\\.(vue)$": "&lt;rootDir&gt;/node_modules/vue-jest",</span><br><span class="line">    "^.+\\.js$": "&lt;rootDir&gt;/node_modules/babel-jest"</span><br><span class="line">  &#125;,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov",</span><br><span class="line">    <span class="string">"text"</span></span><br><span class="line">  ],</span><br><span class="line">  "moduleNameMapper": &#123; // 处理webpack alias</span><br><span class="line">    "@/(.*)$": "&lt;rootDir&gt;/src/$1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "snapshotSerializers": [ // 配置快照测试</span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/node_modules/jest-serializer-vue"</span></span><br><span class="line">  ],</span><br><span class="line">  "collectCoverageFrom": [</span><br><span class="line">    "!env.js",</span><br><span class="line">    "server/**/*.js",</span><br><span class="line">    <span class="string">"app.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端单元测试的一些说明"><a href="#前端单元测试的一些说明" class="headerlink" title="前端单元测试的一些说明"></a>前端单元测试的一些说明</h3><p>关于vue-test-utils和Jest的配合测试，我推荐可以查看这个系列的<a href="https://alexjoverm.github.io/2017/08/21/Write-the-first-Vue-js-Component-Unit-Test-in-Jest/" target="_blank" rel="noopener">文章</a>，讲解很清晰。</p><p>接着，明确一下前端单元测试都需要测试些什么东西。引用<code>vue-test-utils</code>的说法：</p><blockquote><p>对于 UI 组件来说，我们不推荐一味追求行级覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。</p></blockquote><blockquote><p>取而代之的是，我们推荐把测试撰写为断言你的组件的公共接口，并在一个黑盒内部处理它。一个简单的测试用例将会断言一些输入 (用户的交互或 prop 的改变) 提供给某组件之后是否导致预期结果 (渲染结果或触发自定义事件)。</p></blockquote><blockquote><p>比如，对于每次点击按钮都会将计数加一的 Counter 组件来说，其测试用例将会模拟点击并断言渲染结果会加 1。该测试并没有关注 Counter 如何递增数值，而只关注其输入和输出。</p></blockquote><blockquote><p>该提议的好处在于，即便该组件的内部实现已经随时间发生了改变，只要你的组件的公共接口始终保持一致，测试就可以通过。</p></blockquote><p>所以，相对于后端api测试看重测试覆盖率而言，前端的单元测试是不必一味追求测试覆盖率的。（当然你要想达到100%测试覆盖率也是没问题的，只不过如果要达到这样的效果你需要撰写非常多繁琐的测试用例，占用太多时间，得不偿失。）替代地，我们只需要回归测试的本源：给定输入，我只关心输出，不考虑内部如何实现。只要能覆盖到和用户相关的操作，能测试到页面的功能即可。</p><p>和之前类似，我们在<code>test/client</code>目录下书写我们的测试用例。对于Vue的单元测试来说，我们就是针对<code>*.vue</code>文件进行测试了。由于本例里的<code>app.vue</code>无实际意义，所以就测试<code>Login.vue</code>和<code>Todolist.vue</code>即可。</p><p>运用<code>vue-test-utils</code>如何来进行测试呢？简单来说，我们需要的做的就是用<code>vue-test-utils</code>提供的<code>mount</code>或者<code>shallow</code>方法将组件在后端渲染出来，然后通过一些诸如<code>setData</code>，<code>propsData</code>、<code>setMethods</code>等方法模拟用户的操作或者模拟我们的测试条件，最后再用jest提供的<code>expect</code>断言来对预期的结果进行判断。这里的预期就很丰富了。我们可以通过判断事件是否触发、元素是否存在、数据是否正确、方法是否被调用等等来对我们的组件进行比较全面的测试。下面的例子里也会比较完整地介绍它们。</p><h3 id="Login-vue的测试"><a href="#Login-vue的测试" class="headerlink" title="Login.vue的测试"></a>Login.vue的测试</h3><p>创建一个<code>login.spec.js</code>文件。</p><p>首先我们来测试页面里是否有两个输入框和一个登录按钮。根据官方文档，我首先注意到了<a href="https://vue-test-utils.vuejs.org/en/guides/common-tips.html#shallow-rendering" target="_blank" rel="noopener">shallow rendering</a>，它的说明是，对于某个组件而言，只渲染这个组件本身，而不渲染它的子组件，让测试速度提高，也符合单元测试的理念。看着好像很不错的样子，拿过来用。</p><h4 id="查找元素测试"><a href="#查找元素测试" class="headerlink" title="查找元素测试"></a>查找元素测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = shallow(Login) <span class="comment">// 每次测试前确保我们的测试实例都是是干净完整的。返回一个wrapper对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Should have two input &amp; one button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = wrapper.findAll(<span class="string">'.el-input'</span>) <span class="comment">// 通过findAll来查找dom或者vue实例</span></span><br><span class="line">  <span class="keyword">const</span> loginButton = wrapper.find(<span class="string">'.el-button'</span>) <span class="comment">// 通过find查找元素</span></span><br><span class="line">  expect(inputs.length).toBe(<span class="number">2</span>) <span class="comment">// 应该有两个输入框</span></span><br><span class="line">  expect(loginButton).toBeTruthy() <span class="comment">// 应该有一个登录按钮。 只要断言条件不为空或这false，toBeTruthy就能通过。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一切看起来很正常。运行测试。结果报错了。报错是<code>input.length</code>并不等于2。通过debug断点查看，确实并没有找到元素。</p><p>这是怎么回事？哦对，我想起来，形如<code>el-input</code>、<code>el-button</code>其实也相当于是子组件啊，所以<code>shallow</code>并不能将它们渲染出来。在这种情况下，用<code>shallow</code>来渲染就不合适了。所以还是需要用<code>mount</code>来渲染，它会将页面渲染成它应该有的样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Login) <span class="comment">// 每次测试前确保我们的测试实例都是是干净完整的。返回一个wrapper对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Should have two input &amp; one button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = wrapper.findAll(<span class="string">'.el-input'</span>) <span class="comment">// 通过findAll来查找dom或者vue实例</span></span><br><span class="line">  <span class="keyword">const</span> loginButton = wrapper.find(<span class="string">'.el-button'</span>) <span class="comment">// 通过find查找元素</span></span><br><span class="line">  expect(inputs.length).toBe(<span class="number">2</span>) <span class="comment">// 应该有两个输入框</span></span><br><span class="line">  expect(loginButton).toBeTruthy() <span class="comment">// 应该有一个登录按钮。 只要断言条件不为空或这false，toBeTruthy就能通过。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>测试，还是报错！还是没有找到它们。为什么呢？再想想。应该是我们并没有将<code>element-ui</code>引入我们的测试里。因为<code>.el-input</code>实际上是<code>element-ui</code>的一个组件，如果没有引入它，vue自然无法将一个<code>el-input</code>渲染成<code>&lt;div class=&quot;el-input&quot;&gt;&lt;input&gt;&lt;/div&gt;</code>这样的形式。想通了就好说了，把它引进来。因为我们的项目里在<code>webpack</code>环境下是有一个<code>main.js</code>作为入口文件的，在测试里可没有这个东西。所以Vue自然也不知道你测试里用到了什么依赖，需要我们单独引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>再次运行测试，通过！</p><h4 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h4><p>接下来，使用Jest内置的一个特别棒的特性：快照（snapshot）。它能够将某个状态下的html结构以一个快照文件的形式存储下来，以后每次运行快照测试的时候如果发现跟之前的快照测试的结果不一致，测试就无法通过。</p><p>当然如果是以后页面确实需要发生改变，快照需要更新，那么只需要在执行jest的时候增加一个<code>-u</code>的参数，就能实现快照的更新。</p><p>说完了原理来实践一下。对于登录页，实际上我们只需要确保html结构没问题那么所有必要的元素自然就存在。因此快照测试写起来特别方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should have the expected html structure'</span>, () =&gt; &#123;</span><br><span class="line">  expect(wrapper.element).toMatchSnapshot() <span class="comment">// 调用toMatchSnapshot来比对快照</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果是第一次进行快照测试，那么它会在你的测试文件所在目录下新建一个<code>__snapshots__</code>的目录存放快照文件。上面的测试就生成了一个<code>login.spec.js.snap</code>的文件，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><br><span class="line"></span><br><span class="line">exports[`Should have the expected html structure 1`] = `</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"el-row content"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-col el-col-24 el-col-xs-24 el-col-sm-6 el-col-sm-offset-9"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"title"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      </span><br><span class="line">     欢迎登录</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"el-row"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-input"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">          <span class="attr">autocomplete</span>=<span class="string">"off"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"账号"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-input"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">          <span class="attr">autocomplete</span>=<span class="string">"off"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"密码"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-button el-button--primary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">          登录</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>可以看到它将整个html结构以快照的形式保存下来了。快照测试能确保我们的前端页面结构的完整性和稳定性。</p><h4 id="methods测试"><a href="#methods测试" class="headerlink" title="methods测试"></a>methods测试</h4><p>很多时候我们需要测试在某些情况下，Vue中的一些methods能否被触发。比如本例里的，我们点击登录按钮应对要触发<code>loginToDo</code>这个方法。于是就涉及到了<code>methods</code>的测试，这个时候<code>vue-test-utils</code>提供的<code>setMethods</code>这个方法就很有用了。我们可以通过设置（覆盖）<code>loginToDo</code>这个方法，来查看它是否被触发了。</p><blockquote><p>注意，一旦setMethods了某个方法，那么在某个test()内部，这个方法原本的作用将完全被你的新function覆盖。包括这个Vue实例里其他methods通过<code>this.xxx()</code>方式调用也一样。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'loginToDo should be called after clicking the button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stub = jest.fn() <span class="comment">// 伪造一个jest的mock funciton</span></span><br><span class="line">  wrapper.setMethods(&#123; <span class="attr">loginToDo</span>: stub &#125;) <span class="comment">// setMethods将loginToDo这个方法覆写</span></span><br><span class="line">  wrapper.find(<span class="string">'.el-button'</span>).trigger(<span class="string">'click'</span>) <span class="comment">// 对button触发一个click事件</span></span><br><span class="line">  expect(stub).toBeCalled() <span class="comment">// 查看loginToDo是否被调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意到这里我们用到了<code>jest.fn</code>这个方法，这个在下节会详细说明。此处你只需要明白这个是jest提供的，可以用来检测是否被调用的方法。</p><h4 id="mock方法测试"><a href="#mock方法测试" class="headerlink" title="mock方法测试"></a>mock方法测试</h4><p>接下去就是对登录这个功能的测试了。由于我们之前把Koa的后端api进行了测试，所以我们在前端测试中，可以默认后端的api接口都是返回正确的结果的。（这也是我们先进行了Koa端测试的原因，保证了后端api的健壮性回到前端测试的时候就能很轻松）</p><p>虽然道理是说得通的，但是我们如何来默认、或者说“伪造”我们的api请求，以及返回的数据呢？这个时候就需要用上Jest一个非常有用的功能<code>mock</code>了。可以说<code>mock</code>这个词对很多做前端的朋友来说，不是很陌生。在没有后端，或者后端功能还未完成的时候，我们可以通过api的mock来实现伪造请求和数据。</p><p>Jest的mock也是同理，不过它更厉害的一点是，它能伪造库。比如我们接下去要用的HTTP请求库<code>axios</code>。对于我们的页面来说，登录只需要发送post请求，判断返回的<code>success</code>是否是<code>true</code>即可。我们先来mock一下<code>axios</code>以及它的<code>post</code>请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>然后我们可以把axios引入我们的项目了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line"></span><br><span class="line">jest.mock(....)</span><br></pre></td></tr></table></figure><p>等会，你肯定会提出疑问，<code>jest.mock()</code>方法写在了<code>import axios from &#39;axios&#39;</code>下面，那么不就意味着<code>axios</code>是从<code>node_modules</code>里引入的吗？其实不是的，<code>jest.mock()</code>会实现函数提升，也就是实际上上面的代码其实和下面的是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(....)</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 这里的axios是来自jest.mock()里的axios</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure><p>看起来甚至有些<code>var</code>的变量提升的味道。</p><p>不过这样的好处是很明显的，我们可以在不破坏<code>eslint</code>的规则的情况下采用第一种的写法而达到一样的目的。</p><p>然后你还会注意到我们用到了<code>jest.fn()</code>的方法，它是jest的mock方法里很重要的一部分。它本身是一个<code>mock function</code>。通过它能够实现方法调用的追踪以及后面会说到的能够实现创建复杂行为的模拟功能。</p><p>继续我们没写完的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Failed to login if not typing the correct password'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    account: <span class="string">'molunerfinn'</span>,</span><br><span class="line">    password: <span class="string">'1234'</span></span><br><span class="line">  &#125;) <span class="comment">// 模拟用户输入数据</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wrapper.vm.loginToDo() <span class="comment">// 模拟异步请求的效果</span></span><br><span class="line">  expect(result.data.success).toBe(<span class="literal">false</span>) <span class="comment">// 期望返回的数据里success是false</span></span><br><span class="line">  expect(result.data.info).toBe(<span class="string">'密码错误！'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们通过<code>setData</code>来模拟用户在两个input框内输入了数据。然后通过<code>wrapper.vm.loginToDo()</code>来显式调用<code>loginTodo</code>的方法。由于我们返回的是一个<code>Promise</code>对象，所以可以用<code>async await</code>将resolve里的数据拿出来。然后测试是否和预期相符。我们这次是测试了输入错误的情况，测试通过，没有问题。那如果我接下去要再测试用户密码都通过的测试怎么办？我们<code>mock</code>的<code>axios</code>的<code>post</code>方法只有一个，难不成还能一个方法输出多种结果？下一节来详细说明这个问题。</p><h4 id="创建复杂行为测试"><a href="#创建复杂行为测试" class="headerlink" title="创建复杂行为测试"></a>创建复杂行为测试</h4><p>回顾一下我们的mock写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>可以看到，采用这种写法的话，post请求始终只能返回一种结果。如何做到既能<code>mock</code>这个<code>post</code>方法又能实现多种结果测试？接下去就要用到Jest另一个杀手锏的方法：<a href="https://facebook.github.io/jest/docs/en/mock-functions.html#mock-implementations" target="_blank" rel="noopener">mockImplementationOnce</a>。官方的示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'default'</span>)</span><br><span class="line">  .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'first call'</span>)</span><br><span class="line">  .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'second call'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());</span><br><span class="line"><span class="comment">// &gt; 'first call', 'second call', 'default', 'default'</span></span><br></pre></td></tr></table></figure><p>4次调用同一个方法却能给出不同的运行结果。这正是我们想要的。</p><p>于是在我们测试登录成功这个方法的时候我们需要改写一下我们对<code>axios</code>的mock方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn()</span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          data: &#123;</span><br><span class="line">            success: <span class="literal">false</span>,</span><br><span class="line">            info: <span class="string">'用户不存在！'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          data: &#123;</span><br><span class="line">            success: <span class="literal">true</span>,</span><br><span class="line">            token: <span class="string">'xxx'</span> <span class="comment">// 随意返回一个token</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>然后开始写我们的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Succeeded to login if typing the correct account &amp; password'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    account: <span class="string">'molunerfinn'</span>,</span><br><span class="line">    password: <span class="string">'123'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wrapper.vm.loginToDo()</span><br><span class="line">  expect(result.data.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就在我认为跟之前的测试没有什么两样的时候，报错传来了。先来看看当<code>success</code>为true的时候，<code>loginToDo</code>在做什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res.data.success) &#123; <span class="comment">// 如果成功</span></span><br><span class="line">  sessionStorage.setItem(<span class="string">'demo-token'</span>, res.data.token) <span class="comment">// 用sessionStorage把token存下来</span></span><br><span class="line">  <span class="keyword">this</span>.$message(&#123; <span class="comment">// 登录成功，显示提示语</span></span><br><span class="line">    type: <span class="string">'success'</span>,</span><br><span class="line">    message: <span class="string">'登录成功！'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.$router.push(<span class="string">'/todolist'</span>) <span class="comment">// 进入todolist页面，登录成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快我就看到了错误所在：我们的测试环境里并没有<code>sessionStorage</code>这个原本应该在浏览器端的东西。以及我们并没有使用<code>vue-router</code>，所以就无法执行<code>this.$router.push()</code>这个方法。</p><p>关于前者，很容易找到<a href="https://stackoverflow.com/questions/30792076/mocking-sessionstorage-when-using-jestjs" target="_blank" rel="noopener">问题</a>的<a href="https://github.com/letsrock-today/mock-local-storage" target="_blank" rel="noopener">解决办法</a>。</p><p>首先安装一下<code>mock-local-storage</code>这个库（也包括了sessionStorage）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add mock-local-storage -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install mock-local-storage --save-dev</span><br></pre></td></tr></table></figure><p>然后配置一下<code>package.json</code>里的<code>jest</code>参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  // ...</span><br><span class="line">  "setupTestFrameworkScriptFile": "mock-local-storage"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后者，阅读过官方的<a href="https://vue-test-utils.vuejs.org/en/guides/common-tips.html#dealing-with-routing" target="_blank" rel="noopener">建议</a>，我们不应该引入<code>vue-router</code>，这样会破坏我们的单元测试。相应的，我们可以mock它。不过这次是用<code>vue-test-utils</code>自带的<code>mocks</code>特性了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $router = &#123; <span class="comment">// 声明一个$router对象</span></span><br><span class="line">  push: jest.fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Login, &#123;</span><br><span class="line">    mocks: &#123;</span><br><span class="line">      $router <span class="comment">// 在beforeEach钩子里挂载进mount的mocks里。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过这个方式，会把<code>$router</code>这个对象挂载到实例的<code>prototype</code>上，就能实现在组件内部通过<code>this.$router.push()</code>的方式来调用了。</p><p>上述两个问题解决之后，我们的测试也顺利通过了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj15nzsg0j215c06aq4c.jpg" alt=""></p><p>接下去开始测试<code>Todolist.vue</code>这个组件了。</p><h3 id="Todolist-vue的测试"><a href="#Todolist-vue的测试" class="headerlink" title="Todolist.vue的测试"></a>Todolist.vue的测试</h3><h4 id="键盘事件测试以及隐式事件触发"><a href="#键盘事件测试以及隐式事件触发" class="headerlink" title="键盘事件测试以及隐式事件触发"></a>键盘事件测试以及隐式事件触发</h4><p>类似的我们在<code>test/client</code>目录下创建一个叫做<code>todolist.spec.js</code>的文件。</p><p>先把上例中的一些环境先预置进来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Todolist <span class="keyword">from</span> <span class="string">'../../src/components/Todolist.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">jest.mock(...) <span class="comment">// 后续补充</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Todolist)</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    name: <span class="string">'Molunerfinn'</span>, <span class="comment">// 预置数据</span></span><br><span class="line">    id: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先来个简单的，测试数据是否正确：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test 1</span></span><br><span class="line">test(<span class="string">'Should get the right username &amp; id'</span>, () =&gt; &#123;</span><br><span class="line">  expect(wrapper.vm.name).toBe(<span class="string">'Molunerfinn'</span>)</span><br><span class="line">  expect(wrapper.vm.id).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过需要注意的是，<code>todolist</code>这个页面在<code>created</code>阶段就会触发<code>getUserInfo</code>和<code>getTodolist</code>这两个方法，而我们的wrapper是相当于在<code>mounted</code>阶段之后的。所以在我们拿到wrapper的时候，<code>created</code>、<code>mounted</code>等生命周期的钩子其实已经运行了。本例里<code>getUserInfo</code>是从<code>sessionStorage</code>里取值，不涉及ajax请求。但是<code>getTodolist</code>涉及请求，因此需要在jest.mock方法里为其配置一下，否则将会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  get: jest.fn()</span><br><span class="line">        <span class="comment">// for test 1</span></span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          status: <span class="number">200</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            result: []</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>上面说到的<code>getTodolist</code>和<code>getUserInfo</code>就是在测试中需要注意的隐式事件，它们并不受你测试的控制就在组件里触发了。</p><p>接下来开始进行键盘事件测试。其实跟鼠标事件类似，键盘事件的触发也是以事件名来命名的。不过对于一些常见的事件，<code>vue-test-utils</code>里给出了一些别名比如：</p><p><code>enter, tab, delete, esc, space, up, down, left, right</code>。你在书写测试的时候可以直接这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">input.trigger(<span class="string">'keyup.enter'</span>)</span><br></pre></td></tr></table></figure><p>当然如果你需要指定某个键也是可以的，只需要提供keyCode就行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">input.trigger(<span class="string">'keyup'</span>， &#123;</span><br><span class="line">  which: <span class="number">13</span> <span class="comment">// enter的keyCode为13</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>于是我们把这个测试完善一下，这个测试是测试当我在输入框激活的情况下按下回车键能否触发<code>addTodos</code>这个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should trigger addTodos when typing the enter key'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stub = jest.fn()</span><br><span class="line">  wrapper.setMethods(&#123;</span><br><span class="line">    addTodos: stub</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">  input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">  expect(stub).toBeCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没有问题，一次通过。</p><p>注意到我们在实际开发时，在组件上调用原生事件是需要加<code>.native</code>修饰符的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入待办事项"</span> <span class="attr">v-model</span>=<span class="string">"todos"</span> @<span class="attr">keyup.enter.native</span>=<span class="string">"addTodos"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在<code>vue-test-utils</code>里你是可以直接通过原生的<code>keyup.enger</code>来触发的。</p><h4 id="wrapper-update-的使用"><a href="#wrapper-update-的使用" class="headerlink" title="wrapper.update()的使用"></a>wrapper.update()的使用</h4><p>很多时候我们要跟异步打交道。尤其是异步取值，异步赋值，页面异步更新。而对于使用Vue来做的实际开发来说，异步的情况简直太多了。</p><p>还记得<code>nextTick</code>么？很多时候，我们要获取一个变更的数据结果，不能直接通过<code>this.xxx</code>获取，相应的我们需要在<code>this.$nextTick()</code>里获取。在测试里我们也会遇到很多需要异步获取的情况，但是我们不需要<code>nextTick</code>这个办法，相应的我们可以通过<code>async await</code>配合<code>wrapper.update()</code>来实现组件更新。例如下面这个测试添加todo成功的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should add a todo if handle in the right way'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    todos: <span class="string">'Test'</span>,</span><br><span class="line">    stauts: <span class="string">'0'</span>,</span><br><span class="line">    id: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> wrapper.vm.addTodos()</span><br><span class="line">  <span class="keyword">await</span> wrapper.update()</span><br><span class="line">  expect(wrapper.vm.list).toEqual([</span><br><span class="line">    &#123;</span><br><span class="line">      status: <span class="string">'0'</span>,</span><br><span class="line">      content: <span class="string">'Test'</span>,</span><br><span class="line">      id: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在本例中，从进页面到添加一个todo并显示出来需要如下步骤：</p><ol><li>getUserInfo -&gt; getTodolist</li><li>输入todo并敲击回车</li><li>addTodos -&gt; getTodolist</li><li>显示添加的todo</li></ol><p>可以看到总共有3个ajax请求。其中第一步不在我们test()的范围内，2、3、4都是我们能控制的。而addTodos和getTodolist这两个ajax请求带来的就是异步的操作。虽然我们mock方法，但是本质上是返回了Promise对象。所以还是需要用<code>await</code>来等待。</p><blockquote><p>注意你在jest.mock()里要加上相应的mockImplementationOnce的get和post请求。</p></blockquote><p>所以第一步<code>await wrapper.vm.addTodos()</code>就是等待<code>addTodos()</code>的返回。<br>第二步<code>await wrapper.update()</code>实际是在等待<code>getTodolist</code>的返回。</p><p>缺一不可。两步等待之后我们就可以通过断言数据<code>list</code>的方式测试我们是否拿到了返回的todo的信息。</p><p>接下去的就是对todo的一些增删改查的操作，采用的测试方法已经和前文所述相差无几，不再赘述。至此所有的独立测试用例的说明就说完了。看看这测试通过的成就感：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2hpjeprj213606udhc.jpg" alt=""></p><p>不过在测试中我还有关于调试的一些经验想分享一下，配合调试能更好的判断我们的测试的时候发生的不可预知的问题所在。</p><h3 id="用VSCode来调试测试"><a href="#用VSCode来调试测试" class="headerlink" title="用VSCode来调试测试"></a>用VSCode来调试测试</h3><p>由于我自己是使用VSCode来做的开发和调试，所以一些用其他IDE或者编辑器的朋友们可能会有所失望。不过没关系，可以考虑加入VSCode阵营嘛！</p><p>本文撰写的时候采用的nodejs版本为<code>8.9.0</code>，VSCode版本为<code>1.18.0</code>，所以所有的debug测试的配置仅保证适用于目前的环境。其他环境的可能需要自行测试一下，不再多说。</p><p>关于jest的调试的配置如下：（注意配置路径为VScode关于本项目的<code>.vscode/launch.json</code>）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible Node.js debug attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  "version": "0.2.0",</span><br><span class="line">  "configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Debug Jest"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/node_modules/jest-cli/bin/jest.js"</span>,</span><br><span class="line">      <span class="attr">"stopOnEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"--runInBand"</span>,</span><br><span class="line">        <span class="string">"--forceExit"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"runtimeExecutable"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">        <span class="string">"--nolazy"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"env"</span>: &#123;</span><br><span class="line">        <span class="attr">"NODE_ENV"</span>: <span class="string">"test"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"console"</span>: <span class="string">"integratedTerminal"</span>,</span><br><span class="line">      <span class="attr">"sourceMaps"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完上面的配置之后，你可以在<code>DEBUG</code>面板里（不要跟我说你不知道什么是DEBUG面板~）找到名为<code>Debug Jest</code>的选项：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2s0qhxkj20og09kq3p.jpg" alt=""></p><p>然后你可以在你的测试文件里打断点了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2uakvi4j21bk09oq5s.jpg" alt=""></p><p>然后运行debug模式，按那个绿色启动按钮，就能进入DEBUG模式，当运行到断点处就会停下：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2y2hpeaj21fa09u41u.jpg" alt=""></p><p>于是你可以在左侧面板的<code>Local</code>和<code>Closure</code>里找到当前作用域下你所需要的变量值、变量类型等等。充分运用VSCode的debug模式，开发的时候查错和调试的效率都会大大加大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文用了很大的篇幅描述了如何搭建一个Jest测试环境，并在测试过程中不断完善我们的测试环境。讲述了Koa后端测试的方法和测试覆盖率的提高，讲述了Vue前端单元测试环境的搭建以及许多相应的测试实例，以及在测试过程中不停地遇到问题并解决问题。能够看到此处的都不是一般有耐心的人，为你们鼓掌~也希望你们通过这篇文章能过对本文在开头提出的几个重点在心中有所体会和感悟：</p><blockquote><p>可以了解到测试的意义，<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>测试框架的搭建，前后端测试的异同点，如何写测试用例，如何查看测试结果并提升我们的测试覆盖率，100%测试覆盖率是否是必须，以及在搭建测试环境、以及测试本身过程中遇到的各种疑难杂症。</p></blockquote><p>本文所有的测试用例以及整体项目实例你都可以在我的<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>的github项目中找到源代码。如果你喜欢我的文章以及项目，欢迎点个star~如果你对我的文章和项目有任何建议或者意见，欢迎在文末评论或者在本项目的<a href="https://github.com/Molunerfinn/vue-koa-demo/issues" target="_blank" rel="noopener">issues</a>跟我探讨！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p>Koa相关</p></blockquote><p><a href="https://segmentfault.com/q/1010000006906863" target="_blank" rel="noopener">Supertest搭配koa报错</a></p><p><a href="http://facebook.github.io/jest/docs/en/cli.html#forceexit" target="_blank" rel="noopener">测试完自动退出</a></p><p><a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">Async testing Koa with Jest</a></p><p><a href="http://www.albertgao.xyz/2017/06/10/how-to-use-jest-to-test-express-middleware-or-a-function-which-consumes-a-callback/" target="_blank" rel="noopener">How to use Jest to test Express middleware or a funciton which consumes a callback?</a></p><p><a href="https://www.valentinog.com/blog/testing-api-koa-jest/" target="_blank" rel="noopener">A clear and concise introduction to testing Koa with Jest and Supertest</a></p><p><a href="https://github.com/Microsoft/vscode/issues/28007" target="_blank" rel="noopener">Debug jest with vscode</a></p><p><a href="https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment" target="_blank" rel="noopener">Test port question</a><br><a href="https://github.com/facebook/jest/issues/4777" target="_blank" rel="noopener">Coverage bug</a></p><p><a href="https://stackoverflow.com/questions/41733634/eaddrinuse-127-0-0-15858-during-jest-test-debugging" target="_blank" rel="noopener">Eaddrinuse bug</a></p><p><a href="https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md" target="_blank" rel="noopener">Istanbul ignore</a></p><blockquote><p>Vue相关</p></blockquote><p><a href="https://vue-test-utils.vuejs.org/en/" target="_blank" rel="noopener">vue-test-utils</a></p><p><a href="https://alexjoverm.github.io/2017/09/25/Test-Methods-and-Mock-Dependencies-in-Vue-js-with-Jest/" target="_blank" rel="noopener">Test Methods and Mock Dependencies in Vue.js with Jest</a></p><p><a href="https://stackoverflow.com/questions/30792076/mocking-sessionstorage-when-using-jestjs" target="_blank" rel="noopener">Storage problem</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今年一月份的时候我写了一个&lt;a href=&quot;https://github.com/Molunerfinn/vue-koa-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue+Koa的全栈应用&lt;/a&gt;，以及相应的&lt;a href=&quot;https://molunerfinn.com/Vue+Koa/&quot;&gt;配套教程&lt;/a&gt;，得到了很多的好评。同时我也在和读者交流的过程中不断认识到不足和缺点，于是也对此进行了不断的更新和完善。本次带来的完善是加入和完整的前后端测试。相信对于很多学习前端的朋友来说，&lt;code&gt;测试&lt;/code&gt;这个东西似乎是个熟悉的陌生人。你听过，但是你未必做过。如果你对前端（以及nodejs端）测试很熟悉，那么本文的帮助可能不大，不过我很希望能得到你们提出的宝贵意见！&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/Nodejs/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>把你的github操作从ssh转成https</title>
    <link href="https://molunerfinn.com/git-ssh2https/"/>
    <id>https://molunerfinn.com/git-ssh2https/</id>
    <published>2017-10-26T21:44:00.000Z</published>
    <updated>2018-11-19T15:29:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>从10月24日开始，由于总所周知的原因，某些地区一些运营商的网络环境下已经无法通过ssh的方式对一些国外服务器进行操作。很不幸github也因此被误杀。这对于广大程序猿来说，简直是一大噩耗。不过我发现通过https的方式还是可以对github进行操作的。毕竟技术是无罪的，不管怎么样，github总是要用的。所以可以将现有的ssh方式改成https。</p><a id="more"></a><h2 id="从ssh到https"><a href="#从ssh到https" class="headerlink" title="从ssh到https"></a>从ssh到https</h2><p>把原有项目从ssh的方式转成https其实很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url origin https://xxxxx <span class="comment">#your https repo url</span></span><br></pre></td></tr></table></figure><p>通过如下命令查看是否更改成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/xxx/xxx.github.io.git (fetch)</span><br><span class="line">origin  https://github.com/xxx/xxx.github.io.git (push)</span><br></pre></td></tr></table></figure><p>不过转成https之后会带来一个问题，那就是每次提交的时候都需要输入github的用户名密码。其实当初用ssh的方式除了安全之外很重要的一个原因就是不用每次都手动输入账号密码。不过其实https的方式也是可以实现的，只是需要一些额外配置。</p><h2 id="配置https免输入密码"><a href="#配置https免输入密码" class="headerlink" title="配置https免输入密码"></a>配置https免输入密码</h2><p>git官方手册里有对于<a href="https://git-scm.com/docs/git-credential-store" target="_blank" rel="noopener">git-credential-store</a>的描述。简单来说，就是将用户名和密码缓存在本地，每次提交的时候自动帮你填入用户名密码。</p><blockquote><p>注意git版本需要在1.7以上</p></blockquote><p>开启也很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>然后你对某个仓库第一次执行push操作的时候，会要求输入用户密码，之后就再也不用了：</p><blockquote><p>官方示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config credential.helper store</span><br><span class="line">$ git push http://example.com/repo.git</span><br><span class="line">Username: &lt;<span class="built_in">type</span> your username&gt;</span><br><span class="line">Password: &lt;<span class="built_in">type</span> your password&gt;</span><br><span class="line"></span><br><span class="line">[several days later]</span><br><span class="line">$ git push http://example.com/repo.git</span><br><span class="line">[your credentials are used automatically]</span><br></pre></td></tr></table></figure><p>通过store的方式会将你的账号密码以明文的形式存在<code>~/.git-credentials</code>文件里，大致长这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.git-credentials</span><br><span class="line">https://username:password@github.com</span><br></pre></td></tr></table></figure><p>如果你觉得这样不太安全，见下一章：</p><h2 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>对于mac而言，可以将git默认的<code>credential.helper</code>指定成<code>osxkeychain</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper osxkeychain</span><br></pre></td></tr></table></figure><p>然后可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config credential.helper</span><br><span class="line">osxkeychain</span><br></pre></td></tr></table></figure><p>来查看是否指定成功了。之后用户名密码将会保存在系统自带的<code>keychain access</code>里。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>使用微软开发的<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" target="_blank" rel="noopener">Git-Credential-Manager-for-Windows</a></p><p>最新版下载地址：<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest" target="_blank" rel="noopener">https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest</a></p><p>安装之后，在控制台里输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper manager</span><br></pre></td></tr></table></figure><p>之后还是一样的，某个项目里输入用户名密码之后，以后就再也不用输入了。你可以在<code>管理网络密码</code>里找到你的用户密码——其实不是密码，而是token了，因为<code>Git-Credential-Manager-for-Windows</code>它会自动调用github的api生成<code>Personal access tokens</code>，你可以在你的github的<code>Personal settings</code>里找到它。所以安全性还是有保障的！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你已经无法用ssh的方式连接github的话，不妨试试https的方式。至少目前来说还是有效的，而且配置也不难~Happy coding again！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从10月24日开始，由于总所周知的原因，某些地区一些运营商的网络环境下已经无法通过ssh的方式对一些国外服务器进行操作。很不幸github也因此被误杀。这对于广大程序猿来说，简直是一大噩耗。不过我发现通过https的方式还是可以对github进行操作的。毕竟技术是无罪的，不管怎么样，github总是要用的。所以可以将现有的ssh方式改成https。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="git" scheme="https://molunerfinn.com/tags/git/"/>
    
  </entry>
  
</feed>
